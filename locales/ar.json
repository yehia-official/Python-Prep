
{
  "theme": {
    "light": "فاتح",
    "dark": "داكن",
    "system": "النظام"
  },
  "home": {
    "hero": {
      "title": "Python Prep: من الصفر إلى الاحتراف.",
      "subtitle": "دليلك الشامل والمتكامل خطوة بخطوة لإتقان لغة بايثون. دروس منظمة، اختبارات تفاعلية، وملاحظات مدعومة بالذكاء الاصطناعي.",
      "cta": "ابدأ رحلتك التعليمية"
    },
    "why": {
      "title": "لماذا تعلم بايثون؟",
      "cards": {
        "beginner": {
          "title": "سهلة للمبتدئين",
          "text": "بناء جملة بايثون البسيط والنظيف يجعلها واحدة من أسهل لغات البرمجة للتعلم."
        },
        "versatile": {
          "title": "متعددة الاستخدامات",
          "text": "من تطوير الويب وعلوم البيانات إلى الذكاء الاصطناعي والأتمتة، يمكن لبايثون أن تفعل كل شيء."
        },
        "demand": {
          "title": "طلب مرتفع",
          "text": "مطورون بايثون مطلوبون بشدة في سوق العمل، مع رواتب تنافسية."
        }
      }
    },
    "learn": {
      "title": "ماذا ستتعلم",
      "more": "...وأكثر من ذلك بكثير!"
    },
    "finalCta": {
      "title": "هل أنت مستعد للبدء؟",
      "subtitle": "درسك الأول على بعد نقرة واحدة فقط. ابدأ رحلتك لتصبح خبيرًا في بايثون اليوم.",
      "cta": "ابدأ التعلم الآن"
    },
    "footer": {
      "rights": "Python Prep. جميع الحقوق محفوظة.",
      "designedBy": "تصميم <a href='https://www.linkedin.com/in/yehia-mohammed-1518a1222?utm_source=share&utm_campaign=share_via&utm_content=profile&utm_medium=android_app' target='_blank' rel='noopener noreferrer' class='text-primary hover:underline'>المهندس يحيى محمد</a>."
    }
  },
  "sidebar": {
    "loading": "جار التحميل",
    "yourProgress": "تقدمك",
    "complete": "مكتمل",
    "downloadCourse": "تحميل الدورة",
    "description": "الوصف",
    "content": "محتوى الدرس",
    "codeExample": "مثال الكود",
    "quiz": "اختبار"
  },
  "lesson": {
    "playground": {
      "title": "ملعب الأكواد",
      "description": "جرب المفاهيم من هذا الدرس. تم ملء مثال الكود مسبقًا من أجلك."
    },
    "quiz": {
      "title": "وقت الاختبار!",
      "description": "اختبر معلوماتك في هذا الدرس."
    }
  },
  "codeRunner": {
    "placeholder": "أدخل كود بايثون الخاص بك هنا",
    "run": "تشغيل الكود",
    "explain": "شرح الكود",
    "output": "الناتج",
    "running": "جاري تشغيل الكود",
    "explainingTitle": "الذكاء الاصطناعي يشرح...",
    "explainingDesc": "يقوم مدرسنا الذكي بتوليد شرح لك.",
    "explanationTitle": "شرح الكود بالذكاء الاصطناعي"
  },
  "quiz": {
    "incomplete": {
      "title": "اختبار غير مكتمل",
      "description": "يرجى الإجابة على جميع الأسئلة قبل الإرسال."
    },
    "submit": "إرسال الاختبار",
    "results": {
      "title": "اكتمل الاختبار!",
      "score": "لقد حصلت على {score}٪."
    },
    "feedback": {
      "analyzing": "جاري تحليل نتائجك...",
      "generating": "يقوم الذكاء الاصطناعي بتوليد ملاحظات مخصصة لك.",
      "title": "اقتراح سرعة تعلم مخصص",
      "suggestion": "اقتراح"
    },
    "tryAgain": "حاول مرة أخرى",
    "nextLesson": "الدرس التالي",
    "courseComplete": "تهانينا! لقد أكملت الدورة بنجاح!"
  },
  "curriculum": [
    {
      "id": "1",
      "title": "مقدمة إلى بايثون",
      "description": "تعلم أساسيات لغة بايثون ولماذا هي لغة شائعة للمبتدئين والخبراء على حد سواء.",
      "content": [
        "بايثون هي لغة برمجة عالية المستوى ومفسرة، تشتهر بقابليتها للقراءة وبناء جملتها البسيط. وهذا يجعلها خيارًا ممتازًا للمبتدئين.",
        "تم إنشاؤها بواسطة جيدو فان روسوم وتم إصدارها لأول مرة في عام 1991. تؤكد فلسفة تصميم بايثون على قابلية قراءة الكود مع استخدامها الملحوظ للمسافات البيضاء الهامة.",
        "يمكنك استخدام بايثون لتطوير الويب، وعلوم البيانات، والذكاء الاصطناعي، والمزيد. لنبدأ بمثال 'أهلاً بالعالم!' الكلاسيكي."
      ],
      "codeExample": "print(\"أهلاً بالعالم!\")",
      "quiz": [
        {
          "question": "من هو مبتكر لغة بايثون؟",
          "options": ["جيمس جوسلينج", "جيدو فان روسوم", "بيارن ستروستروب", "دينيس ريتشي"],
          "correctAnswer": "جيدو فان روسوم"
        },
        {
          "question": "ما هو التركيز الأساسي لفلسفة تصميم بايثون؟",
          "options": ["سرعة التنفيذ", "قابلية قراءة الكود", "إدارة الذاكرة", "بناء الجملة المعقد"],
          "correctAnswer": "قابلية قراءة الكود"
        },
        {
          "question": "ماذا يعني أن بايثون لغة 'مفسرة'؟",
          "options": ["يتم تحويل الكود إلى لغة الآلة قبل تشغيله", "يتم تشغيل الكود مباشرة سطرًا بسطر بواسطة برنامج آخر", "يجب كتابة الكود في محرر معين", "يمكن استخدام الكود فقط لتطوير الويب"],
          "correctAnswer": "يتم تشغيل الكود مباشرة سطرًا بسطر بواسطة برنامج آخر"
        },
        {
          "question": "أي من التالي ليس استخدامًا شائعًا لبايثون؟",
          "options": ["علوم البيانات", "تطوير الويب", "الذكاء الاصطناعي", "تنسيق صفحات الويب"],
          "correctAnswer": "تنسيق صفحات الويب"
        },
        {
          "question": "كيف تكتب تعليقًا من سطر واحد في بايثون؟",
          "options": ["// هذا تعليق", "/* هذا تعليق */", "# هذا تعليق", "<!-- هذا تعليق -->"],
          "correctAnswer": "# هذا تعليق"
        }
      ],
      "pacing": "medium"
    },
    {
      "id": "2",
      "title": "المتغيرات وأنواع البيانات",
      "description": "فهم كيفية تخزين وإدارة البيانات في بايثون باستخدام المتغيرات وأنواع البيانات المختلفة.",
      "content": [
        "في بايثون، يتم إنشاء المتغير في اللحظة التي تقوم فيها بتعيين قيمة له لأول مرة. لا تحتاج إلى التصريح عن نوع المتغير بشكل صريح.",
        "تحتوي بايثون على العديد من أنواع البيانات المضمنة. الأكثر شيوعًا هي: الأعداد الصحيحة (`int`)، والأعداد العشرية (`float`)، والنصوص (`str`)، والقيم المنطقية (`bool`).",
        "على سبيل المثال، يمكنك تخزين اسم شخص وعمره في متغيرات مثل هذا. يمكن استخدام دالة `type()` للتحقق من نوع بيانات المتغير."
      ],
      "codeExample": "name = \"أليس\"  # هذا نص (str)\nage = 30       # هذا عدد صحيح (int)\nheight = 5.5   # هذا عدد عشري (float)\nis_student = True # هذه قيمة منطقية (bool)\n\nprint(type(name))\nprint(type(age))",
      "quiz": [
        {
          "question": "أي من الطرق التالية هي الطريقة الصحيحة لتعيين سلسلة نصية لمتغير؟",
          "options": ["string name = 'بوب'", "name = 'بوب'", "name := 'بوب'", "let name = 'بوب'"],
          "correctAnswer": "name = 'بوب'"
        },
        {
          "question": "ماذا ستعيد الدالة `type(10.5)`؟",
          "options": ["int", "string", "float", "double"],
          "correctAnswer": "float"
        },
        {
          "question": "ما هو نوع البيانات المنطقي (boolean)؟",
          "options": ["عدد صحيح", "سلسلة من الأحرف", "رقم به فاصلة عشرية", "قيمة تكون إما True أو False"],
          "correctAnswer": "قيمة تكون إما True أو False"
        },
        {
          "question": "إذا قمت بتشغيل `x = 5` ثم `x = 'hello'`، فما هو نوع بيانات `x`؟",
          "options": ["int", "str", "error", "bool"],
          "correctAnswer": "str"
        },
        {
          "question": "يمكن أن تبدأ أسماء المتغيرات في بايثون برقم.",
          "options": ["صحيح", "خطأ"],
          "correctAnswer": "خطأ"
        }
      ],
      "pacing": "medium"
    },
    {
      "id": "3",
      "title": "تدفق التحكم: If/Else",
      "description": "تعلم كيفية اتخاذ القرارات في الكود الخاص بك باستخدام العبارات الشرطية.",
      "content": [
        "تسمح العبارات الشرطية لبرنامجك بتنفيذ كتل معينة من التعليمات البرمجية فقط إذا تم استيفاء شرط معين. أكثر العبارات الشرطية شيوعًا هي `if` و `elif` (else if) و `else`.",
        "تتحقق عبارة `if` من شرط ما. إذا كان `True`، يتم تنفيذ كتلة الكود الموجودة تحتها. إذا كان `False`، ينتقل البرنامج إلى الجزء التالي.",
        "يمكنك ربط شروط متعددة باستخدام `elif`، وتوفير إجراء افتراضي باستخدام `else` عندما لا يتم استيفاء أي من شروط `if` أو `elif`."
      ],
      "codeExample": "age = 18\n\nif age < 13:\n    print(\"أنت طفل.\")\nelif age < 20:\n    print(\"أنت مراهق.\")\nelse:\n    print(\"أنت بالغ.\")",
      "quiz": [
        {
          "question": "ما هي الكلمة المفتاحية المستخدمة لشروط 'else if' في بايثون؟",
          "options": ["elseif", "else if", "elif", "case"],
          "correctAnswer": "elif"
        },
        {
          "question": "في الكود المثال، ماذا سيتم طباعته إذا كان `age` يساوي 25؟",
          "options": ["أنت طفل.", "أنت مراهق.", "أنت بالغ.", "لن يتم طباعة أي شيء."],
          "correctAnswer": "أنت بالغ."
        },
        {
          "question": "أي من هذه المعاملات يتحقق من المساواة؟",
          "options": ["=", "==", "===", "!="],
          "correctAnswer": "=="
        },
        {
          "question": "هل يمكن أن توجد عبارة `if` بدون كتلة `else`؟",
          "options": ["نعم", "لا"],
          "correctAnswer": "نعم"
        },
        {
          "question": "ما هو الغرض من عبارة `else`؟",
          "options": ["للتحقق من شرط إضافي", "لتشغيل كود إذا كانت جميع الشروط السابقة خاطئة", "لإنهاء البرنامج", "لتعريف متغير"],
          "correctAnswer": "لتشغيل كود إذا كانت جميع الشروط السابقة خاطئة"
        }
      ],
      "pacing": "medium"
    },
    {
      "id": "4",
      "title": "الدوال",
      "description": "اكتشف كيفية كتابة كتل من التعليمات البرمجية القابلة لإعادة الاستخدام باستخدام الدوال.",
      "content": [
        "الدالة هي كتلة من التعليمات البرمجية المنظمة والقابلة لإعادة الاستخدام والتي تستخدم لأداء إجراء واحد ذي صلة. توفر الدوال نمطية أفضل لتطبيقك ودرجة عالية من إعادة استخدام الكود.",
        "يمكنك تعريف دالة باستخدام الكلمة المفتاحية `def`، متبوعة باسم الدالة والأقواس `()`.",
        "يمكن للدالة أن تأخذ وسائط (بيانات تمررها إليها) ويمكنها إرجاع بيانات كنتيجة باستخدام الكلمة المفتاحية `return`."
      ],
      "codeExample": "# دالة تأخذ رقمين وتعيد مجموعهما\ndef add_numbers(x, y):\n    return x + y\n\n# استدعاء الدالة وتخزين النتيجة\nresult = add_numbers(5, 3)\nprint(result)  # سيطبع هذا 8",
      "quiz": [
        {
          "question": "ما هي الكلمة المفتاحية المستخدمة لتعريف دالة في بايثون؟",
          "options": ["function", "def", "fun", "define"],
          "correctAnswer": "def"
        },
        {
          "question": "ماذا تفعل الكلمة المفتاحية `return` في الدالة؟",
          "options": ["تطبع قيمة على وحدة التحكم", "توقف تنفيذ الدالة", "تمرر البيانات مرة أخرى خارج الدالة", "تحدد اسم الدالة"],
          "correctAnswer": "تمرر البيانات مرة أخرى خارج الدالة"
        },
        {
          "question": "ماذا تسمى القيم التي يتم تمريرها إلى دالة؟",
          "options": ["معلمات (Parameters)", "متغيرات (Variables)", "وسائط (Arguments)", "قيم مرتجعة (Returns)"],
          "correctAnswer": "وسائط (Arguments)"
        },
        {
          "question": "هل يمكن استدعاء دالة دون تعريفها أولاً؟",
          "options": ["نعم", "لا"],
          "correctAnswer": "لا"
        },
        {
          "question": "يجب أن تحتوي الدالة دائمًا على عبارة `return`.",
          "options": ["صحيح", "خطأ"],
          "correctAnswer": "خطأ"
        }
      ],
      "pacing": "medium"
    },
    {
      "id": "5",
      "title": "القوائم (Lists) والصفوف (Tuples)",
      "description": "تعرف على أنواع بيانات التسلسل في بايثون: القوائم (القابلة للتغيير) والصفوف (غير القابلة للتغيير).",
      "content": [
        "القائمة هي مجموعة مرتبة وقابلة للتغيير. في بايثون، تُكتب القوائم بأقواس مربعة `[]`.",
        "يمكنك الوصول إلى العناصر عن طريق فهرستها (بدءًا من 0)، وتغييرها، وإضافة عناصر جديدة باستخدام `append()`، وإزالة العناصر باستخدام `remove()` أو `pop()`.",
        "الصف هو مجموعة مرتبة وغير قابلة للتغيير. في بايثون، تُكتب الصفوف بأقواس مستديرة `()`. بمجرد إنشاء الصف، لا يمكنك تغيير قيمه."
      ],
      "codeExample": "# قائمة\nmy_list = [1, \"apple\", 3.14]\nmy_list.append(\"new item\")\nprint(my_list) # [1, 'apple', 3.14, 'new item']\nprint(my_list[1]) # 'apple'\n\n# صف\nmy_tuple = (1, \"apple\", 3.14)\nprint(my_tuple[0]) # 1",
      "quiz": [
        {
          "question": "ما الرمز المستخدم لإنشاء قائمة؟",
          "options": ["()", "{}", "[]", "<>"],
          "correctAnswer": "[]"
        },
        {
          "question": "ما هو الفرق الرئيسي بين القائمة والصف؟",
          "options": ["القوائم مرتبة والصفوف ليست كذلك", "القوائم يمكن أن تحتوي على أي نوع بيانات، والصفوف تحتوي فقط على أرقام", "القوائم قابلة للتغيير، والصفوف غير قابلة للتغيير", "القوائم تستخدم الفهارس، والصفوف لا تستخدمها"],
          "correctAnswer": "القوائم قابلة للتغيير، والصفوف غير قابلة للتغيير"
        },
        {
          "question": "كيف تضيف عنصرًا إلى نهاية قائمة تسمى `my_list`؟",
          "options": ["my_list.add('new')", "my_list.append('new')", "my_list.insert('new')", "my_list.push('new')"],
          "correctAnswer": "my_list.append('new')"
        },
        {
          "question": "ما هو فهرس العنصر الأول في قائمة أو صف؟",
          "options": ["1", "0", "-1", "A"],
          "correctAnswer": "0"
        },
        {
          "question": "إذا حاولت تغيير عنصر في صف، ماذا يحدث؟",
          "options": ["يتم تحديث العنصر", "يتم إنشاء صف جديد", "تحصل على خطأ من نوع TypeError", "يتم إزالة العنصر"],
          "correctAnswer": "تحصل على خطأ من نوع TypeError"
        }
      ],
      "pacing": "medium"
    },
    {
      "id": "6",
      "title": "القواميس (Dictionaries) والمجموعات (Sets)",
      "description": "استكشف القواميس لأزواج المفتاح-القيمة والمجموعات للعناصر الفريدة.",
      "content": [
        "القاموس هو مجموعة مرتبة (في بايثون 3.7+)، قابلة للتغيير، ولا تسمح بالتكرارات. تُكتب القواميس بأقواس معقوفة `{}`, ولها مفاتيح وقيم.",
        "يمكنك الوصول إلى العناصر في القاموس عن طريق الإشارة إلى اسم مفتاحها، داخل الأقواس المربعة.",
        "المجموعة هي مجموعة غير مرتبة وغير قابلة للتغيير (لا يمكن تغيير العناصر)، وغير مفهرسة. تستخدم المجموعات أيضًا الأقواس المعقوفة، ولكنها تحتوي فقط على قيم، وليس أزواج مفتاح-قيمة. تقوم بإزالة الإدخالات المكررة تلقائيًا."
      ],
      "codeExample": "# قاموس\nmy_dict = {\n  \"brand\": \"Ford\",\n  \"model\": \"Mustang\",\n  \"year\": 1964\n}\nprint(my_dict[\"model\"]) # Mustang\n\n# مجموعة\nmy_set = {\"apple\", \"banana\", \"cherry\", \"apple\"}\nprint(my_set) # {'cherry', 'banana', 'apple'}",
      "quiz": [
        {
          "question": "كيف تصل إلى القيمة المرتبطة بالمفتاح 'brand' في `my_dict`؟",
          "options": ["my_dict(brand)", "my_dict['brand']", "my_dict.get_brand()", "my_dict[0]"],
          "correctAnswer": "my_dict['brand']"
        },
        {
          "question": "ما هي السمة الرئيسية للمجموعة؟",
          "options": ["تحافظ على العناصر بترتيب معين", "تخزن العناصر المكررة", "تخزن العناصر الفريدة فقط", "تستخدم أزواج مفتاح-قيمة"],
          "correctAnswer": "تخزن العناصر الفريدة فقط"
        },
        {
          "question": "أي بنية بيانات تستخدم أزواج مفتاح-قيمة؟",
          "options": ["List", "Tuple", "Set", "Dictionary"],
          "correctAnswer": "Dictionary"
        },
        {
          "question": "ما هو الرمز المستخدم لكل من القواميس والمجموعات؟",
          "options": ["()", "[]", "{}", "<>"],
          "correctAnswer": "{}"
        },
        {
          "question": "هل يمكنك تغيير عنصر في مجموعة بعد إنشائها؟",
          "options": ["نعم، باستخدام فهرسها", "نعم، باستخدام طريقة update()", "لا، عناصر المجموعة غير قابلة للتغيير", "لا، ولكن يمكنك إضافة وإزالة العناصر"],
          "correctAnswer": "لا، ولكن يمكنك إضافة وإزالة العناصر"
        }
      ],
      "pacing": "medium"
    },
    {
      "id": "7",
      "title": "حلقات For",
      "description": "تعلم كيفية التكرار عبر التسلسلات مثل القوائم والصفوف والنصوص باستخدام حلقات for.",
      "content": [
        "تُستخدم حلقة for للتكرار عبر تسلسل (سواء كان قائمة أو صفًا أو قاموسًا أو مجموعة أو نصًا).",
        "باستخدام حلقة for، يمكننا تنفيذ مجموعة من العبارات، مرة واحدة لكل عنصر في قائمة، صف، مجموعة، إلخ.",
        "غالبًا ما تُستخدم دالة `range()` مع حلقات for لإنشاء تسلسل من الأرقام."
      ],
      "codeExample": "fruits = [\"apple\", \"banana\", \"cherry\"]\nfor fruit in fruits:\n  print(fruit)\n\n# Using range()\nfor i in range(5): # This will loop from 0 to 4\n  print(i)",
      "quiz": [
        {
          "question": "ما هو استخدام حلقة for؟",
          "options": ["اتخاذ القرارات", "تعريف دالة", "التكرار عبر تسلسل", "تخزين البيانات"],
          "correctAnswer": "التكرار عبر تسلسل"
        },
        {
          "question": "في `for x in my_list:`، ما هو `x`؟",
          "options": ["فهرس العنصر الحالي", "القائمة نفسها", "العنصر الحالي في التسلسل", "عداد"],
          "correctAnswer": "العنصر الحالي في التسلسل"
        },
        {
          "question": "ما الأرقام التي ستنتجها `range(1, 4)`؟",
          "options": ["1, 2, 3, 4", "1, 2, 3", "0, 1, 2, 3", "1, 4"],
          "correctAnswer": "1, 2, 3"
        },
        {
          "question": "كيف يمكنك التكرار عبر مفاتيح قاموس `my_dict`؟",
          "options": ["for key in my_dict.keys():", "for key in my_dict:", "كلاهما صحيح", "لا شيء مما سبق"],
          "correctAnswer": "كلاهما صحيح"
        },
        {
          "question": "هل يمكنك التكرار عبر سلسلة نصية؟",
          "options": ["نعم، حرفًا بحرف", "لا، النصوص ليست تسلسلات", "فقط إذا قمت بتحويلها إلى قائمة أولاً"],
          "correctAnswer": "نعم، حرفًا بحرف"
        }
      ],
      "pacing": "medium"
    },
    {
      "id": "8",
      "title": "حلقات While",
      "description": "فهم كيفية تنفيذ كتلة من التعليمات البرمجية طالما كان الشرط صحيحًا.",
      "content": [
        "باستخدام حلقة while، يمكننا تنفيذ مجموعة من العبارات طالما كان الشرط صحيحًا.",
        "من المهم أن يكون لديك 'شرط خروج' في حلقة while الخاصة بك، وإلا فإنها ستستمر إلى الأبد، مما يؤدي إلى حلقة لا نهائية.",
        "يمكن استخدام عبارة `break` لإيقاف الحلقة حتى لو كان شرط while صحيحًا، ويمكن استخدام عبارة `continue` لإيقاف التكرار الحالي والمتابعة بالتكرار التالي."
      ],
      "codeExample": "i = 1\nwhile i < 6:\n  print(i)\n  if i == 3:\n    break  # الخروج من الحلقة عندما يكون i يساوي 3\n  i += 1",
      "quiz": [
        {
          "question": "متى تتوقف حلقة while؟",
          "options": ["بعد عدد ثابت من التكرارات", "عندما يصبح شرطها خاطئًا", "عندما ينتهي البرنامج", "عند استدعاء دالة"],
          "correctAnswer": "عندما يصبح شرطها خاطئًا"
        },
        {
          "question": "ما هي 'الحلقة اللانهائية'؟",
          "options": ["حلقة تعمل ببطء شديد", "حلقة لا تنتهي أبدًا لأن شرطها يظل دائمًا صحيحًا", "حلقة تستخدم الكثير من الذاكرة", "حلقة بها خطأ"],
          "correctAnswer": "حلقة لا تنتهي أبدًا لأن شرطها يظل دائمًا صحيحًا"
        },
        {
          "question": "ماذا تفعل عبارة `break` داخل الحلقة؟",
          "options": ["تتخطى بقية التكرار الحالي", "تخرج من الحلقة تمامًا", "توقف الحلقة مؤقتًا", "تعيد تشغيل الحلقة"],
          "correctAnswer": "تخرج من الحلقة تمامًا"
        },
        {
          "question": "ماذا تفعل عبارة `continue` داخل الحلقة؟",
          "options": ["تتخطى بقية التكرار الحالي وتنتقل إلى التالي", "تخرج من الحلقة تمامًا", "تنهي البرنامج", "تستمر من بداية نفس التكرار"],
          "correctAnswer": "تتخطى بقية التكرار الحالي وتنتقل إلى التالي"
        },
        {
          "question": "ما الذي يجب أن تتذكره لتضمينه في حلقة while لتجنب حلقة لا نهائية؟",
          "options": ["عبارة طباعة", "عبارة break", "طريقة لتغيير المتغير في الشرط (مثل i += 1)", "عبارة return"],
          "correctAnswer": "طريقة لتغيير المتغير في الشرط (مثل i += 1)"
        }
      ],
      "pacing": "medium"
    },
    {
      "id": "9",
      "title": "معالجة النصوص",
      "description": "تعلم طرقًا مختلفة للعمل مع النصوص وتنسيقها.",
      "content": [
        "تحتوي بايثون على مجموعة غنية من الدوال المضمنة التي يمكنك استخدامها على النصوص. نظرًا لأن النصوص غير قابلة للتغيير، فإن هذه الدوال تعيد نصوصًا جديدة ولا تعدل الأصلية.",
        "تشمل الدوال الشائعة `upper()`، `lower()`، `strip()` (لإزالة المسافات البيضاء)، `replace()`، و `split()` (لإنشاء قائمة من نص).",
        "F-strings (formatted string literals) هي طريقة قوية ومريحة لتضمين التعبيرات داخل النصوص للتنسيق."
      ],
      "codeExample": "my_string = \"  Hello, World!  \"\n\n# دوال شائعة\nprint(my_string.upper()) # \"  HELLO, WORLD!  \"\nprint(my_string.strip()) # \"Hello, World!\"\nprint(my_string.replace(\"World\", \"Python\")) # \"  Hello, Python!  \"\n\n# تنسيق F-string\nname = \"Yehia\"\nage = 25\nprint(f\"My name is {name} and I am {age} years old.\")",
      "quiz": [
        {
          "question": "أي دالة تحول النص إلى أحرف كبيرة؟",
          "options": ["capitalize()", "upper()", "to_upper()", "uppercase()"],
          "correctAnswer": "upper()"
        },
        {
          "question": "ماذا تفعل دالة `strip()`؟",
          "options": ["تزيل جميع الأحرف من النص", "تزيل المسافات البيضاء البادئة واللاحقة", "تقسم النص إلى قائمة", "تستبدل حرفًا"],
          "correctAnswer": "تزيل المسافات البيضاء البادئة واللاحقة"
        },
        {
          "question": "إذا كان `s = 'abc'`، هل `s.upper()` يغير قيمة `s`؟",
          "options": ["نعم، s تصبح 'ABC'", "لا، تعيد نصًا جديدًا 'ABC' ولكن s تظل 'abc'"],
          "correctAnswer": "لا، تعيد نصًا جديدًا 'ABC' ولكن s تظل 'abc'"
        },
        {
          "question": "كيف تبدأ f-string؟",
          "options": ["بحرف 'f' قبل علامة الاقتباس الافتتاحية", "بكلمة 'fmt' قبل علامة الاقتباس الافتتاحية", "بعلامة '%' داخل النص", "بـ .format() في النهاية"],
          "correctAnswer": "بحرف 'f' قبل علامة الاقتباس الافتتاحية"
        },
        {
          "question": "ماذا تفعل `split(',')` للنص؟",
          "options": ["تدمج النص مع الفواصل", "تزيل جميع الفواصل", "تقسم النص إلى قائمة من النصوص الفرعية عند كل فاصلة", "تجد فهرس أول فاصلة"],
          "correctAnswer": "تقسم النص إلى قائمة من النصوص الفرعية عند كل فاصلة"
        }
      ],
      "pacing": "medium"
    },
    {
      "id": "10",
      "title": "التعامل مع الملفات",
      "description": "تعلم كيفية القراءة من الملفات والكتابة إليها على جهاز الكمبيوتر الخاص بك.",
      "content": [
        "توفر بايثون دوال سهلة الاستخدام لإنشاء الملفات وقراءتها وكتابتها.",
        "تعد دالة `open()` هي المفتاح للعمل مع الملفات. تأخذ وسيطين: اسم الملف والوضع (`'r'` للقراءة، `'w'` للكتابة، `'a'` للإلحاق).",
        "من الممارسات الجيدة استخدام عبارة `with` عند التعامل مع كائنات الملفات. هذا له ميزة أن الملف يتم إغلاقه بشكل صحيح بعد انتهاء مجموعة التعليمات البرمجية الخاصة به، حتى لو حدث خطأ."
      ],
      "codeExample": "# الكتابة إلى ملف (ينشئ الملف إذا لم يكن موجودًا)\nwith open(\"myfile.txt\", \"w\", encoding='utf-8') as f:\n    f.write(\"أهلاً من بايثون!\\n\")\n    f.write(\"هذا سطر جديد.\\n\")\n\n# القراءة من ملف\nwith open(\"myfile.txt\", \"r\", encoding='utf-8') as f:\n    content = f.read()\n    print(content)",
      "quiz": [
        {
          "question": "ما هو الوضع لفتح ملف للكتابة؟",
          "options": ["'r'", "'x'", "'w'", "'a'"],
          "correctAnswer": "'w'"
        },
        {
          "question": "لماذا يوصى باستخدام بناء `with open(...)`؟",
          "options": ["يعمل بشكل أسرع", "يغلق الملف تلقائيًا", "يمكنه فتح أي نوع من الملفات", "يشفر الملف"],
          "correctAnswer": "يغلق الملف تلقائيًا"
        },
        {
          "question": "ماذا يفعل فتح ملف في وضع الإلحاق (`'a'`)؟",
          "options": ["يحذف الملف", "يقرأ الملف", "يكتب فوق محتوى الملف", "يضيف محتوى جديدًا إلى نهاية الملف"],
          "correctAnswer": "يضيف محتوى جديدًا إلى نهاية الملف"
        },
        {
          "question": "أي دالة تقرأ محتوى ملف بالكامل في سلسلة نصية واحدة؟",
          "options": ["read()", "readline()", "readlines()", "get_content()"],
          "correctAnswer": "read()"
        },
        {
          "question": "إذا فتحت ملفًا موجودًا في وضع الكتابة (`'w'`)، فماذا يحدث لمحتواه الأصلي؟",
          "options": ["يتم إضافة المحتوى الجديد إلى النهاية", "يحدث خطأ", "يتم مسح المحتوى الأصلي", "يتم نقل المحتوى الأصلي إلى ملف نسخ احتياطي"],
          "correctAnswer": "يتم مسح المحتوى الأصلي"
        }
      ],
      "pacing": "medium"
    },
    {
      "id": "11",
      "title": "معالجة الاستثناءات",
      "description": "تعلم كيفية التعامل مع الأخطاء بأمان باستخدام كتل try...except.",
      "content": [
        "تسمى الأخطاء التي يتم اكتشافها أثناء التنفيذ استثناءات. إذا لم يتم التعامل معها، فسوف توقف برنامجك.",
        "تتيح لك كتلة `try` اختبار كتلة من التعليمات البرمجية بحثًا عن الأخطاء.",
        "تتيح لك كتلة `except` التعامل مع الخطأ. يمكنك تحديد معالجات مختلفة لأنواع استثناءات مختلفة.",
        "تتيح لك كتلة `finally` تنفيذ التعليمات البرمجية، بغض النظر عن نتيجة كتل try-and-except."
      ],
      "codeExample": "try:\n  x = 10 / 0\nexcept ZeroDivisionError:\n  print(\"خطأ: لا يمكن القسمة على صفر!\")\nexcept TypeError:\n  print(\"خطأ: تم استخدام نوع بيانات غير صحيح.\")\nfinally:\n  print(\"سيتم تنفيذ هذا دائمًا.\")",
      "quiz": [
        {
          "question": "أي كتلة تحتوي على الكود الذي قد يسبب استثناءً؟",
          "options": ["except", "finally", "try", "if"],
          "correctAnswer": "try"
        },
        {
          "question": "ما هو الغرض من كتلة `finally`؟",
          "options": ["لمعالجة الخطأ", "للتسبب في خطأ", "لتنفيذ كود سواء حدث خطأ أم لا", "للإبلاغ عن الخطأ للمستخدم"],
          "correctAnswer": "لتنفيذ كود سواء حدث خطأ أم لا"
        },
        {
          "question": "ما نوع الخطأ الذي تثيره القسمة على صفر؟",
          "options": ["TypeError", "ValueError", "ZeroDivisionError", "SyntaxError"],
          "correctAnswer": "ZeroDivisionError"
        },
        {
          "question": "هل يمكنك الحصول على كتل `except` متعددة لكتلة `try` واحدة؟",
          "options": ["لا، يسمح بواحدة فقط", "نعم، للتعامل مع أنواع مختلفة من الاستثناءات"],
          "correctAnswer": "نعم، للتعامل مع أنواع مختلفة من الاستثناءات"
        },
        {
          "question": "ماذا يحدث إذا حدث استثناء ولم تكن هناك كتلة `except` للتعامل معه؟",
          "options": ["يستمر البرنامج كالمعتاد", "يتعطل البرنامج ويعرض رسالة خطأ", "يتجاهل البرنامج الخطأ بصمت", "يسأل البرنامج المستخدم ماذا يفعل"],
          "correctAnswer": "يتعطل البرنامج ويعرض رسالة خطأ"
        }
      ],
      "pacing": "medium"
    },
    {
      "id": "12",
      "title": "مقدمة في البرمجة الشيئية (OOP)",
      "description": "فهم المفاهيم الأساسية للبرمجة الشيئية (OOP).",
      "content": [
        "البرمجة الشيئية (OOP) هي نموذج برمجي يعتمد على مفهوم 'الكائنات'، التي يمكن أن تحتوي على بيانات وتعليمات برمجية.",
        "المفاهيم الرئيسية لـ OOP هي: التغليف، التجريد، الوراثة، وتعدد الأشكال.",
        "الفئة (Class) تشبه المخطط لإنشاء الكائنات. الكائن (Object) هو نسخة من فئة. فكر في فئة 'سيارة' كمخطط، وسيارتك المحددة ككائن (نسخة) من تلك الفئة."
      ],
      "codeExample": "# هذا مجرد مثال مفاهيمي. سنقوم بتعريف فئة في الدرس التالي.\nclass Car:\n  # السمات (البيانات) والدوال (الكود) توضع هنا\n  pass\n\n# إنشاء كائنات (نسخ) من فئة السيارة\nmy_car = Car()\nyour_car = Car()",
      "quiz": [
        {
          "question": "ما هي 'الفئة' (Class) في البرمجة الشيئية؟",
          "options": ["جزء من البيانات", "دالة", "مخطط لإنشاء الكائنات", "كائن بحد ذاته"],
          "correctAnswer": "مخطط لإنشاء الكائنات"
        },
        {
          "question": "ما هو 'الكائن' (Object) في البرمجة الشيئية؟",
          "options": ["نوع من المتغيرات", "نسخة من فئة", "نموذج برمجي", "ملف"],
          "correctAnswer": "نسخة من فئة"
        },
        {
          "question": "أي من التالي ليس مفهومًا أساسيًا في البرمجة الشيئية؟",
          "options": ["الوراثة", "تعدد الأشكال", "التغليف", "التكرار"],
          "correctAnswer": "التكرار"
        },
        {
          "question": "يُطلق على مفهوم تجميع البيانات والدوال التي تعمل على تلك البيانات داخل وحدة واحدة ...؟",
          "options": ["الوراثة", "التجريد", "التغليف", "تعدد الأشكال"],
          "correctAnswer": "التغليف"
        },
        {
          "question": "تُعرف قدرة الكائن على اتخاذ أشكال عديدة بـ ...؟",
          "options": ["الوراثة", "تعدد الأشكال", "التغليف", "التجريد"],
          "correctAnswer": "تعدد الأشكال"
        }
      ],
      "pacing": "medium"
    },
    {
      "id": "13",
      "title": "الفئات والكائنات",
      "description": "تعلم كيفية تعريف الفئات الخاصة بك وإنشاء الكائنات في بايثون.",
      "content": [
        "لإنشاء فئة، استخدم الكلمة المفتاحية `class`.",
        "تحتوي جميع الفئات على دالة تسمى `__init__()`، والتي يتم تنفيذها دائمًا عند بدء تشغيل الفئة. استخدمها لتعيين قيم لخصائص الكائن.",
        "يمكن أن تحتوي الكائنات أيضًا على دوال. الدوال في الكائنات هي دوال تنتمي إلى الكائن."
      ],
      "codeExample": "class Dog:\n  # دالة __init__ هي المُنشئ\n  def __init__(self, name, age):\n    self.name = name  # سمة نسخة\n    self.age = age    # سمة نسخة\n\n  # دالة\n  def bark(self):\n    return f\"{self.name} يقول نباح!\"\n\n# إنشاء كائن كلب\nmy_dog = Dog(\"فيدو\", 5)\n\nprint(my_dog.name)\nprint(my_dog.bark())",
      "quiz": [
        {
          "question": "ما هو اسم دالة المُنشئ في فئة بايثون؟",
          "options": ["__main__", "__construct__", "__init__", "__setup__"],
          "correctAnswer": "__init__"
        },
        {
          "question": "إلى ماذا يشير المعلم `self`؟",
          "options": ["الفئة نفسها", "النسخة الحالية من الفئة", "متغير عام", "الفئة الأصل"],
          "correctAnswer": "النسخة الحالية من الفئة"
        },
        {
          "question": "كيف تنشئ نسخة من فئة تسمى `Cat`؟",
          "options": ["my_cat = Cat", "my_cat = new Cat()", "my_cat = Cat()", "create Cat() as my_cat"],
          "correctAnswer": "my_cat = Cat()"
        },
        {
          "question": "تسمى المتغيرات التي تنتمي إلى نسخة...",
          "options": ["سمات الفئة", "سمات عامة", "سمات النسخة", "سمات ثابتة"],
          "correctAnswer": "سمات النسخة"
        },
        {
          "question": "تسمى الدوال المعرفة داخل فئة...",
          "options": ["إجراءات", "دوال (Methods)", "تعاريف", "لامدا"],
          "correctAnswer": "دوال (Methods)"
        }
      ],
      "pacing": "medium"
    },
    {
      "id": "14",
      "title": "الوراثة وتعدد الأشكال",
      "description": "تعلم كيفية إنشاء فئات جديدة من فئات موجودة وكيف يمكن للكائنات مشاركة السلوكيات.",
      "content": [
        "تسمح لنا الوراثة بتعريف فئة ترث جميع الدوال والخصائص من فئة أخرى.",
        "الفئة الأصل هي الفئة التي يتم الوراثة منها، وتسمى أيضًا الفئة الأساسية. الفئة الفرعية هي الفئة التي ترث من فئة أخرى، وتسمى أيضًا الفئة المشتقة.",
        "تعدد الأشكال يعني 'أشكال عديدة'، ويشير إلى قدرة فئات مختلفة على أن تُعامل كنسخ من نفس الفئة من خلال الوراثة. يسمح للدوال بالقيام بأشياء مختلفة بناءً على الكائن الذي تعمل عليه."
      ],
      "codeExample": "# الفئة الأصل\nclass Animal:\n  def speak(self):\n    return \"صوت حيوان ما\"\n\n# الفئة الفرعية التي ترث من Animal\nclass Cat(Animal):\n  def speak(self): # تجاوز الدالة\n    return \"مواء\"\n\n# فئة فرعية أخرى\nclass Dog(Animal):\n  def speak(self): # تجاوز الدالة\n    return \"نباح\"\n\ncat = Cat()\ndog = Dog()\nprint(cat.speak()) # يطبع \"مواء\"\nprint(dog.speak()) # يطبع \"نباح\"",
      "quiz": [
        {
          "question": "ما هي الفائدة الأساسية للوراثة؟",
          "options": ["كود أسرع", "إعادة استخدام الكود", "بناء جملة أبسط", "إدارة ذاكرة أفضل"],
          "correctAnswer": "إعادة استخدام الكود"
        },
        {
          "question": "كيف تشير إلى أن فئة `Child` ترث من `Parent`؟",
          "options": ["class Child(Parent):", "class Child inherits Parent:", "class Child extends Parent:", "class Child < Parent:"],
          "correctAnswer": "class Child(Parent):"
        },
        {
          "question": "عندما توفر فئة فرعية تنفيذها الخاص لدالة معرفة بالفعل في فئتها الأصل، يطلق على ذلك...؟",
          "options": ["تحميل زائد للدالة", "تجاوز الدالة", "إخفاء الدالة", "نسخ الدالة"],
          "correctAnswer": "تجاوز الدالة"
        },
        {
          "question": "المفهوم الموضح بـ `cat.speak()` و `dog.speak()` اللذين يعيدان نتائج مختلفة هو...؟",
          "options": ["الوراثة", "التغليف", "تعدد الأشكال", "التجريد"],
          "correctAnswer": "تعدد الأشكال"
        },
        {
          "question": "تسمى الفئة التي يتم الوراثة منها...",
          "options": ["فئة فرعية", "فئة مشتقة", "فئة فرعية (Subclass)", "فئة أصل (أو فئة أساسية)"],
          "correctAnswer": "فئة أصل (أو فئة أساسية)"
        }
      ],
      "pacing": "fast"
    },
    {
      "id": "15",
      "title": "الوحدات النمطية والحزم",
      "description": "تعلم كيفية تنظيم الكود الخاص بك في وحدات نمطية وحزم.",
      "content": [
        "الوحدة النمطية هي ببساطة ملف يحتوي على كود بايثون. يمكنك استخدام عبارة `import` لاستخدام الكود من وحدة نمطية في أخرى.",
        "تأتي بايثون مع مكتبة ضخمة من الوحدات النمطية القياسية التي يمكنك استخدامها، مثل `math` للدوال الرياضية أو `datetime` للعمل مع التواريخ.",
        "الحزمة هي طريقة لهيكلة مساحة أسماء الوحدات النمطية في بايثون باستخدام 'أسماء الوحدات النمطية المنقطة'. الحزمة هي دليل يحتوي على وحدات بايثون نمطية ويحتوي على ملف `__init__.py`."
      ],
      "codeExample": "# استيراد وحدة math بأكملها\nimport math\nprint(math.pi)\n\n# استيراد دالة معينة من وحدة datetime\nfrom datetime import date\ntoday = date.today()\nprint(today)\n\n# يمكنك أيضًا إعطاء اسم مستعار لوحدة مستوردة\nimport math as m\nprint(m.sqrt(16))",
      "quiz": [
        {
          "question": "ما هي وحدة بايثون النمطية؟",
          "options": ["دالة مضمنة", "ملف بايثون يحتوي على كود", "مجلد من النصوص البرمجية", "نوع من الفئات"],
          "correctAnswer": "ملف بايثون يحتوي على كود"
        },
        {
          "question": "ما هي الكلمة المفتاحية المستخدمة لجلب كود وحدة نمطية إلى النص البرمجي الحالي؟",
          "options": ["include", "use", "import", "load"],
          "correctAnswer": "import"
        },
        {
          "question": "كيف تستورد الثابت `pi` فقط من وحدة `math`؟",
          "options": ["import math.pi", "from math import pi", "import pi from math", "using math.pi"],
          "correctAnswer": "from math import pi"
        },
        {
          "question": "ماذا تسمى مجموعة من الوحدات النمطية في دليل؟",
          "options": ["مكتبة", "مجموعة", "حزمة", "مجموعة (Set)"],
          "correctAnswer": "حزمة"
        },
        {
          "question": "ما هو الغرض من `import math as m`؟",
          "options": ["لإنشاء نسخة من وحدة math", "لإعطاء وحدة math اسمًا مستعارًا أقصر، `m`", "لاستيراد وحدة تسمى 'm'", "لتشغيل الدالة الرئيسية لوحدة math"],
          "correctAnswer": "لإعطاء وحدة math اسمًا مستعارًا أقصر، `m`"
        }
      ],
      "pacing": "medium"
    },
    {
      "id": "16",
      "title": "مكتبة بايثون القياسية",
      "description": "استكشف بعضًا من أكثر الوحدات النمطية فائدة المضمنة مع بايثون.",
      "content": [
        "مكتبة بايثون القياسية هي مجموعة واسعة من الوحدات النمطية التي تأتي مع كل تثبيت قياسي لبايثون.",
        "لا تحتاج إلى تثبيتها بشكل منفصل. تحتاج فقط إلى استيرادها.",
        "تشمل بعض الوحدات النمطية الأساسية `os` للتفاعل مع نظام التشغيل، و `sys` للمعلمات الخاصة بالنظام، و `random` لتوليد أرقام عشوائية، و `json` للعمل مع بيانات JSON."
      ],
      "codeExample": "import random\nimport os\n\n# توليد عدد صحيح عشوائي بين 1 و 10\nrandom_number = random.randint(1, 10)\nprint(f\"رقم عشوائي: {random_number}\")\n\n# الحصول على دليل العمل الحالي\ncurrent_directory = os.getcwd()\nprint(f\"الدليل الحالي: {current_directory}\")",
      "quiz": [
        {
          "question": "أي وحدة نمطية ستستخدمها للحصول على الدليل الحالي؟",
          "options": ["sys", "os", "path", "system"],
          "correctAnswer": "os"
        },
        {
          "question": "لتوليد عدد عشري عشوائي بين 0.0 و 1.0، ستستخدم...",
          "options": ["random.randint(0, 1)", "random.random()", "random.float()", "random.uniform(0, 1)"],
          "correctAnswer": "random.random()"
        },
        {
          "question": "هل تحتاج إلى تثبيت الوحدات النمطية من المكتبة القياسية باستخدام pip؟",
          "options": ["نعم، دائمًا", "لا، تأتي مع بايثون", "فقط على ويندوز", "فقط على ماك"],
          "correctAnswer": "لا، تأتي مع بايثون"
        },
        {
          "question": "تُستخدم وحدة `json` لـ...",
          "options": ["العمل مع كود جافا سكريبت", "إنشاء واجهات مستخدم", "تحليل وتوليد بيانات JSON", "العمليات الرياضية"],
          "correctAnswer": "تحليل وتوليد بيانات JSON"
        },
        {
          "question": "أي وحدة نمطية توفر الوصول إلى معلمات ووظائف خاصة بالنظام؟",
          "options": ["os", "sys", "system", "platform"],
          "correctAnswer": "sys"
        }
      ],
      "pacing": "medium"
    },
    {
      "id": "17",
      "title": "List Comprehensions",
      "description": "تعلم طريقة موجزة لإنشاء القوائم.",
      "content": [
        "توفر List comprehensions بناء جملة أقصر لإنشاء قائمة جديدة بناءً على قيم قائمة موجودة.",
        "تتكون من أقواس تحتوي على تعبير متبوع بعبارة `for`، ثم صفر أو أكثر من عبارات `for` أو `if`.",
        "هذا يمكن أن يجعل الكود الخاص بك في كثير من الأحيان أكثر قابلية للقراءة والتعبير مقارنة باستخدام حلقة for التقليدية لإنشاء قائمة."
      ],
      "codeExample": "# الطريقة التقليدية\nsquares = []\nfor x in range(10):\n  squares.append(x**2)\nprint(squares)\n\n# طريقة list comprehension\nsquares_comp = [x**2 for x in range(10)]\nprint(squares_comp)\n\n# مع شرط\neven_squares = [x**2 for x in range(10) if x % 2 == 0]\nprint(even_squares)",
      "quiz": [
        {
          "question": "ما هي الفائدة الرئيسية من list comprehensions؟",
          "options": ["تعمل بشكل أسرع", "توفر بناء جملة أكثر إيجازًا وقابلية للقراءة لإنشاء القوائم", "يمكنها القيام بأشياء لا تستطيع حلقات for القيام بها", "تستخدم ذاكرة أقل"],
          "correctAnswer": "توفر بناء جملة أكثر إيجازًا وقابلية للقراءة لإنشاء القوائم"
        },
        {
          "question": "أي من هذه هي list comprehension صالحة؟",
          "options": ["(x for x in range(5))", "[x for x in range(5)]", "{x for x in range(5)}", "list(x for x in range(5))"],
          "correctAnswer": "[x for x in range(5)]"
        },
        {
          "question": "كيف يمكنك إنشاء قائمة بجميع الأحرف الكبيرة في سلسلة نصية `s`؟",
          "options": ["[char.upper() for char in s]", "[char for char in s if char.isupper()]", "{char for char in s if char.isupper()}", "[char.upper() if char.islower() for char in s]"],
          "correctAnswer": "[char for char in s if char.isupper()]"
        },
        {
          "question": "هل يمكنك تضمين شرط `if` في list comprehension؟",
          "options": ["لا، يُسمح فقط بحلقات for", "نعم، لتصفية العناصر", "نعم، ولكن في البداية فقط", "لا، هذا يتطلب دالة لامدا"],
          "correctAnswer": "نعم، لتصفية العناصر"
        },
        {
          "question": "ماذا تُقيّم `[num * 2 for num in [1, 2, 3]]`؟",
          "options": ["[1, 2, 3]", "[1, 4, 9]", "[2, 4, 6]", "[2, 2, 2]"],
          "correctAnswer": "[2, 4, 6]"
        }
      ],
      "pacing": "fast"
    },
    {
      "id": "18",
      "title": "دوال لامدا",
      "description": "تعلم كيفية إنشاء دوال صغيرة ومجهولة الاسم بسرعة.",
      "content": [
        "دالة لامدا هي دالة صغيرة مجهولة الاسم.",
        "يمكن لدالة لامدا أن تأخذ أي عدد من الوسائط، ولكن يمكن أن يكون لها تعبير واحد فقط.",
        "من الأفضل استخدامها عندما تحتاج إلى دالة صغيرة لفترة قصيرة، غالبًا كوسيط لدالة من الدرجة الأعلى مثل `map()` أو `filter()`."
      ],
      "codeExample": "# دالة عادية\ndef double(n):\n  return n * 2\n\n# دالة لامدا المكافئة\ndouble_lambda = lambda n: n * 2\n\nprint(double(5))\nprint(double_lambda(5))\n\n# استخدام لامدا مع دوال أخرى\nmy_list = [1, 2, 3, 4]\ndoubled_list = list(map(lambda x: x * 2, my_list))\nprint(doubled_list)",
      "quiz": [
        {
          "question": "ما هي الكلمة المفتاحية المستخدمة لإنشاء دالة لامدا؟",
          "options": ["def", "anon", "lambda", "function"],
          "correctAnswer": "lambda"
        },
        {
          "question": "ما هو القيد الرئيسي لدوال لامدا؟",
          "options": ["يمكن أن يكون لها وسيط واحد فقط", "لا يمكن تخزينها في متغير", "يمكن أن تحتوي على تعبير واحد فقط", "لا يمكن استخدامها مع القوائم"],
          "correctAnswer": "يمكن أن تحتوي على تعبير واحد فقط"
        },
        {
          "question": "ما هي الدالة 'المجهولة'؟",
          "options": ["دالة سرية", "دالة بدون اسم", "دالة غير آمنة", "دالة لا تعيد شيئًا"],
          "correctAnswer": "دالة بدون اسم"
        },
        {
          "question": "أي من هذه هي دالة لامدا صالحة تضيف رقمين؟",
          "options": ["lambda a, b: return a + b", "lambda a, b: a + b", "lambda (a, b): a + b", "def lambda(a, b): a + b"],
          "correctAnswer": "lambda a, b: a + b"
        },
        {
          "question": "متى تستخدم دوال لامدا بشكل شائع؟",
          "options": ["كدوال مستقلة", "لتعريف دوال الفئة", "كوسائط لدوال من الدرجة الأعلى", "لإدخال/إخراج الملفات"],
          "correctAnswer": "كوسائط لدوال من الدرجة الأعلى"
        }
      ],
      "pacing": "fast"
    },
    {
      "id": "19",
      "title": "Map، Filter، و Reduce",
      "description": "تعرف على الدوال المضمنة القوية للعمل مع الكائنات القابلة للتكرار.",
      "content": [
        "تنفذ دالة `map()` دالة محددة لكل عنصر في كائن قابل للتكرار. يتم إرسال العنصر إلى الدالة كمعامل.",
        "تعيد دالة `filter()` مكررًا حيث يتم تصفية العناصر من خلال دالة لاختبار ما إذا كان العنصر مقبولاً أم لا.",
        "تقوم دالة `reduce()` بإجراء عملية حسابية متداولة على زوج متسلسل من القيم في قائمة. وهي جزء من وحدة `functools`."
      ],
      "codeExample": "from functools import reduce\n\nnumbers = [1, 2, 3, 4, 5]\n\n# Map: تطبيق دالة على كل عنصر\ndoubled = map(lambda x: x * 2, numbers)\nprint(list(doubled)) # [2, 4, 6, 8, 10]\n\n# Filter: الاحتفاظ بالعناصر التي تعيد الدالة لها true\nevens = filter(lambda x: x % 2 == 0, numbers)\nprint(list(evens)) # [2, 4]\n\n# Reduce: تجميع قائمة في قيمة واحدة\nsum_of_all = reduce(lambda x, y: x + y, numbers)\nprint(sum_of_all) # 15",
      "quiz": [
        {
          "question": "أي دالة ستستخدمها لتطبيق نفس العملية على كل عنصر في قائمة؟",
          "options": ["filter", "reduce", "map", "apply"],
          "correctAnswer": "map"
        },
        {
          "question": "أي دالة ستستخدمها لإنشاء قائمة جديدة تحتوي فقط على العناصر التي تحقق شرطًا معينًا؟",
          "options": ["filter", "reduce", "map", "select"],
          "correctAnswer": "filter"
        },
        {
          "question": "أي وحدة نمطية تحتوي على دالة `reduce`؟",
          "options": ["itertools", "collections", "functools", "math"],
          "correctAnswer": "functools"
        },
        {
          "question": "يجب أن تعيد الدالة التي يتم تمريرها إلى `filter()`...",
          "options": ["رقمًا", "سلسلة نصية", "قيمة منطقية (True أو False)", "قائمة"],
          "correctAnswer": "قيمة منطقية (True أو False)"
        },
        {
          "question": "ما هي نتيجة `reduce(lambda x, y: x + y, [1, 2, 3])`؟",
          "options": ["3", "5", "6", "خطأ"],
          "correctAnswer": "6"
        }
      ],
      "pacing": "fast"
    },
    {
      "id": "20",
      "title": "المزخرفات (Decorators)",
      "description": "تعلم كيفية تعديل أو تحسين الدوال دون تغيير الكود الخاص بها.",
      "content": [
        "المزخرفات هي ميزة قوية ومرنة في بايثون تسمح لك بإضافة وظائف إلى دالة أو طريقة موجودة دون تعديل شفرتها المصدرية.",
        "المزخرف هو دالة تأخذ دالة أخرى كوسيط، وتضيف نوعًا من الوظائف، ثم تعيد دالة أخرى.",
        "يمكنك تطبيق مزخرف على دالة باستخدام الرمز `@` متبوعًا باسم المزخرف، ويوضع مباشرة فوق تعريف الدالة."
      ],
      "codeExample": "def my_decorator(func):\n    def wrapper():\n        print(\"شيء ما يحدث قبل استدعاء الدالة.\")\n        func()\n        print(\"شيء ما يحدث بعد استدعاء الدالة.\")\n    return wrapper\n\n@my_decorator\ndef say_hello():\n    print(\"أهلاً!\")\n\nsay_hello()",
      "quiz": [
        {
          "question": "ما هو المزخرف في بايثون؟",
          "options": ["نوع من الفئات", "دالة تعدل دالة أخرى", "بناء جملة للتعليقات", "طريقة لتنسيق الكود"],
          "correctAnswer": "دالة تعدل دالة أخرى"
        },
        {
          "question": "ما الرمز المستخدم لتطبيق مزخرف؟",
          "options": ["#", "$", "&", "@"],
          "correctAnswer": "@"
        },
        {
          "question": "ماذا تعيد دالة المزخرف عادةً؟",
          "options": ["الدالة الأصلية، غير معدلة", "دالة جديدة (غلاف)", "قيمة منطقية", "لا شيء"],
          "correctAnswer": "دالة جديدة (غلاف)"
        },
        {
          "question": "هل يمكنك تطبيق مزخرفات متعددة على دالة واحدة؟",
          "options": ["لا، يُسمح بواحدة فقط", "نعم، يتم تطبيقها من الأسفل إلى الأعلى"],
          "correctAnswer": "نعم، يتم تطبيقها من الأسفل إلى الأعلى"
        },
        {
          "question": "حالة استخدام شائعة للمزخرفات هي...",
          "options": ["الحسابات الرياضية", "تسجيل أو توقيت تنفيذ الدالة", "تخزين البيانات", "تعريف المتغيرات"],
          "correctAnswer": "تسجيل أو توقيت تنفيذ الدالة"
        }
      ],
      "pacing": "fast"
    },
    {
      "id": "21",
      "title": "المولدات (Generators)",
      "description": "تعلم كيفية إنشاء المكررات بطريقة بسيطة وفعالة من حيث الذاكرة.",
      "content": [
        "المولدات هي طريقة بسيطة لإنشاء المكررات. هي دوال تستخدم الكلمة المفتاحية `yield` لإعادة سلسلة من القيم، واحدة تلو الأخرى.",
        "على عكس الدوال العادية التي تحسب قيمة وتعيدها، 'تنتج' المولدات قيمًا. في كل مرة تستدعي فيها `next()` على مولد، فإنه يستأنف التنفيذ من حيث توقف آخر مرة.",
        "هذا فعال جدًا من حيث الذاكرة للعمل مع مجموعات بيانات كبيرة، لأنه لا يخزن جميع القيم في الذاكرة دفعة واحدة."
      ],
      "codeExample": "# دالة مولد\ndef countdown(num):\n    print(\"البداية\")\n    while num > 0:\n        yield num\n        num -= 1\n\n# إنشاء كائن مولد\ngen = countdown(3)\n\nprint(next(gen)) # يطبع البداية، ثم 3\nprint(next(gen)) # يطبع 2\nprint(next(gen)) # يطبع 1",
      "quiz": [
        {
          "question": "ما هي الكلمة المفتاحية المستخدمة في دالة المولد لإنتاج قيمة؟",
          "options": ["return", "generate", "yield", "produce"],
          "correctAnswer": "yield"
        },
        {
          "question": "ما هي الميزة الرئيسية لاستخدام المولدات؟",
          "options": ["إنها أسرع من الدوال العادية", "إنها فعالة من حيث الذاكرة", "إنها أسهل في الكتابة", "يمكن استخدامها كمزخرفات"],
          "correctAnswer": "إنها فعالة من حيث الذاكرة"
        },
        {
          "question": "ماذا يحدث عند استدعاء دالة المولد؟",
          "options": ["تنفذ الدالة بأكملها وتعيد قائمة", "تعيد كائن مولد", "تثير خطأ على الفور", "تطبع جميع القيم على وحدة التحكم"],
          "correctAnswer": "تعيد كائن مولد"
        },
        {
          "question": "كيف تحصل على القيمة التالية من مولد `gen`؟",
          "options": ["gen.next()", "next(gen)", "gen.get()", "gen.yield()"],
          "correctAnswer": "next(gen)"
        },
        {
          "question": "ماذا يحدث عندما ينتج المولد جميع قيمه وتستدعي `next()` عليه مرة أخرى؟",
          "options": ["يبدأ من جديد من البداية", "يثير استثناء StopIteration", "يعيد None", "ينتظر المزيد من البيانات"],
          "correctAnswer": "يثير استثناء StopIteration"
        }
      ],
      "pacing": "fast"
    },
    {
      "id": "22",
      "title": "العمل مع JSON",
      "description": "تعلم كيفية تحليل وإنشاء بيانات JSON، وهو تنسيق شائع لتبادل البيانات.",
      "content": [
        "JSON (JavaScript Object Notation) هو تنسيق خفيف لتبادل البيانات. من السهل على البشر قراءته وكتابته ومن السهل على الآلات تحليله وتوليده.",
        "تحتوي بايثون على حزمة مضمنة تسمى `json`، والتي يمكن استخدامها للعمل مع بيانات JSON.",
        "تُستخدم دالة `json.loads()` لتحليل سلسلة JSON إلى قاموس بايثون. تُستخدم دالة `json.dumps()` لتحويل قاموس بايثون إلى سلسلة JSON."
      ],
      "codeExample": "import json\n\n# قاموس بايثون\nperson_dict = {'name': 'Yehia', 'age': 30, 'city': 'New York'}\n\n# تحويل القاموس إلى سلسلة JSON\njson_string = json.dumps(person_dict, indent=4, ensure_ascii=False)\nprint(\"سلسلة JSON:\")\nprint(json_string)\n\n# تحويل سلسلة JSON مرة أخرى إلى قاموس\nparsed_dict = json.loads(json_string)\nprint(\"\\nالقاموس المحلل:\")\nprint(parsed_dict['name'])",
      "quiz": [
        {
          "question": "ماذا يرمز JSON؟",
          "options": ["Java Standard Object Notation", "JavaScript Object Notation", "JavaScript Ordered Notation", "Java Source Object Notation"],
          "correctAnswer": "JavaScript Object Notation"
        },
        {
          "question": "أي دالة `json` تحول قاموس بايثون إلى سلسلة JSON؟",
          "options": ["json.load()", "json.loads()", "json.dump()", "json.dumps()"],
          "correctAnswer": "json.dumps()"
        },
        {
          "question": "أي دالة `json` تحلل سلسلة JSON إلى كائن بايثون؟",
          "options": ["json.load()", "json.loads()", "json.dump()", "json.dumps()"],
          "correctAnswer": "json.loads()"
        },
        {
          "question": "ما هو نوع بيانات بايثون الذي يتوافق معه كائن JSON عادةً؟",
          "options": ["قائمة", "صف", "قاموس", "مجموعة"],
          "correctAnswer": "قاموس"
        },
        {
          "question": "في `json.dumps(data, indent=4)`، ما هو الغرض من `indent=4`؟",
          "options": ["يجعل سلسلة JSON أكثر إحكامًا", "يضيف 4 مسافات من المسافة البادئة للطباعة الجميلة", "يشفر البيانات 4 مرات", "يحد من عمق JSON إلى 4 مستويات"],
          "correctAnswer": "يضيف 4 مسافات من المسافة البادئة للطباعة الجميلة"
        }
      ],
      "pacing": "medium"
    },
    {
      "id": "23",
      "title": "مقدمة في واجهات برمجة التطبيقات (APIs)",
      "description": "فهم ما هي واجهات برمجة التطبيقات وكيفية التفاعل معها باستخدام بايثون.",
      "content": [
        "API تعني واجهة برمجة التطبيقات. هي مجموعة من القواعد التي تسمح لتطبيقات البرامج المختلفة بالتواصل مع بعضها البعض.",
        "واجهات برمجة تطبيقات الويب شائعة جدًا. تسمح لك بالحصول على بيانات من خدمات أخرى، مثل معلومات الطقس، ومنشورات وسائل التواصل الاجتماعي، أو أسعار الأسهم.",
        "تعد مكتبة `requests` الطريقة الأكثر شيوعًا لتقديم طلبات HTTP إلى واجهات برمجة التطبيقات في بايثون. يمكنك تقديم طلبات GET لاسترداد البيانات وطلبات POST لإرسال البيانات."
      ],
      "codeExample": "import requests\nimport json\n\n# تقديم طلب GET إلى واجهة برمجة تطبيقات عامة\nresponse = requests.get(\"https://api.publicapis.org/random\")\n\n# التحقق مما إذا كان الطلب ناجحًا\nif response.status_code == 200:\n    # تحليل استجابة JSON\n    data = response.json()\n    print(json.dumps(data, indent=2))\nelse:\n    print(f\"فشل في الحصول على البيانات. رمز الحالة: {response.status_code}\")",
      "quiz": [
        {
          "question": "ماذا تعني API؟",
          "options": ["واجهة بروتوكول التطبيق", "واجهة برمجة التطبيقات", "ربط برمجي متقدم", "مثيل بروتوكول التطبيق"],
          "correctAnswer": "واجهة برمجة التطبيقات"
        },
        {
          "question": "أي مكتبة تستخدم بشكل شائع لتقديم طلبات HTTP في بايثون؟",
          "options": ["http", "urllib", "requests", "web"],
          "correctAnswer": "requests"
        },
        {
          "question": "ما هو رمز حالة HTTP الذي يشير إلى طلب ناجح؟",
          "options": ["200", "404", "500", "301"],
          "correctAnswer": "200"
        },
        {
          "question": "أي طريقة HTTP تستخدم عادةً لاسترداد البيانات من واجهة برمجة التطبيقات؟",
          "options": ["POST", "GET", "DELETE", "PUT"],
          "correctAnswer": "GET"
        },
        {
          "question": "بعد الحصول على استجابة من `requests.get()`، أي طريقة تستخدم لتحليل محتوى JSON؟",
          "options": ["response.text", "response.content", "response.json()", "response.parse()"],
          "correctAnswer": "response.json()"
        }
      ],
      "pacing": "medium"
    },
    {
      "id": "24",
      "title": "أساسيات كشط الويب",
      "description": "تعلم كيفية استخراج البيانات من مواقع الويب باستخدام Requests و BeautifulSoup.",
      "content": [
        "كشط الويب هو عملية استخراج البيانات تلقائيًا من مواقع الويب. إنه مفيد عندما لا يوفر موقع الويب واجهة برمجة تطبيقات.",
        "تُستخدم مكتبة `requests` لتنزيل محتوى HTML لصفحة ويب.",
        "تُستخدم مكتبة `BeautifulSoup` لتحليل HTML وجعل من السهل التنقل والبحث عن البيانات التي تريدها. يمكنك تحديد العناصر حسب علامات HTML أو فئاتها أو معرفاتها."
      ],
      "codeExample": "# ملاحظة: ستحتاج إلى تثبيت هذه المكتبات أولاً:\n# pip install requests beautifulsoup4\nimport requests\nfrom bs4 import BeautifulSoup\n\n# هذا مثال مفاهيمي. يتطلب كشط موقع حقيقي الفحص.\n# URL = \"http://example.com\"\n# response = requests.get(URL)\n# soup = BeautifulSoup(response.content, 'html.parser')\n\n# العثور على عنصر حسب اسم علامته\n# title = soup.find('h1').text\n# print(title)\nprint(\"يتطلب كشط الويب مكتبات خارجية مثل requests و beautifulsoup4.\")",
      "quiz": [
        {
          "question": "ما هو كشط الويب؟",
          "options": ["تصميم مواقع الويب", "استخراج البيانات تلقائيًا من مواقع الويب", "تأمين مواقع الويب", "اختبار سرعة موقع الويب"],
          "correctAnswer": "استخراج البيانات تلقائيًا من مواقع الويب"
        },
        {
          "question": "أي مكتبة تستخدم لتحليل محتوى HTML؟",
          "options": ["requests", "json", "BeautifulSoup", "os"],
          "correctAnswer": "BeautifulSoup"
        },
        {
          "question": "أي مكتبة تستخدم لتنزيل HTML لصفحة الويب؟",
          "options": ["requests", "bs4", "parser", "html"],
          "correctAnswer": "requests"
        },
        {
          "question": "كيف تقوم بتهيئة BeautifulSoup بمحتوى HTML؟",
          "options": ["soup = BeautifulSoup('html.parser', response.content)", "soup = BeautifulSoup(response.content, 'html.parser')", "soup = new BeautifulSoup(response.content)", "soup.parse(response.content)"],
          "correctAnswer": "soup = BeautifulSoup(response.content, 'html.parser')"
        },
        {
          "question": "هل من المقبول دائمًا كشط أي موقع ويب؟",
          "options": ["نعم، جميع البيانات على الإنترنت مجانية", "لا، يجب عليك دائمًا التحقق من شروط خدمة موقع الويب وملف `robots.txt` أولاً"],
          "correctAnswer": "لا، يجب عليك دائمًا التحقق من شروط خدمة موقع الويب وملف `robots.txt` أولاً"
        }
      ],
      "pacing": "medium"
    },
    {
      "id": "25",
      "title": "البيئات الافتراضية و pip",
      "description": "تعلم كيفية إدارة تبعيات المشروع باستخدام البيئات الافتراضية ومدير الحزم pip.",
      "content": [
        "بينما تعمل على المزيد من مشاريع بايثون، ستجد أن المشاريع المختلفة قد تتطلب إصدارات مختلفة من نفس المكتبة. هذا يمكن أن يسبب تعارضات.",
        "البيئة الافتراضية هي بيئة بايثون معزولة تسمح لك بإدارة التبعيات لمشروع معين بشكل منفصل.",
        "`pip` هو مثبت الحزم لبايثون. تستخدمه لتثبيت الحزم وترقيتها وإزالتها من بيئاتك. من الممارسات الشائعة إدراج تبعيات المشروع في ملف `requirements.txt`."
      ],
      "codeExample": "# في الطرفية الخاصة بك:\n\n# 1. إنشاء بيئة افتراضية\n# python -m venv my_project_env\n\n# 2. تفعيلها\n# على ويندوز: .\\my_project_env\\Scripts\\activate\n# على ماك/لينكس: source my_project_env/bin/activate\n\n# 3. استخدام pip لتثبيت الحزم\n# pip install requests\n\n# 4. تجميد التبعيات إلى ملف\n# pip freeze > requirements.txt\n\n# 5. لاحقًا، يمكن لمطور آخر تثبيت جميع التبعيات\n# pip install -r requirements.txt",
      "quiz": [
        {
          "question": "ما هو الغرض الأساسي للبيئة الافتراضية؟",
          "options": ["لجعل الكود يعمل بشكل أسرع", "لعزل تبعيات المشروع وتجنب التعارضات", "لكتابة كود بايثون", "لمشاركة الكود الخاص بك عبر الإنترنت"],
          "correctAnswer": "لعزل تبعيات المشروع وتجنب التعارضات"
        },
        {
          "question": "ما هو `pip`؟",
          "options": ["محرر كود بايثون", "مدير إصدار بايثون", "مثبت الحزم القياسي لبايثون", "نوع من البيئة الافتراضية"],
          "correctAnswer": "مثبت الحزم القياسي لبايثون"
        },
        {
          "question": "أي أمر ينشئ بيئة افتراضية تسمى `venv`؟",
          "options": ["pip create venv", "python -m venv venv", "virtualenv create venv", "python new venv"],
          "correctAnswer": "python -m venv venv"
        },
        {
          "question": "ما هو الاسم الشائع للملف المستخدم لسرد تبعيات المشروع؟",
          "options": ["packages.json", "dependencies.yml", "pip.conf", "requirements.txt"],
          "correctAnswer": "requirements.txt"
        },
        {
          "question": "أي أمر يثبت جميع الحزم من ملف `requirements.txt`؟",
          "options": ["pip install all", "pip requirements.txt", "pip install -r requirements.txt", "pip load requirements.txt"],
          "correctAnswer": "pip install -r requirements.txt"
        }
      ],
      "pacing": "medium"
    },
    {
      "id": "26",
      "title": "مقدمة في الاختبار",
      "description": "فهم أهمية الاختبار وتعلم أساسيات إطار عمل `unittest` في بايثون.",
      "content": [
        "كتابة الاختبارات للكود الخاص بك أمر بالغ الأهمية لضمان أنه يعمل كما هو متوقع ويستمر في العمل أثناء إجراء التغييرات.",
        "يتضمن الاختبار الآلي كتابة كود يتحقق مما إذا كان كود التطبيق الرئيسي الخاص بك يتصرف بشكل صحيح.",
        "توفر وحدة `unittest` المضمنة في بايثون إطار عمل لإنشاء الاختبارات وتشغيلها. تكتب حالات الاختبار كفئات ترث من `unittest.TestCase`، ودوال الاختبار هي دوال تبدأ أسماؤها بـ `test_`."
      ],
      "codeExample": "import unittest\n\n# دالة للاختبار\ndef add(a, b):\n    return a + b\n\n# فئة حالة اختبار\nclass TestAddFunction(unittest.TestCase):\n\n    def test_add_positive_numbers(self):\n        self.assertEqual(add(2, 3), 5)\n\n    def test_add_negative_numbers(self):\n        self.assertEqual(add(-1, -1), -2)\n\n# لتشغيل الاختبارات (عادة من سطر الأوامر):\n# python -m unittest your_test_file.py\nprint(\"يوضح هذا المثال بنية ملف اختبار باستخدام وحدة unittest.\")",
      "quiz": [
        {
          "question": "لماذا الاختبار مهم في تطوير البرمجيات؟",
          "options": ["لجعل الكود أطول", "لضمان جودة الكود ومنع الأخطاء", "لإبطاء التطوير", "لاستبدال التعليقات"],
          "correctAnswer": "لضمان جودة الكود ومنع الأخطاء"
        },
        {
          "question": "ما هو اسم إطار عمل الاختبار المضمن في بايثون؟",
          "options": ["pytest", "nose2", "unittest", "doctest"],
          "correctAnswer": "unittest"
        },
        {
          "question": "في `unittest`، يجب أن تبدأ دوال الاختبار بـ...",
          "options": ["assert_", "check_", "test_", "verify_"],
          "correctAnswer": "test_"
        },
        {
          "question": "أي تأكيد `unittest` يتحقق مما إذا كانت قيمتان متساويتان؟",
          "options": ["assertTrue()", "assertIs()", "assertEqual()", "assertIn()"],
          "correctAnswer": "assertEqual()"
        },
        {
          "question": "يجب أن ترث فئات حالة الاختبار في `unittest` من أي فئة؟",
          "options": ["unittest.Test", "unittest.Suite", "unittest.Case", "unittest.TestCase"],
          "correctAnswer": "unittest.TestCase"
        }
      ],
      "pacing": "medium"
    },
    {
      "id": "27",
      "title": "تصحيح أخطاء كود بايثون",
      "description": "تعلم تقنيات وأدوات للعثور على الأخطاء وإصلاحها في الكود الخاص بك.",
      "content": [
        "تصحيح الأخطاء هو عملية العثور على العيوب أو المشاكل وحلها داخل برنامج كمبيوتر.",
        "أبسط أشكال تصحيح الأخطاء هو استخدام عبارات `print()` لفحص حالة المتغيرات في نقاط مختلفة في الكود الخاص بك.",
        "أداة أكثر قوة هي مصحح الأخطاء، مثل `pdb` المضمن في بايثون (Python Debugger). يسمح لك بإيقاف تنفيذ الكود مؤقتًا، وفحص المتغيرات، والتنقل عبر الكود سطرًا بسطر."
      ],
      "codeExample": "import pdb\n\ndef my_function(x, y):\n    result = x + y\n    # تعيين نقطة توقف\n    pdb.set_trace()\n    result = result * 2\n    return result\n\n# عند تشغيل هذا، سيتوقف البرنامج مؤقتًا عند نقطة التوقف\n# وستدخل مصحح الأخطاء pdb في الطرفية الخاصة بك.\n# print(my_function(3, 4))\nprint(\"تسمح وحدة pdb بتصحيح الأخطاء التفاعلي.\")",
      "quiz": [
        {
          "question": "ما هو تصحيح الأخطاء؟",
          "options": ["كتابة كود جديد", "عملية العثور على الأخطاء وإصلاحها", "تحسين سرعة الكود", "التعليق على الكود"],
          "correctAnswer": "عملية العثور على الأخطاء وإصلاحها"
        },
        {
          "question": "ما هي أبسط تقنية لتصحيح الأخطاء وأكثرها شيوعًا؟",
          "options": ["استخدام مصحح أخطاء احترافي", "سؤال صديق", "استخدام عبارات `print()`", "إعادة كتابة الكود"],
          "correctAnswer": "استخدام عبارات `print()`"
        },
        {
          "question": "ما اسم وحدة تصحيح الأخطاء المضمنة في بايثون؟",
          "options": ["debug", "pdb", "pydebug", "debugger"],
          "correctAnswer": "pdb"
        },
        {
          "question": "ماذا تفعل `pdb.set_trace()`؟",
          "options": ["تطبع مكدس الاستدعاءات", "تنهي البرنامج", "تعين نقطة توقف وتبدأ مصحح الأخطاء", "تتجاهل جميع الأخطاء"],
          "correctAnswer": "تعين نقطة توقف وتبدأ مصحح الأخطاء"
        },
        {
          "question": "في مصحح الأخطاء، ماذا يعني 'التنقل عبر' الكود؟",
          "options": ["تنفيذ الكود ببطء شديد", "تنفيذ الكود سطرًا بسطر", "القفز إلى نهاية الدالة", "حذف أسطر من الكود"],
          "correctAnswer": "تنفيذ الكود سطرًا بسطر"
        }
      ],
      "pacing": "medium"
    },
    {
      "id": "28",
      "title": "أفضل ممارسات بايثون (PEP 8)",
      "description": "تعرف على PEP 8، دليل الأسلوب الرسمي لكود بايثون، لكتابة كود نظيف وقابل للقراءة.",
      "content": [
        "PEP 8 هو دليل الأسلوب الرسمي لكود بايثون. اتباعه يجعل الكود الخاص بك أكثر قابلية للقراءة واتساقًا مع كود بايثون الآخر.",
        "تشمل الإرشادات الرئيسية استخدام 4 مسافات للمسافة البادئة (وليس علامات التبويب)، وتحديد طول الأسطر بـ 79 حرفًا، واستخدام أسطر فارغة لفصل الدوال والفئات، واتباع اصطلاحات التسمية.",
        "على سبيل المثال، يجب أن تكون أسماء الدوال والمتغيرات `snake_case` (مثل `my_function`)، بينما يجب أن تكون أسماء الفئات `CamelCase` (مثل `MyClass`)."
      ],
      "codeExample": "# أسلوب PEP 8 جيد\ndef calculate_sum(a, b):\n    return a + b\n\nclass MySampleClass:\n    def __init__(self, name):\n        self.name = name\n\n# أسلوب PEP 8 سيئ\n# def CalculateSum( A,B ):\n#  return A+B\n#\n# class my_sample_class:\n#   def __init__(self,Name):\n#     self.name=Name\nprint(\"اتباع PEP 8 يجعل الكود أسهل في القراءة.\")",
      "quiz": [
        {
          "question": "ما هو PEP 8؟",
          "options": ["اقتراح تحسين بايثون لميزة جديدة", "دليل الأسلوب الرسمي لكود بايثون", "مكتبة لتنسيق الكود", "إصدار من بايثون"],
          "correctAnswer": "دليل الأسلوب الرسمي لكود بايثون"
        },
        {
          "question": "وفقًا لـ PEP 8، ما هي الطريقة المفضلة للمسافة البادئة للكود؟",
          "options": ["مسافتان", "علامات تبويب", "4 مسافات", "8 مسافات"],
          "correctAnswer": "4 مسافات"
        },
        {
          "question": "ما هو اصطلاح التسمية الموصى به للدوال والمتغيرات؟",
          "options": ["camelCase", "PascalCase", "kebab-case", "snake_case"],
          "correctAnswer": "snake_case"
        },
        {
          "question": "ما هو اصطلاح التسمية الموصى به للفئات؟",
          "options": ["camelCase", "PascalCase (أو CamelCase)", "snake_case", "UPPER_CASE"],
          "correctAnswer": "PascalCase (أو CamelCase)"
        },
        {
          "question": "لماذا من المهم اتباع دليل أسلوب مثل PEP 8؟",
          "options": ["إنه مطلوب لتشغيل الكود", "يحسن قابلية قراءة الكود واتساقه", "يجعل الكود يعمل بشكل أسرع", "يضيف المزيد من الميزات إلى اللغة"],
          "correctAnswer": "يحسن قابلية قراءة الكود واتساقه"
        }
      ],
      "pacing": "medium"
    },
    {
      "id": "29",
      "title": "أساسيات التزامن",
      "description": "مقدمة في التزامن وكيفية استخدام الخيوط للمهام المتوازية.",
      "content": [
        "التزامن هو قدرة البرنامج على تشغيل مهام متعددة أو أجزاء من المهام في فترات زمنية متداخلة. لا يعني بالضرورة أنها تعمل في نفس اللحظة بالضبط.",
        "تسمح وحدة `threading` في بايثون بإنشاء وإدارة الخيوط. الخيط هو تدفق منفصل للتنفيذ.",
        "هذا مفيد للمهام المرتبطة بالإدخال/الإخراج (مثل انتظار طلب شبكة أو قراءة ملف)، لأنه يسمح لبرنامجك بالقيام بأعمال أخرى أثناء الانتظار."
      ],
      "codeExample": "import threading\nimport time\n\ndef my_task(name):\n    print(f\"الخيط {name}: يبدأ\")\n    time.sleep(2) # محاكاة مهمة طويلة\n    print(f\"الخيط {name}: ينتهي\")\n\n# إنشاء خيوط\nthread1 = threading.Thread(target=my_task, args=(\"واحد\",))\nthread2 = threading.Thread(target=my_task, args=(\"اثنان\",))\n\n# بدء الخيوط\nthread1.start()\nthread2.start()\n\nprint(\"الرئيسي: جميع الخيوط قيد التشغيل\")\n\n# انتظار اكتمال الخيوط\nthread1.join()\nthread2.join()\n\nprint(\"الرئيسي: تم كل شيء\")",
      "quiz": [
        {
          "question": "ما هو التزامن؟",
          "options": ["تشغيل الكود في نفس الوقت بالضبط", "القدرة على إدارة مهام متعددة في فترات زمنية متداخلة", "طريقة لكتابة الكود بشكل أسرع", "تقنية لتصحيح الأخطاء"],
          "correctAnswer": "القدرة على إدارة مهام متعددة في فترات زمنية متداخلة"
        },
        {
          "question": "أي وحدة نمطية تستخدم للخيوط في بايثون؟",
          "options": ["multiprocessing", "asyncio", "threading", "concurrent"],
          "correctAnswer": "threading"
        },
        {
          "question": "ماذا تفعل `thread.start()`؟",
          "options": ["تشغل دالة الهدف للخيط على الفور", "تجهز الخيط ليتم تشغيله", "تبدأ تنفيذ الخيط", "توقف الخيط"],
          "correctAnswer": "تبدأ تنفيذ الخيط"
        },
        {
          "question": "ما هو الغرض من `thread.join()`؟",
          "options": ["لدمج خيطين في واحد", "لإيقاف الخيط", "للانتظار حتى ينهي الخيط تنفيذه", "لبدء الخيط"],
          "correctAnswer": "للانتظار حتى ينهي الخيط تنفيذه"
        },
        {
          "question": "الخيوط هي الأكثر فعالية لأي نوع من المهام؟",
          "options": ["المهام المرتبطة بوحدة المعالجة المركزية (حسابات ثقيلة)", "المهام المرتبطة بالإدخال/الإخراج (انتظار الشبكة/القرص)", "جميع المهام على حد سواء", "فقط لطباعة النص"],
          "correctAnswer": "المهام المرتبطة بالإدخال/الإخراج (انتظار الشبكة/القرص)"
        }
      ],
      "pacing": "fast"
    },
    {
      "id": "30",
      "title": "المشروع النهائي: تجميع كل شيء معًا",
      "description": "طبق كل ما تعلمته لبناء مشروع صغير وكامل.",
      "content": [
        "تهانينا على وصولك إلى الدرس النهائي! حان الوقت لدمج جميع المفاهيم التي تعلمتها.",
        "مشروع نهائي رائع هو تطبيق سطر أوامر. على سبيل المثال، دفتر جهات اتصال بسيط، أو مدير قائمة مهام، أو تطبيق طقس يجلب البيانات من واجهة برمجة تطبيقات.",
        "فكر في الهيكل: كيف ستخزن البيانات (على سبيل المثال، في قائمة من القواميس)؟ ما الدوال التي ستحتاجها (مثل `add_contact`، `view_contacts`)؟ كيف ستتعامل مع إدخال المستخدم وإدخال/إخراج الملفات لحفظ البيانات؟"
      ],
      "codeExample": "# فكرة مشروع: مدير قائمة مهام بسيط\n\n# 1. استخدم قائمة لتخزين عناصر المهام.\n# 2. اكتب دوال لـ:\n#    - view_tasks()\n#    - add_task()\n#    - mark_task_complete()\n#    - save_tasks_to_file()\n#    - load_tasks_from_file()\n# 3. استخدم حلقة while للحفاظ على تشغيل البرنامج وطلب إدخال المستخدم.\n# 4. استخدم if/elif/else للتعامل مع اختيارات المستخدم.\n# 5. استخدم try/except لمعالجة الأخطاء (مثل، ملف غير موجود).\n\nprint(\"هذه فرصتك لبناء شيء بنفسك!\")",
      "quiz": [
        {
          "question": "أي بنية بيانات ستكون مناسبة لتخزين قائمة من جهات الاتصال، حيث يكون كل جهة اتصال مجموعة من المعلومات الخاصة بها؟",
          "options": ["قائمة بسيطة من النصوص", "قائمة من القواميس", "مجموعة", "صف"],
          "correctAnswer": "قائمة من القواميس"
        },
        {
          "question": "لحفظ بياناتك بحيث تستمر بعد إغلاق البرنامج، يجب عليك استخدام...",
          "options": ["المتغيرات", "إدخال/إخراج الملفات", "دوال لامدا", "المزخرفات"],
          "correctAnswer": "إدخال/إخراج الملفات"
        },
        {
          "question": "ما هو نوع الحلقة الأفضل للجزء الرئيسي من تطبيق سطر أوامر ينتظر أوامر المستخدم؟",
          "options": ["حلقة for على نطاق", "حلقة while تعمل حتى يختار المستخدم الخروج", "دالة map", "دالة تكرارية"],
          "correctAnswer": "حلقة while تعمل حتى يختار المستخدم الخروج"
        },
        {
          "question": "إذا كان تطبيقك يحصل على بيانات من خدمة طقس عبر الإنترنت، فماذا تستخدم؟",
          "options": ["قاعدة بيانات", "بيئة افتراضية", "واجهة برمجة تطبيقات (API)", "مزخرف"],
          "correctAnswer": "واجهة برمجة تطبيقات (API)"
        },
        {
          "question": "ما هو الجزء الأكثر أهمية في المشروع النهائي؟",
          "options": ["جعله يبدو جميلاً", "كتابته بأقل عدد من أسطر الكود", "تطبيق المفاهيم التي تعلمتها لحل مشكلة", "استخدام كل ميزة من الدورة"],
          "correctAnswer": "تطبيق المفاهيم التي تعلمتها لحل مشكلة"
        }
      ],
      "pacing": "fast"
    }
  ]
}
