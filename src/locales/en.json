
{
  "theme": {
    "light": "Light",
    "dark": "Dark",
    "system": "System"
  },
  "home": {
    "hero": {
      "title": "Python Prep: From Scratch to Pro.",
      "subtitle": "Your comprehensive, step-by-step guide to mastering the Python language. Structured lessons, interactive quizzes, and AI-powered feedback.",
      "cta": "Start Your Learning Journey"
    },
    "why": {
      "title": "Why Learn Python?",
      "cards": {
        "beginner": {
          "title": "Beginner-Friendly",
          "text": "Python’s simple, clean syntax makes it one of the easiest programming languages to learn."
        },
        "versatile": {
          "title": "Extremely Versatile",
          "text": "From web development and data science to AI and automation, Python can do it all."
        },
        "demand": {
          "title": "High Demand",
          "text": "Python developers are highly sought after in the job market, with competitive salaries."
        }
      }
    },
    "learn": {
      "title": "What You'll Learn",
      "more": "...and much more!"
    },
    "finalCta": {
      "title": "Ready to Get Started?",
      "subtitle": "Your first lesson is just one click away. Begin your journey to becoming a Python expert today.",
      "cta": "Start Learning Now"
    },
    "footer": {
      "rights": "Python Prep. All rights reserved.",
      "designedBy": "Designed by <a href='https://www.linkedin.com/in/yehia-mohammed-1518a1222?utm_source=share&utm_campaign=share_via&utm_content=profile&utm_medium=android_app' target='_blank' rel='noopener noreferrer' class='text-primary hover:underline'>Engineer Yehia Mohammed</a>."
    }
  },
  "sidebar": {
    "loading": "Loading",
    "yourProgress": "Your Progress",
    "complete": "Complete",
    "downloadCourse": "Download Course",
    "description": "Description",
    "content": "Lesson Content",
    "codeExample": "Code Example",
    "quiz": "Quiz",
    "levels": {
      "beginner": "Beginner",
      "intermediate": "Intermediate",
      "advanced": "Advanced"
    }
  },
  "lesson": {
    "playground": {
      "title": "Code Playground",
      "description": "Try out the concepts from this lesson. The code example is pre-filled for you."
    },
    "quiz": {
      "title": "Quiz Time!",
      "description": "Test your knowledge on this lesson."
    }
  },
  "codeRunner": {
    "placeholder": "Enter your Python code here",
    "run": "Run Code",
    "explain": "Explain Code",
    "output": "Output",
    "running": "Running code",
    "explainingTitle": "AI is explaining...",
    "explainingDesc": "Our AI teacher is generating an explanation for you.",
    "explanationTitle": "AI Code Explanation"
  },
  "quiz": {
    "incomplete": {
      "title": "Incomplete Quiz",
      "description": "Please answer all questions before submitting."
    },
    "submit": "Submit Quiz",
    "results": {
      "title": "Quiz Complete!",
      "score": "You scored {score}%."
    },
    "feedback": {
      "analyzing": "Analyzing your results...",
      "generating": "Our AI is generating personalized feedback for you.",
      "title": "Personalized Feedback from Your AI Tutor"
    },
    "tryAgain": "Try Again",
    "nextLesson": "Next Lesson",
    "courseComplete": "Congratulations! You have completed the course!"
  },
  "curriculum": {
    "beginner": [
      {
        "id": "1",
        "title": "Introduction to Python",
        "description": "Learn the basics of Python and why it's a popular language for beginners and experts alike.",
        "content": [
          "Welcome to the world of Python! Python is a high-level, interpreted programming language. Let's break that down. 'High-level' means it's designed to be easy for humans to read and write, using words similar to English. 'Interpreted' means that the code is run line-by-line by a program called an interpreter, which makes testing and debugging faster. You don't need a separate 'compilation' step.",
          "Python's core philosophy, created by Guido van Rossum and first released in 1991, revolves around code readability. One of the most unique features you'll encounter is its use of whitespace (indentation) to define code blocks, like loops or functions. Unlike many other languages that use curly braces `{}`, Python's clean look forces you to write well-structured code from the start.",
          "The versatility of Python is a major reason for its popularity. It's a general-purpose language, which means it's not specialized for just one thing. It's used by major companies for web development (like Instagram and Spotify), data analysis and machine learning, scientific computing, automation scripts to make your life easier, and so much more. This course will give you the foundation to explore any of these exciting fields.",
          "Let's begin with the most traditional first program: printing 'Hello, World!'. In Python, this is incredibly simple. You use the built-in `print()` function, and pass the text you want to display inside the parentheses and quotes. Try it in the playground below!"
        ],
        "codeExample": "print(\"Hello, World!\")",
        "quiz": [
          {
            "question": "Who is the creator of Python?",
            "options": ["James Gosling", "Guido van Rossum", "Bjarne Stroustrup", "Dennis Ritchie"],
            "correctAnswer": "Guido van Rossum"
          },
          {
            "question": "What is the primary focus of Python's design philosophy?",
            "options": ["Execution speed", "Code readability", "Memory management", "Complex syntax"],
            "correctAnswer": "Code readability"
          },
          {
            "question": "What does it mean for Python to be an 'interpreted' language?",
            "options": ["Code is converted to machine code before running", "Code is run directly line-by-line by another program", "Code must be written in a specific editor", "Code can only be used for web development"],
            "correctAnswer": "Code is run directly line-by-line by another program"
          },
          {
            "question": "Which of the following is NOT a common use for Python?",
            "options": ["Data Science", "Web Development", "Artificial Intelligence", "Styling web pages"],
            "correctAnswer": "Styling web pages"
          },
          {
            "question": "How do you write a single-line comment in Python?",
            "options": ["// This is a comment", "/* This is a comment */", "# This is a comment", "<!-- This is a comment -->"],
            "correctAnswer": "# This is a comment"
          }
        ],
        "pacing": "medium"
      },
      {
        "id": "2",
        "title": "Variables and Data Types",
        "description": "Understand how to store and manage data in Python using variables and different data types.",
        "content": [
          "Think of variables as labeled containers where you can store information. In Python, you create a variable and give it a value in a single step using the assignment operator `=`. For instance, `player_score = 100` creates a variable named `player_score` and puts the number 100 inside it. Python is dynamically typed, which means you don't have to tell Python what type of data the variable will hold. It figures it out automatically.",
          "Python comes with several fundamental data types to handle different kinds of information. The most common are: **Strings (`str`)** for text, like `'Hello'` or `\"Python\"`; **Integers (`int`)** for whole numbers, like `10` or `-50`; **Floats (`float`)** for numbers with decimal points, like `3.14` or `-0.5`; and **Booleans (`bool`)** which can only be `True` or `False`, used for logical operations.",
          "You can reassign variables to different values, and even different types, at any time. For example, you can start with `my_variable = 10` and later say `my_variable = 'Now I am a string'`. While this is possible, it's generally good practice to keep the data type of a variable consistent to avoid confusion.",
          "If you're ever unsure about the type of data a variable holds, you can use the built-in `type()` function. For example, `print(type(player_score))` would output `<class 'int'>`, telling you it's an integer. This is a very useful tool for debugging."
        ],
        "codeExample": "name = \"Alice\"      # A string (str)\nage = 30           # An integer (int)\nheight = 5.5       # A float\nis_student = True   # A boolean (bool)\n\n# Let's check the type of the 'age' variable\nprint(f\"The variable 'name' is of type: {type(name)}\")\nprint(f\"The variable 'age' is of type: {type(age)}\")",
        "quiz": [
          {
            "question": "Which of the following is the correct way to assign a string to a variable?",
            "options": ["string name = 'Bob'", "name = 'Bob'", "name := 'Bob'", "let name = 'Bob'"],
            "correctAnswer": "name = 'Bob'"
          },
          {
            "question": "What would `type(10.5)` return?",
            "options": ["int", "string", "float", "double"],
            "correctAnswer": "float"
          },
          {
            "question": "What is a boolean data type?",
            "options": ["A whole number", "A sequence of characters", "A number with a decimal point", "A value that is either True or False"],
            "correctAnswer": "A value that is either True or False"
          },
          {
            "question": "If you run `x = 5` and then `x = 'hello'`, what is the data type of `x`?",
            "options": ["int", "str", "error", "bool"],
            "correctAnswer": "str"
          },
          {
            "question": "Variable names in Python can start with a number.",
            "options": ["True", "False"],
            "correctAnswer": "False"
          }
        ],
        "pacing": "medium"
      },
      {
        "id": "3",
        "title": "Control Flow: If/Else",
        "description": "Learn how to make decisions in your code using conditional statements.",
        "content": [
          "Programs often need to make decisions and execute different code based on certain conditions. This is called control flow. The most basic way to control the flow in Python is with `if`, `elif`, and `else` statements.",
          "An `if` statement checks if a condition is `True`. If it is, the indented code block below it runs. For example: `if temperature > 30: print('It is a hot day!')`. The condition `temperature > 30` is an expression that evaluates to either `True` or `False`.",
          "What if the first condition is false? You can use an `elif` (short for 'else if') statement to check another condition. You can have as many `elif` statements as you need. The program checks them in order and runs the code for the *first* one that is `True`.",
          "Finally, the `else` statement provides a block of code to run if *none* of the preceding `if` or `elif` conditions were `True`. It's a catch-all for any other case. An `else` statement is optional."
        ],
        "codeExample": "age = 18\n\nif age < 13:\n    print(\"You are a child.\")\nelif age >= 13 and age < 20:\n    print(\"You are a teenager.\")\nelse:\n    print(\"You are an adult.\")",
        "quiz": [
          {
            "question": "What keyword is used for 'else if' conditions in Python?",
            "options": ["elseif", "else if", "elif", "case"],
            "correctAnswer": "elif"
          },
          {
            "question": "In the example code, what would be printed if `age` was 25?",
            "options": ["You are a child.", "You are a teenager.", "You are an adult.", "Nothing would be printed."],
            "correctAnswer": "You are an adult."
          },
          {
            "question": "Which of these operators checks for equality?",
            "options": ["=", "==", "===", "!="],
            "correctAnswer": "=="
          },
          {
            "question": "Can an `if` statement exist without an `else` block?",
            "options": ["Yes", "No"],
            "correctAnswer": "Yes"
          },
          {
            "question": "What is the purpose of the `else` statement?",
            "options": ["To check an additional condition", "To run code if all previous conditions are false", "To end the program", "To define a variable"],
            "correctAnswer": "To run code if all previous conditions are false"
          }
        ],
        "pacing": "medium"
      },
      {
        "id": "4",
        "title": "Functions",
        "description": "Discover how to write reusable blocks of code with functions.",
        "content": [
          "As your programs get bigger, you'll find yourself writing the same piece of code over and over. Functions allow you to package a block of code, give it a name, and reuse it whenever you need it. This principle is known as DRY (Don't Repeat Yourself).",
          "You define a function using the `def` keyword, followed by a function name, parentheses `()`, and a colon `:`. All the code belonging to the function must be indented underneath it. For example: `def greet(): print('Hello!')`.",
          "Functions become even more powerful when you pass data into them. The variables inside the parentheses are called **parameters**. When you call the function, the values you pass in are called **arguments**. For example, in `def greet(name):`, `name` is a parameter.",
          "Often, a function performs a calculation and needs to send a result back. The `return` keyword is used for this. When a `return` statement is executed, the function stops and sends the specified value back to where it was called. A function can return any data type: a number, a string, a list, or even another function!"
        ],
        "codeExample": "# A function that takes a name and returns a greeting\ndef greet_person(name):\n    return f\"Hello, {name}! Welcome to Python.\"\n\n# Call the function and store the result in a variable\ngreeting = greet_person(\"Yehia\")\nprint(greeting)\n\n# Another call with a different argument\nprint(greet_person(\"Student\"))",
        "quiz": [
          {
            "question": "Which keyword is used to define a function in Python?",
            "options": ["function", "def", "fun", "define"],
            "correctAnswer": "def"
          },
          {
            "question": "What does the `return` keyword do in a function?",
            "options": ["Prints a value to the console", "Stops the function execution", "Passes data back out of the function", "Defines the function's name"],
            "correctAnswer": "Passes data back out of the function"
          },
          {
            "question": "In `def my_func(param1):`, what is `param1`?",
            "options": ["An argument", "A variable", "A parameter", "A return value"],
            "correctAnswer": "A parameter"
          },
          {
            "question": "Can a function be called without being defined first?",
            "options": ["Yes", "No"],
            "correctAnswer": "No"
          },
          {
            "question": "A function must always have a `return` statement.",
            "options": ["True", "False"],
            "correctAnswer": "False"
          }
        ],
        "pacing": "medium"
      },
      {
        "id": "5",
        "title": "Lists and Tuples",
        "description": "Learn about Python's sequence data types: lists (mutable) and tuples (immutable).",
        "content": [
          "To store a collection of items, you often need a sequence data type. Python's most common sequence is the **list**. A list is an ordered collection of items, and it's **mutable**, which means you can change its contents after it's created. Lists are defined with square brackets `[]`, with items separated by commas.",
          "You can access any item in a list using its **index** - its position in the list. Indexing starts at 0. So, for `my_list = ['a', 'b', 'c']`, `my_list[0]` is `'a'`. You can add items to the end with the `.append()` method, and remove items with `.remove()` (by value) or `.pop()` (by index).",
          "A **tuple** is another ordered collection, similar to a list, but with one crucial difference: it's **immutable**. Once you create a tuple, you cannot add, remove, or change its elements. Tuples are defined with round brackets `()`. You might use a tuple for data that shouldn't change, like the coordinates `(x, y)` of a point.",
          "Why use a tuple if it's less flexible? Their immutability makes them predictable and can be slightly more memory-efficient. They can also be used as keys in a dictionary (which we'll see later), whereas lists cannot."
        ],
        "codeExample": "# A list of numbers\nnumbers = [1, 2, 3, 5, 8]\nprint(f\"Original list: {numbers}\")\n\n# Add an item to the list\nnumbers.append(13)\nprint(f\"List after append: {numbers}\")\n\n# Access an item by index\nprint(f\"The third item is: {numbers[2]}\")\n\n# A tuple of strings\nweekdays = (\"Monday\", \"Tuesday\", \"Wednesday\")\nprint(f\"First day of the week is: {weekdays[0]}\")",
        "quiz": [
          {
            "question": "Which symbol is used to create a list?",
            "options": ["()", "{}", "[]", "<>"],
            "correctAnswer": "[]"
          },
          {
            "question": "What is the main difference between a list and a tuple?",
            "options": ["Lists are ordered, tuples are not", "Lists can hold any data type, tuples only hold numbers", "Lists are mutable, tuples are immutable", "Lists use indexes, tuples do not"],
            "correctAnswer": "Lists are mutable, tuples are immutable"
          },
          {
            "question": "How do you add an element to the end of a list called `my_list`?",
            "options": ["my_list.add('new')", "my_list.append('new')", "my_list.insert('new')", "my_list.push('new')"],
            "correctAnswer": "my_list.append('new')"
          },
          {
            "question": "What is the index of the first element in a list or tuple?",
            "options": ["1", "0", "-1", "A"],
            "correctAnswer": "0"
          },
          {
            "question": "If you try to change an element in a tuple, what happens?",
            "options": ["The element is updated", "A new tuple is created", "You get a TypeError", "The element is removed"],
            "correctAnswer": "You get a TypeError"
          }
        ],
        "pacing": "medium"
      },
      {
        "id": "6",
        "title": "Dictionaries and Sets",
        "description": "Explore dictionaries for key-value pairs and sets for unique elements.",
        "content": [
          "A **dictionary** is a collection that stores data in **key-value pairs**. Instead of accessing elements by a numerical index, you access them using a unique key. Dictionaries are defined with curly braces `{}`. For example: `student = {'name': 'Alice', 'id': 123}`. Here, `'name'` and `'id'` are keys.",
          "Dictionaries are mutable, so you can add new key-value pairs (e.g., `student['grade'] = 'A'`), modify existing values (e.g., `student['id'] = 456`), and remove pairs. They are incredibly useful for storing structured information where each piece of data has a clear label.",
          "A **set** is an *unordered* collection of *unique* elements. This means a set cannot have duplicate items, and you cannot rely on the items being in any particular order. Sets are also created with curly braces, but they don't have key-value pairs: `unique_numbers = {1, 2, 3, 2, 1}` would result in `{1, 2, 3}`.",
          "Sets are highly optimized for checking if an element is present in the collection. They are also great for mathematical set operations like union (`|`), intersection (`&`), and difference (`-`)."
        ],
        "codeExample": "# A dictionary to store car information\ncar_info = {\n  \"brand\": \"Ford\",\n  \"model\": \"Mustang\",\n  \"year\": 1964\n}\n\n# Accessing a value using its key\nprint(f\"The car model is: {car_info['model']}\")\n\n# Adding a new key-value pair\ncar_info[\"color\"] = \"red\"\nprint(f\"Updated dictionary: {car_info}\")\n\n# A set of numbers (duplicates are automatically removed)\nnumbers_set = {1, 5, 10, 5, 2, 1}\nprint(f\"The set of unique numbers is: {numbers_set}\")",
        "quiz": [
          {
            "question": "How do you access the value associated with the key 'brand' in `my_dict`?",
            "options": ["my_dict(brand)", "my_dict['brand']", "my_dict.get_brand()", "my_dict[0]"],
            "correctAnswer": "my_dict['brand']"
          },
          {
            "question": "What is a key characteristic of a set?",
            "options": ["It keeps elements in a specific order", "It stores duplicate elements", "It stores only unique elements", "It uses key-value pairs"],
            "correctAnswer": "It stores only unique elements"
          },
          {
            "question": "Which data structure uses key-value pairs?",
            "options": ["List", "Tuple", "Set", "Dictionary"],
            "correctAnswer": "Dictionary"
          },
          {
            "question": "What happens if you try to add a duplicate item to a set?",
            "options": ["It raises an error", "It adds the duplicate item", "It does nothing and the set remains unchanged", "It replaces the original item"],
            "correctAnswer": "It does nothing and the set remains unchanged"
          },
          {
            "question": "How do you add a new key-value pair, 'price': 5000, to a dictionary named `car`?",
            "options": ["car.append('price', 5000)", "car.add({'price': 5000})", "car['price'] = 5000", "add key 'price' value 5000 to car"],
            "correctAnswer": "car['price'] = 5000"
          }
        ],
        "pacing": "medium"
      },
      {
        "id": "7",
        "title": "For Loops",
        "description": "Learn how to iterate over sequences like lists, tuples, and strings using for loops.",
        "content": [
          "A **for loop** is used to iterate, or loop over, the items in a sequence (like a list, tuple, dictionary, set, or string). It allows you to execute a block of code for each item in the sequence.",
          "The syntax is `for item in sequence:`. In each iteration of the loop, the variable `item` will hold the current element from the `sequence`, and the indented code block will be executed.",
          "A common partner to the `for` loop is the `range()` function. `range()` generates a sequence of numbers, which is useful when you want to repeat an action a specific number of times. For example, `range(5)` generates the numbers 0, 1, 2, 3, 4. `range(2, 6)` would generate 2, 3, 4, 5.",
          "You can loop through different data structures in different ways. For a list, you get each item. For a string, you get each character. For a dictionary, by default, you get each key. You can also use methods like `.values()` or `.items()` to loop through a dictionary's values or key-value pairs, respectively."
        ],
        "codeExample": "fruits = [\"apple\", \"banana\", \"cherry\"]\n\n# Loop through each item in the list and print it\nprint(\"My favorite fruits are:\")\nfor fruit in fruits:\n  print(f\"- {fruit}\")\n\n# Loop using range() to print numbers\nprint(\"\\nCounting from 0 to 4:\")\nfor i in range(5):\n  print(i)",
        "quiz": [
          {
            "question": "What is a for loop used for?",
            "options": ["Making decisions", "Defining a function", "Iterating over a sequence", "Storing data"],
            "correctAnswer": "Iterating over a sequence"
          },
          {
            "question": "In `for x in my_list:`, what is `x`?",
            "options": ["The index of the current item", "The list itself", "The current item in the sequence", "A counter"],
            "correctAnswer": "The current item in the sequence"
          },
          {
            "question": "What numbers will `range(1, 4)` produce?",
            "options": ["1, 2, 3, 4", "1, 2, 3", "0, 1, 2, 3", "1, 4"],
            "correctAnswer": "1, 2, 3"
          },
          {
            "question": "How can you loop through both the keys and values of a dictionary `my_dict`?",
            "options": ["for k, v in my_dict.items():", "for k, v in my_dict:", "for item in my_dict.values():", "for item in my_dict.keys():"],
            "correctAnswer": "for k, v in my_dict.items():"
          },
          {
            "question": "What will `for char in \"Hi!\": print(char)` output?",
            "options": ["Hi!", "H\ni\n!", "Error", "['H', 'i', '!']"],
            "correctAnswer": "H\ni\n!"
          }
        ],
        "pacing": "medium"
      },
      {
        "id": "8",
        "title": "While Loops",
        "description": "Understand how to execute a block of code as long as a condition is true.",
        "content": [
          "While a `for` loop is used to iterate over a sequence, a **while loop** is used to repeat a block of code as long as a certain condition remains `True`. The loop will continue running until the condition becomes `False`.",
          "The syntax is `while condition:`. The loop checks the `condition` *before* each iteration. If it's true, the indented code block is executed. If it's false, the loop terminates.",
          "A critical part of a `while` loop is ensuring that something inside the loop will eventually make the condition false. If not, you will create an **infinite loop**, which will run forever and crash your program. Usually, this involves a counter that is incremented or some other state change.",
          "You can control the flow of a `while` loop with two special statements. The `break` statement will immediately terminate the loop, regardless of the condition. The `continue` statement will skip the rest of the current iteration and jump back to the top to check the condition again."
        ],
        "codeExample": "count = 5\n\n# This loop will count down from 5 to 1\nwhile count > 0:\n  print(f\"Countdown: {count}\")\n  count -= 1  # This is crucial to avoid an infinite loop!\n\nprint(\"Blast off!\")",
        "quiz": [
          {
            "question": "When does a while loop stop?",
            "options": ["After a fixed number of iterations", "When its condition becomes false", "When the program ends", "When a function is called"],
            "correctAnswer": "When its condition becomes false"
          },
          {
            "question": "What is an 'infinite loop'?",
            "options": ["A loop that runs very slowly", "A loop that never ends because its condition always stays true", "A loop that uses a lot of memory", "A loop with an error"],
            "correctAnswer": "A loop that never ends because its condition always stays true"
          },
          {
            "question": "What does the `break` statement do inside a loop?",
            "options": ["Skips the rest of the current iteration", "Exits the loop entirely", "Pauses the loop", "Restarts the loop"],
            "correctAnswer": "Exits the loop entirely"
          },
          {
            "question": "What does the `continue` statement do inside a loop?",
            "options": ["Skips the rest of the current iteration and goes to the next one", "Exits the loop entirely", "Ends the program", "Continues from the beginning of the same iteration"],
            "correctAnswer": "Skips the rest of the current iteration and goes to the next one"
          },
          {
            "question": "What must you remember to include in a while loop to avoid an infinite loop?",
            "options": ["A print statement", "A break statement", "A way to change the variable in the condition (e.g., i += 1)", "A return statement"],
            "correctAnswer": "A way to change the variable in the condition (e.g., i += 1)"
          }
        ],
        "pacing": "medium"
      },
      {
        "id": "9",
        "title": "String Manipulation",
        "description": "Learn various methods to work with and format strings.",
        "content": [
          "Strings are one of the most common data types you'll work with. Python provides a rich set of built-in **methods** to manipulate them. A key thing to remember is that strings are **immutable**. This means string methods never change the original string; they always return a new, modified string.",
          "Some of the most useful methods are: `.lower()` and `.upper()` to change the case; `.strip()` to remove whitespace from the beginning and end; `.replace(old, new)` to swap parts of a string; and `.split(separator)` to break a string into a list of smaller strings.",
          "Combining strings is also a common task. You can use the `+` operator to concatenate them, but a more modern and powerful way is using **f-strings** (formatted string literals). By placing an `f` before the opening quote, you can embed variables and expressions directly inside the string by wrapping them in curly braces `{}`. This is often more readable and efficient.",
          "You can also check for the existence of a substring within a larger string using the `in` keyword, which returns a boolean value (`True` or `False`). For example: `'py' in 'python'` would evaluate to `True`."
        ],
        "codeExample": "my_string = \"  Hello, Python World!  \"\n\n# Using strip() and upper()\ncleaned_upper = my_string.strip().upper()\nprint(f\"Cleaned and uppercased: {cleaned_upper}\")\n\n# Using replace()\nnew_string = cleaned_upper.replace(\"PYTHON\", \"PROGRAMMING\")\nprint(f\"Replaced string: {new_string}\")\n\n# F-string formatting\nlanguage = \"Python\"\nyear = 1991\nprint(f\"{language} was first released in {year}.\")",
        "quiz": [
          {
            "question": "Which method converts a string to all uppercase letters?",
            "options": ["capitalize()", "upper()", "to_upper()", "uppercase()"],
            "correctAnswer": "upper()"
          },
          {
            "question": "What does the `strip()` method do?",
            "options": ["Removes all characters from a string", "Removes leading and trailing whitespace", "Splits the string into a list", "Replaces a character"],
            "correctAnswer": "Removes leading and trailing whitespace"
          },
          {
            "question": "If `s = 'abc'`, does `s.upper()` change the value of `s`?",
            "options": ["Yes, s becomes 'ABC'", "No, it returns a new string 'ABC' but s remains 'abc'"],
            "correctAnswer": "No, it returns a new string 'ABC' but s remains 'abc'"
          },
          {
            "question": "How do you start an f-string?",
            "options": ["With 'f' before the opening quote", "With 'fmt' before the opening quote", "With '%' inside the string", "With .format() at the end"],
            "correctAnswer": "With 'f' before the opening quote"
          },
          {
            "question": "What does `\"a-b-c\".split('-')` return?",
            "options": ["['a', 'b', 'c']", "('a', 'b', 'c')", "\"abc\"", "\"a b c\""],
            "correctAnswer": "['a', 'b', 'c']"
          }
        ],
        "pacing": "medium"
      },
      {
        "id": "10",
        "title": "Exception Handling",
        "description": "Learn how to handle errors gracefully using try...except blocks.",
        "content": [
          "Errors that occur during the execution of a program are called **exceptions**. If your program doesn't handle an exception, it will crash and display an error message. Good programmers anticipate potential errors and write code to handle them gracefully.",
          "Python's mechanism for handling errors is the `try...except` block. You place the code that might cause an error inside the `try` block. If an error occurs, the code inside the `try` block stops executing, and Python looks for a matching `except` block to handle that specific type of error.",
          "You can have multiple `except` blocks to handle different types of exceptions, like `ZeroDivisionError` for dividing by zero or `FileNotFoundError` for when a file doesn't exist. You can also have a general `except` block that catches any exception.",
          "Optionally, you can include a `finally` block. The code inside `finally` will run no matter what—whether an exception occurred or not. This is useful for cleanup actions, like closing a file or a network connection."
        ],
        "codeExample": "numerator = 10\ndenominator = 0\n\ntry:\n  # This line will cause a ZeroDivisionError\n  result = numerator / denominator\n  print(result)\nexcept ZeroDivisionError:\n  # This block runs because the specific error occurred\n  print(\"Error: You can't divide by zero!\")\nfinally:\n  # This block will run no matter what\n  print(\"The calculation attempt has finished.\")",
        "quiz": [
          {
            "question": "Which block contains the code that might cause an exception?",
            "options": ["except", "finally", "try", "if"],
            "correctAnswer": "try"
          },
          {
            "question": "What is the purpose of the `finally` block?",
            "options": ["To handle the error", "To cause an error", "To execute code whether an error occurs or not", "To report the error to the user"],
            "correctAnswer": "To execute code whether an error occurs or not"
          },
          {
            "question": "What kind of error does dividing by zero raise?",
            "options": ["TypeError", "ValueError", "ZeroDivisionError", "SyntaxError"],
            "correctAnswer": "ZeroDivisionError"
          },
          {
            "question": "Can you have multiple `except` blocks for one `try` block?",
            "options": ["No, only one is allowed", "Yes, to handle different types of exceptions"],
            "correctAnswer": "Yes, to handle different types of exceptions"
          },
          {
            "question": "What happens if an exception occurs and there is no `except` block to handle it?",
            "options": ["The program continues as normal", "The program crashes and displays an error message", "The program silently ignores the error", "The program asks the user what to do"],
            "correctAnswer": "The program crashes and displays an error message"
          }
        ],
        "pacing": "medium"
      },
      {
        "id": "11",
        "title": "Introduction to OOP",
        "description": "Understand the fundamental concepts of Object-Oriented Programming (OOP).",
        "content": [
          "Object-Oriented Programming (OOP) is a way of thinking about and structuring your code. Instead of a series of functions, you organize your program around **objects**. An object is a self-contained unit that bundles together data (called **attributes**) and functions that operate on that data (called **methods**).",
          "A **Class** is the blueprint or template for creating objects. For example, you could have a `Car` class that defines what all cars have (attributes like `color`, `brand`) and what they can do (methods like `start_engine()`, `drive()`). An actual car, like a specific red Ford, would be an **object** (or **instance**) created from that `Car` class.",
          "There are four main principles of OOP: **Encapsulation** (bundling data and methods together), **Abstraction** (hiding complex implementation details and showing only necessary features), **Inheritance** (allowing a new class to adopt the properties and methods of an existing class), and **Polymorphism** (allowing objects of different classes to be treated as objects of a common superclass).",
          "We will explore these concepts in detail in the upcoming lessons. For now, just understand that OOP helps in creating modular, reusable, and well-organized code, especially for large and complex applications."
        ],
        "codeExample": "# This is just a conceptual example. We'll define a class in the next lesson.\n\n# This is the 'blueprint' for a car.\nclass Car:\n  # Attributes (data) and methods (code) would go here.\n  # For example: color, brand, start_engine(), drive()\n  pass\n\n# Here we create two distinct 'objects' (instances) from the Car class.\nmy_car = Car()\nyour_car = Car()\n\nprint(\"We have created two car objects from the Car class blueprint.\")",
        "quiz": [
          {
            "question": "What is a 'class' in OOP?",
            "options": ["A piece of data", "A function", "A blueprint for creating objects", "An object itself"],
            "correctAnswer": "A blueprint for creating objects"
          },
          {
            "question": "What is an 'object' in OOP?",
            "options": ["A type of variable", "An instance of a class", "A programming paradigm", "A file"],
            "correctAnswer": "An instance of a class"
          },
          {
            "question": "Which of the following is NOT a core concept of OOP?",
            "options": ["Inheritance", "Polymorphism", "Encapsulation", "Iteration"],
            "correctAnswer": "Iteration"
          },
          {
            "question": "The concept of bundling data and methods that work on that data within one unit is called...?",
            "options": ["Inheritance", "Abstraction", "Encapsulation", "Polymorphism"],
            "correctAnswer": "Encapsulation"
          },
          {
            "question": "The ability of an object to take on many forms is known as...?",
            "options": ["Inheritance", "Polymorphism", "Encapsulation", "Abstraction"],
            "correctAnswer": "Polymorphism"
          }
        ],
        "pacing": "medium"
      },
      {
        "id": "12",
        "title": "Classes and Objects",
        "description": "Learn how to define your own classes and create objects in Python.",
        "content": [
          "To define a class (the blueprint), you use the `class` keyword followed by the class name (by convention, in `CamelCase`). Everything indented below this line belongs to the class.",
          "Almost every class will have a special method called `__init__()`. This method is the **constructor**; it gets called automatically whenever you create a new object from the class. Its primary job is to initialize the object's attributes.",
          "The first parameter of any method inside a class must be `self`. `self` is a special variable that refers to the instance of the object itself. It allows you to access the attributes and methods of that specific object. When you call a method like `my_dog.bark()`, Python automatically passes `my_dog` as the `self` argument.",
          "Functions defined inside a class are called **methods**. They define the behaviors of the object. Attributes are variables that belong to the object and store its data."
        ],
        "codeExample": "class Dog:\n  # The constructor method\n  def __init__(self, name, age):\n    # These are instance attributes\n    self.name = name\n    self.age = age\n\n  # This is an instance method\n  def bark(self):\n    return f\"{self.name} says woof!\"\n\n# Create an instance (object) of the Dog class\nmy_dog = Dog(\"Fido\", 5)\n\n# Access attributes and call methods using dot notation\nprint(f\"My dog's name is {my_dog.name}.\")\nprint(f\"He is {my_dog.age} years old.\")\nprint(my_dog.bark())",
        "quiz": [
          {
            "question": "What is the name of the constructor method in a Python class?",
            "options": ["__main__", "__construct__", "__init__", "__setup__"],
            "correctAnswer": "__init__"
          },
          {
            "question": "What does the `self` parameter refer to?",
            "options": ["The class itself", "The current instance of the class", "A global variable", "The parent class"],
            "correctAnswer": "The current instance of the class"
          },
          {
            "question": "How do you create an instance of a class named `Cat`?",
            "options": ["my_cat = Cat", "my_cat = new Cat()", "my_cat = Cat()", "create Cat() as my_cat"],
            "correctAnswer": "my_cat = Cat()"
          },
          {
            "question": "Variables that belong to an instance are called...",
            "options": ["Class attributes", "Global attributes", "Instance attributes", "Static attributes"],
            "correctAnswer": "Instance attributes"
          },
          {
            "question": "Functions defined inside a class are called...",
            "options": ["Procedures", "Methods", "Definitions", "Lambdas"],
            "correctAnswer": "Methods"
          }
        ],
        "pacing": "medium"
      },
      {
        "id": "13",
        "title": "Inheritance and Polymorphism",
        "description": "Learn how to create new classes from existing ones and how objects can share behaviors.",
        "content": [
          "**Inheritance** is a powerful OOP feature that allows you to create a new class that inherits attributes and methods from an existing class. The new class is called the **child class** (or derived class), and the one it inherits from is the **parent class** (or base class). This promotes code reuse.",
          "You define a child class by putting the parent class name in parentheses after the child class name: `class ChildClass(ParentClass):`.",
          "A child class can **override** a method from its parent. This means providing a new implementation for a method that is already defined in the parent. This is useful for specializing behavior, as seen in the example where `Cat` and `Dog` have different `speak` methods.",
          "**Polymorphism** literally means 'many forms'. In programming, it refers to the ability to use a common interface for different types of objects. Because both `Cat` and `Dog` inherit from `Animal`, we can treat them both as `Animal`s. We could have a function that takes any `Animal` object and calls its `.speak()` method, and it would work correctly for both cats and dogs, producing different results. This makes code more flexible and extensible."
        ],
        "codeExample": "# Parent class (Base class)\nclass Animal:\n  def __init__(self, name):\n    self.name = name\n  \n  def speak(self):\n    return f\"{self.name} makes a sound.\"\n\n# Child class (Derived class)\nclass Dog(Animal):\n  # Override the speak method\n  def speak(self):\n    return f\"{self.name} barks.\"\n\n# Another child class\nclass Cat(Animal):\n  # Override the speak method\n  def speak(self):\n    return f\"{self.name} meows.\"\n\nmy_dog = Dog(\"Buddy\")\nmy_cat = Cat(\"Whiskers\")\n\nprint(my_dog.speak()) # Calls the Dog's version\nprint(my_cat.speak()) # Calls the Cat's version",
        "quiz": [
          {
            "question": "What is the primary benefit of inheritance?",
            "options": ["Faster code", "Code reuse", "Simpler syntax", "Better memory management"],
            "correctAnswer": "Code reuse"
          },
          {
            "question": "How do you indicate that a class `Child` inherits from `Parent`?",
            "options": ["class Child(Parent):", "class Child inherits Parent:", "class Child extends Parent:", "class Child < Parent:"],
            "correctAnswer": "class Child(Parent):"
          },
          {
            "question": "When a child class provides its own implementation of a method that is already defined in its parent class, it's called...?",
            "options": ["Method overloading", "Method overriding", "Method hiding", "Method copying"],
            "correctAnswer": "Method overriding"
          },
          {
            "question": "The concept demonstrated by `my_dog.speak()` and `my_cat.speak()` returning different results for methods with the same name is...?",
            "options": ["Inheritance", "Encapsulation", "Polymorphism", "Abstraction"],
            "correctAnswer": "Polymorphism"
          },
          {
            "question": "A class that is inherited from is called a...",
            "options": ["Child class", "Derived class", "Subclass", "Parent class (or Base class)"],
            "correctAnswer": "Parent class (or Base class)"
          }
        ],
        "pacing": "fast"
      },
      {
        "id": "14",
        "title": "Modules and Packages",
        "description": "Learn how to organize your code into modules and packages.",
        "content": [
          "As your projects grow, putting all your code in one file becomes messy and unmanageable. Python's solution is **modules**. A module is simply a Python file (with a `.py` extension) containing functions, classes, and variables. You can then **import** that module into another file to use its contents.",
          "You can import an entire module using `import module_name`. You would then access its functions like `module_name.function_name()`. Alternatively, you can import specific parts from a module using `from module_name import function_name`. This lets you call `function_name()` directly.",
          "Python comes with a vast **Standard Library** full of useful modules you can import without installing anything extra. The `math` module for advanced math operations, `random` for random numbers, and `datetime` for working with dates and times are common examples.",
          "For even larger projects, you can group related modules together into a **package**. A package is just a directory that contains Python modules and a special (often empty) file named `__init__.py`. This file tells Python that the directory should be treated as a package, allowing you to organize your code in a hierarchical structure."
        ],
        "codeExample": "# 1. Import the entire math module\nimport math\nprint(f\"The value of Pi is approximately {math.pi}\")\n\n# 2. Import a specific function from the datetime module\nfrom datetime import date\ntoday = date.today()\nprint(f\"Today's date is {today}\")\n\n# 3. Import a module and give it a shorter alias\nimport random as rd\nrandom_number = rd.randint(1, 100)\nprint(f\"A random number is: {random_number}\")",
        "quiz": [
          {
            "question": "What is a Python module?",
            "options": ["A built-in function", "A Python file containing code", "A folder of scripts", "A type of class"],
            "correctAnswer": "A Python file containing code"
          },
          {
            "question": "Which keyword is used to bring a module's code into your current script?",
            "options": ["include", "use", "import", "load"],
            "correctAnswer": "import"
          },
          {
            "question": "How would you import only the `pi` constant from the `math` module?",
            "options": ["import math.pi", "from math import pi", "import pi from math", "using math.pi"],
            "correctAnswer": "from math import pi"
          },
          {
            "question": "What is a collection of modules in a directory called?",
            "options": ["Library", "Suite", "Package", "Set"],
            "correctAnswer": "Package"
          },
          {
            "question": "What is the purpose of `import math as m`?",
            "options": ["To create a copy of the math module", "To give the math module a shorter alias, `m`", "To import a module named 'm'", "To run the math module's main function"],
            "correctAnswer": "To give the math module a shorter alias, `m`"
          }
        ],
        "pacing": "medium"
      },
      {
        "id": "15",
        "title": "The Python Standard Library",
        "description": "Explore some of the most useful modules included with Python.",
        "content": [
          "One of Python's greatest strengths is its 'batteries-included' philosophy. This is embodied by the **Python Standard Library**, a massive collection of modules and packages that are automatically installed with Python. You don't need to download or install them separately; you just `import` them.",
          "Exploring the Standard Library is key to becoming an effective Python programmer, as it provides tools for a huge range of common tasks, saving you from having to write everything from scratch.",
          "Some essential modules to know are: **`os`** for interacting with the operating system (e.g., working with files and directories), **`sys`** for accessing system-specific parameters and functions (like command-line arguments), **`random`** for generating random numbers and making random choices, and **`json`** for encoding and decoding JSON data.",
          "This is just the tip of the iceberg. There are modules for handling compressed files, working with networks, performing mathematical calculations, and much more. The official Python documentation is the best place to explore all the available modules."
        ],
        "codeExample": "import random\nimport os\nimport platform\n\n# Use the random module to pick a random choice\nchoices = ['rock', 'paper', 'scissors']\ncomputer_choice = random.choice(choices)\nprint(f\"The computer chose: {computer_choice}\")\n\n# Use the os module to get the current working directory\ncurrent_directory = os.getcwd()\nprint(f\"This script is running in: {current_directory}\")\n\n# Use the platform module to get OS info\nos_name = platform.system()\nprint(f\"You are running on: {os_name}\")",
        "quiz": [
          {
            "question": "Which module would you use to get the current directory?",
            "options": ["sys", "os", "path", "system"],
            "correctAnswer": "os"
          },
          {
            "question": "To generate a random floating point number between 0.0 and 1.0, you would use...",
            "options": ["random.randint(0, 1)", "random.random()", "random.float()", "random.uniform(0, 1)"],
            "correctAnswer": "random.random()"
          },
          {
            "question": "Do you need to install modules from the Standard Library using pip?",
            "options": ["Yes, always", "No, they come with Python", "Only on Windows", "Only on Mac"],
            "correctAnswer": "No, they come with Python"
          },
          {
            "question": "The `json` module is used for...",
            "options": ["Working with JavaScript code", "Creating user interfaces", "Parsing and generating JSON data", "Mathematical operations"],
            "correctAnswer": "Parsing and generating JSON data"
          },
          {
            "question": "Which module provides access to system-specific parameters and functions?",
            "options": ["os", "sys", "system", "platform"],
            "correctAnswer": "sys"
          }
        ],
        "pacing": "medium"
      }
    ],
    "intermediate": [
       {
        "id": "16",
        "title": "List Comprehensions",
        "description": "Learn a concise way to create lists.",
        "content": [
          "Python offers many ways to write code that is both elegant and efficient. **List comprehensions** are a perfect example. They provide a compact, readable syntax for creating a list based on an existing sequence.",
          "A list comprehension consists of brackets `[]` containing an expression, followed by a `for` clause. For example, to create a list of squares from 0 to 9, you could write a for loop, or you could use a list comprehension: `squares = [x**2 for x in range(10)]`.",
          "The basic syntax is `[expression for item in iterable]`. This is often much shorter and clearer than a traditional `for` loop that initializes an empty list and appends to it in each iteration.",
          "You can also add an `if` condition to the end to filter items from the original sequence. The syntax becomes `[expression for item in iterable if condition]`. The expression is only evaluated for items where the condition is true. This makes them incredibly powerful for transforming and filtering data in a single line."
        ],
        "codeExample": "# A traditional for loop to get even numbers\neven_numbers_loop = []\nfor i in range(1, 11):\n  if i % 2 == 0:\n    even_numbers_loop.append(i)\nprint(f\"Using a loop: {even_numbers_loop}\")\n\n# Doing the same thing with a list comprehension\neven_numbers_comp = [i for i in range(1, 11) if i % 2 == 0]\nprint(f\"Using a comprehension: {even_numbers_comp}\")\n\n# You can also transform the data\nsquares_of_evens = [i**2 for i in range(1, 11) if i % 2 == 0]\nprint(f\"Squares of evens: {squares_of_evens}\")",
        "quiz": [
          {
            "question": "What is the main benefit of list comprehensions?",
            "options": ["They run faster", "They offer a more concise and readable syntax for creating lists", "They can do things for loops cannot", "They use less memory"],
            "correctAnswer": "They offer a more concise and readable syntax for creating lists"
          },
          {
            "question": "Which of these is a valid list comprehension?",
            "options": ["(x for x in range(5))", "[x for x in range(5)]", "{x for x in range(5)}", "list(x for x in range(5))"],
            "correctAnswer": "[x for x in range(5)]"
          },
          {
            "question": "How would you create a list of all the uppercase letters in a string `s`?",
            "options": ["[char.upper() for char in s]", "[char for char in s if char.isupper()]", "{char for char in s if char.isupper()}", "[char.upper() if char.islower() for char in s]"],
            "correctAnswer": "[char for char in s if char.isupper()]"
          },
          {
            "question": "Can you include a conditional `if` in a list comprehension?",
            "options": ["No, only for loops are allowed", "Yes, to filter elements", "Yes, but only at the beginning", "No, that requires a lambda function"],
            "correctAnswer": "Yes, to filter elements"
          },
          {
            "question": "What does `[num * 2 for num in [1, 2, 3]]` evaluate to?",
            "options": ["[1, 2, 3]", "[1, 4, 9]", "[2, 4, 6]", "[2, 2, 2]"],
            "correctAnswer": "[2, 4, 6]"
          }
        ],
        "pacing": "fast"
      },
      {
        "id": "17",
        "title": "Lambda Functions",
        "description": "Learn to create small, anonymous functions on the fly.",
        "content": [
          "A **lambda function** is a small, single-expression function that has no name (it's **anonymous**). It's defined using the `lambda` keyword.",
          "The syntax is `lambda arguments: expression`. The function can take any number of arguments, but can only have one expression. The expression is evaluated and returned when the function is called. Think of it as a shorthand for a simple `def` function with a single `return` statement.",
          "Why use them? Lambda functions are useful when you need a simple function for a short period of time, and you don't want to clutter your code with a full `def` function definition. They are very commonly used as arguments to higher-order functions (functions that take other functions as arguments), such as `map`, `filter`, or when sorting.",
          "For example, if you want to sort a list of tuples based on the second element of each tuple, you can provide a lambda function to the `key` argument of the `sort()` method: `my_list.sort(key=lambda x: x[1])`. This is much cleaner than defining a separate function just for this one-time use."
        ],
        "codeExample": "# A lambda function that adds 10 to a number\nadd_ten = lambda x: x + 10\nprint(f\"15 + 10 = {add_ten(15)}\")\n\n# A lambda function that multiplies two numbers\nmultiply = lambda x, y: x * y\nprint(f\"5 * 6 = {multiply(5, 6)}\")\n\n# Using a lambda function to sort a list of tuples by the second element\npoints = [(1, 5), (9, 2), (4, 7)]\npoints.sort(key=lambda point: point[1])\nprint(f\"Sorted points by y-axis: {points}\")",
        "quiz": [
          {
            "question": "What keyword is used to create a lambda function?",
            "options": ["def", "anon", "lambda", "function"],
            "correctAnswer": "lambda"
          },
          {
            "question": "What is a key limitation of lambda functions?",
            "options": ["They can only have one argument", "They cannot be stored in a variable", "They can only contain a single expression", "They cannot be used with lists"],
            "correctAnswer": "They can only contain a single expression"
          },
          {
            "question": "What is an 'anonymous' function?",
            "options": ["A function that is secret", "A function with no name", "A function that is not safe", "A function that returns nothing"],
            "correctAnswer": "A function with no name"
          },
          {
            "question": "Which of these is a valid lambda function that adds two numbers?",
            "options": ["lambda a, b: return a + b", "lambda a, b: a + b", "lambda (a, b): a + b", "def lambda(a, b): a + b"],
            "correctAnswer": "lambda a, b: a + b"
          },
          {
            "question": "When are lambda functions most commonly used?",
            "options": ["As standalone functions", "To define class methods", "As arguments to higher-order functions", "For file I/O"],
            "correctAnswer": "As arguments to higher-order functions"
          }
        ],
        "pacing": "fast"
      },
      {
        "id": "18",
        "title": "Map, Filter, and Reduce",
        "description": "Learn about powerful built-in functions for working with iterables.",
        "content": [
          "Python includes several powerful functions for a style of programming called **functional programming**. `map`, `filter`, and `reduce` are three of the most well-known.",
          "The **`map()`** function applies a given function to every item of an iterable (like a list) and returns a map object (which can be converted to a list). For example, `map(lambda x: x * 2, [1, 2, 3])` will apply the doubling function to each number.",
          "The **`filter()`** function creates an iterator from elements of an iterable for which a function returns `True`. It essentially filters the sequence. The function passed to `filter` must return a boolean value. For example, `filter(lambda x: x > 10, numbers)` will keep only the numbers greater than 10.",
          "The **`reduce()`** function is a bit different. It's part of the `functools` module and it applies a function of two arguments cumulatively to the items of a sequence, so as to reduce the sequence to a single value. For example, `reduce(lambda x, y: x + y, [1, 2, 3, 4])` would compute `((1+2)+3)+4` to get the sum."
        ],
        "codeExample": "from functools import reduce\n\nnumbers = [1, 2, 3, 4, 5, 6, 7, 8]\n\n# Map: Create a new list with the square of each number\nsquares = list(map(lambda x: x**2, numbers))\nprint(f\"Squares: {squares}\")\n\n# Filter: Create a new list with only the odd numbers\nodds = list(filter(lambda x: x % 2 != 0, numbers))\nprint(f\"Odd Numbers: {odds}\")\n\n# Reduce: Find the product of all numbers in the list\nproduct = reduce(lambda x, y: x * y, numbers)\nprint(f\"Product of all numbers: {product}\")",
        "quiz": [
          {
            "question": "Which function would you use to apply the same operation to every element in a list?",
            "options": ["filter", "reduce", "map", "apply"],
            "correctAnswer": "map"
          },
          {
            "question": "Which function would you use to create a new list containing only the elements that satisfy a certain condition?",
            "options": ["filter", "reduce", "map", "select"],
            "correctAnswer": "filter"
          },
          {
            "question": "Which module contains the `reduce` function?",
            "options": ["itertools", "collections", "functools", "math"],
            "correctAnswer": "functools"
          },
          {
            "question": "The function passed to `filter()` must return...",
            "options": ["A number", "A string", "A boolean value (True or False)", "A list"],
            "correctAnswer": "A boolean value (True or False)"
          },
          {
            "question": "What is the result of `reduce(lambda x, y: x + y, [1, 2, 3])`?",
            "options": ["3", "5", "6", "An error"],
            "correctAnswer": "6"
          }
        ],
        "pacing": "fast"
      },
      {
        "id": "19",
        "title": "Decorators",
        "description": "Learn how to modify or enhance functions without changing their code.",
        "content": [
          "In Python, functions are 'first-class citizens', which means you can treat them like any other variable: you can pass them as arguments to other functions, and you can have functions that return other functions. This capability is what makes **decorators** possible.",
          "A decorator is a function that takes another function as an argument, adds some kind of functionality (a 'decoration'), and then returns a new, enhanced function. This allows you to modify or extend the behavior of functions without permanently changing their source code.",
          "The most common way to apply a decorator is with the `@` syntax, which is just 'syntactic sugar'. Placing `@my_decorator` on the line before `def my_function():` is equivalent to writing `my_function = my_decorator(my_function)` after the function has been defined.",
          "Decorators are commonly used for tasks that apply to many functions, such as logging function calls, timing how long a function takes to run, checking user permissions before running a critical function, or managing database transactions."
        ],
        "codeExample": "def uppercase_decorator(function):\n    def wrapper():\n        # Get the original result\n        original_result = function()\n        # Modify it\n        modified_result = original_result.upper()\n        return modified_result\n    return wrapper\n\n# Apply the decorator to our function\n@uppercase_decorator\ndef say_greeting():\n    return \"hello there\"\n\n# Calling the function now calls the wrapped version\nprint(say_greeting())",
        "quiz": [
          {
            "question": "What is a decorator in Python?",
            "options": ["A type of class", "A function that modifies another function", "A syntax for comments", "A way to style code"],
            "correctAnswer": "A function that modifies another function"
          },
          {
            "question": "What symbol is used to apply a decorator?",
            "options": ["#", "$", "&", "@"],
            "correctAnswer": "@"
          },
          {
            "question": "What does a decorator function typically return?",
            "options": ["The original function, unmodified", "A new function (a wrapper)", "A boolean value", "Nothing"],
            "correctAnswer": "A new function (a wrapper)"
          },
          {
            "question": "Can you apply multiple decorators to a single function?",
            "options": ["No, only one is allowed", "Yes, they are applied from bottom to top"],
            "correctAnswer": "Yes, they are applied from bottom to top"
          },
          {
            "question": "A common use case for decorators is...",
            "options": ["Mathematical calculations", "Logging or timing function execution", "Storing data", "Defining variables"],
            "correctAnswer": "Logging or timing function execution"
          }
        ],
        "pacing": "fast"
      },
      {
        "id": "20",
        "title": "Generators",
        "description": "Learn to create iterators in a simple, memory-efficient way.",
        "content": [
          "A Python **generator** is a special kind of iterator. It's a function that, instead of returning a single value with `return`, 'yields' a sequence of values one at a time using the `yield` keyword.",
          "When you call a normal function, it runs to completion and returns. When you call a generator function, it returns a **generator object**. The code inside the function doesn't run until you start iterating over it, typically by calling `next()` on the generator object or using it in a `for` loop.",
          "Each time `yield` is encountered, the function pauses its execution and sends the value back. The next time you call `next()` on it, the function resumes right from where it left off, with all its local variables intact.",
          "The primary advantage of generators is their **memory efficiency**. They produce items on-the-fly and don't store the entire sequence in memory. This makes them perfect for working with very large datasets, reading large files, or generating infinite sequences where storing everything would be impossible."
        ],
        "codeExample": "# This generator function yields numbers from 0 up to (but not including) max\ndef number_generator(max):\n    n = 0\n    while n < max:\n        print(f\"- Yielding {n}\")\n        yield n\n        n += 1\n\n# Using the generator in a for loop\nprint(\"Looping through the generator:\")\nfor number in number_generator(4):\n    print(f\"  Received {number}\")",
        "quiz": [
          {
            "question": "What keyword is used in a generator function to produce a value?",
            "options": ["return", "generate", "yield", "produce"],
            "correctAnswer": "yield"
          },
          {
            "question": "What is the main advantage of using generators?",
            "options": ["They are faster than regular functions", "They are memory-efficient", "They are easier to write", "They can be used as decorators"],
            "correctAnswer": "They are memory-efficient"
          },
          {
            "question": "What does calling a generator function return?",
            "options": ["It executes the entire function and returns a list", "It returns a generator object", "It raises an error immediately", "It prints all values to the console"],
            "correctAnswer": "It returns a generator object"
          },
          {
            "question": "How do you get the next value from a generator `gen`?",
            "options": ["gen.next()", "next(gen)", "gen.get()", "gen.yield()"],
            "correctAnswer": "next(gen)"
          },
          {
            "question": "What happens when a generator has yielded all its values and you call `next()` on it again?",
            "options": ["It starts over from the beginning", "It raises a StopIteration exception", "It returns None", "It waits for more data"],
            "correctAnswer": "It raises a StopIteration exception"
          }
        ],
        "pacing": "fast"
      },
      {
        "id": "21",
        "title": "Working with Files",
        "description": "Learn to read from and write to files on your computer.",
        "content": [
          "A common requirement for programs is to read data from files or write data to them for permanent storage. Python makes this process straightforward. The key function for this is `open()`.",
          "The `open()` function takes two main arguments: the file path and the **mode**. The mode is a string that specifies how you want to interact with the file. The most common modes are: `'r'` for reading (default), `'w'` for writing (will overwrite the file if it exists), and `'a'` for appending (adds to the end of the file).",
          "It is considered best practice to use the `with` statement when working with files. The syntax `with open('filename', 'r') as f:` creates a context where the file is open. The main advantage is that Python will automatically close the file for you once the indented block is exited, even if errors occur.",
          "Once a file is open, you can use methods like `.read()` to get the entire content as a single string, `.readline()` to get one line at a time, or `.readlines()` to get all lines as a list of strings. To write, you use the `.write()` method."
        ],
        "codeExample": "# This code will create a new file named 'demo.txt'\n# The 'w' mode means we are writing to it.\nwith open(\"demo.txt\", \"w\") as f:\n    f.write(\"This is the first line.\\n\")\n    f.write(\"This is the second line.\\n\")\n\nprint(\"'demo.txt' has been created.\")\n\n# Now, let's read the content back from the file.\n# The 'r' mode means we are reading.\nwith open(\"demo.txt\", \"r\") as f:\n    content = f.read()\n    print(\"\\nContent of 'demo.txt':\")\n    print(content)",
        "quiz": [
          {
            "question": "What is the mode for opening a file for writing, which will overwrite existing content?",
            "options": ["'r'", "'x'", "'w'", "'a'"],
            "correctAnswer": "'w'"
          },
          {
            "question": "Why is using the `with open(...)` syntax recommended?",
            "options": ["It runs faster", "It automatically closes the file", "It can open any file type", "It encrypts the file"],
            "correctAnswer": "It automatically closes the file"
          },
          {
            "question": "What does opening a file in append mode (`'a'`) do?",
            "options": ["Deletes the file", "Reads the file", "Overwrites the file's content", "Adds new content to the end of the file"],
            "correctAnswer": "Adds new content to the end of the file"
          },
          {
            "question": "Which function reads the entire content of a file into a single string?",
            "options": ["read()", "readline()", "readlines()", "get_content()"],
            "correctAnswer": "read()"
          },
          {
            "question": "If you open an existing file in write mode (`'w'`), what happens to its original content?",
            "options": ["The new content is added to the end", "An error occurs", "The original content is erased", "The original content is moved to a backup file"],
            "correctAnswer": "The original content is erased"
          }
        ],
        "pacing": "medium"
      },
      {
        "id": "22",
        "title": "Working with JSON",
        "description": "Learn to parse and create JSON data, a common format for data exchange.",
        "content": [
          "JSON (JavaScript Object Notation) is a lightweight, text-based format for data exchange. It's the de-facto standard for web APIs and configuration files because it's easy for humans to read and for machines to parse.",
          "Python's `json` module, part of the standard library, makes working with JSON data seamless. It maps Python objects to their JSON equivalents. For example, a Python dictionary `{}` becomes a JSON object `{}`, a Python list `[]` becomes a JSON array `[]`, and `None` becomes `null`.",
          "To convert a Python object (like a dictionary or list) into a JSON formatted string, you use the `json.dumps()` method (dump string). You can pass `indent=4` to make the output string nicely formatted and readable.",
          "To do the reverse—parse a JSON formatted string into a Python object—you use the `json.loads()` method (load string). This will typically return a Python dictionary or list that you can then work with in your code."
        ],
        "codeExample": "import json\n\n# A Python dictionary\nperson_dict = {\n    'name': 'Yehia',\n    'age': 30,\n    'isStudent': False,\n    'courses': ['History', 'CompSci']\n}\n\n# 1. Convert the Python dictionary to a JSON string (serialization)\njson_string = json.dumps(person_dict, indent=4)\nprint(\"--- JSON String ---\")\nprint(json_string)\n\n# 2. Convert the JSON string back to a Python dictionary (deserialization)\nparsed_dict = json.loads(json_string)\nprint(\"\\n--- Parsed Dictionary ---\")\nprint(parsed_dict)\nprint(f\"The name is: {parsed_dict['name']}\")",
        "quiz": [
          {
            "question": "What does JSON stand for?",
            "options": ["Java Standard Object Notation", "JavaScript Object Notation", "JavaScript Ordered Notation", "Java Source Object Notation"],
            "correctAnswer": "JavaScript Object Notation"
          },
          {
            "question": "Which `json` method converts a Python dictionary to a JSON string?",
            "options": ["json.load()", "json.loads()", "json.dump()", "json.dumps()"],
            "correctAnswer": "json.dumps()"
          },
          {
            "question": "Which `json` method parses a JSON string into a Python object?",
            "options": ["json.load()", "json.loads()", "json.dump()", "json.dumps()"],
            "correctAnswer": "json.loads()"
          },
          {
            "question": "What Python data type does a JSON object typically map to?",
            "options": ["List", "Tuple", "Dictionary", "Set"],
            "correctAnswer": "Dictionary"
          },
          {
            "question": "In `json.dumps(data, indent=4)`, what is the purpose of `indent=4`?",
            "options": ["It makes the JSON string more compact", "It adds 4 spaces of indentation for pretty-printing", "It encrypts the data 4 times", "It limits the depth of the JSON to 4 levels"],
            "correctAnswer": "It adds 4 spaces of indentation for pretty-printing"
          }
        ],
        "pacing": "medium"
      },
      {
        "id": "23",
        "title": "Introduction to APIs",
        "description": "Understand what APIs are and how to interact with them using Python.",
        "content": [
          "API stands for **Application Programming Interface**. At its core, an API is a set of rules and protocols that allows two different software applications to communicate with each other. It's a contract that defines how one piece of software can request services or data from another.",
          "In modern web development, you'll constantly interact with web APIs. These APIs allow you to fetch data from external services over the internet. For example, when an app shows you the weather, it's likely calling a weather service's API. This saves developers from having to build their own weather-tracking infrastructure.",
          "The most common way to interact with web APIs is using HTTP requests. The most popular third-party library for this in Python is `requests`. It simplifies the process of making different types of requests, like a `GET` request to retrieve data, or a `POST` request to send new data.",
          "When you make a successful request to an API, it sends back a response. This response includes a **status code** (e.g., `200` for success, `404` for not found) and often a body containing the requested data, typically in JSON format. You can then use the `response.json()` method to parse this data into a Python dictionary."
        ],
        "codeExample": "# You may need to run 'pip install requests' in your terminal first\nimport requests\nimport json\n\n# API endpoint for a random joke\nURL = \"https://official-joke-api.appspot.com/random_joke\"\n\nprint(\"Fetching a random joke from an API...\")\n# Make a GET request to the API\nresponse = requests.get(URL)\n\n# Check if the request was successful (status code 200)\nif response.status_code == 200:\n    # Parse the JSON response into a Python dictionary\n    data = response.json()\n    print(\"\\nSetup: \" + data['setup'])\n    print(\"Punchline: \" + data['punchline'])\nelse:\n    print(f\"Failed to get data. Status code: {response.status_code}\")",
        "quiz": [
          {
            "question": "What does API stand for?",
            "options": ["Application Protocol Interface", "Application Programming Interface", "Advanced Programming Interlink", "Application Protocol Instance"],
            "correctAnswer": "Application Programming Interface"
          },
          {
            "question": "Which library is most commonly used to make HTTP requests in Python?",
            "options": ["http", "urllib", "requests", "web"],
            "correctAnswer": "requests"
          },
          {
            "question": "What HTTP status code indicates a successful request?",
            "options": ["200", "404", "500", "301"],
            "correctAnswer": "200"
          },
          {
            "question": "Which HTTP method is typically used to retrieve data from an API?",
            "options": ["POST", "GET", "DELETE", "PUT"],
            "correctAnswer": "GET"
          },
          {
            "question": "After getting a response from `requests.get()`, which method is used to parse the JSON content?",
            "options": ["response.text", "response.content", "response.json()", "response.parse()"],
            "correctAnswer": "response.json()"
          }
        ],
        "pacing": "medium"
      },
      {
        "id": "24",
        "title": "Basic Web Scraping",
        "description": "Learn to extract data from websites using Requests and BeautifulSoup.",
        "content": [
          "**Web scraping** is the automated process of extracting data from websites. It's a useful technique when the data you want is available on a website but not through a structured API. For example, you might scrape product prices from an e-commerce site or headlines from a news site.",
          "The process generally involves two main steps. First, you use a library like `requests` to download the raw HTML content of a web page, just like your browser would. This gives you the page's source code as a string.",
          "Second, raw HTML is difficult to work with. So, you use a parsing library to turn the HTML string into a structured object that you can navigate. The most popular library for this in Python is **`BeautifulSoup`**. It allows you to search for and extract information by finding specific HTML tags (like `<h1>` or `<p>`), or elements with specific CSS classes or IDs.",
          "**Important Note:** Always be respectful when scraping. Check a website's `robots.txt` file (e.g., `example.com/robots.txt`) and its Terms of Service to see if they permit scraping. Scraping too aggressively can overload a website's servers and is considered bad practice."
        ],
        "codeExample": "# NOTE: You would need to install these libraries first:\n# pip install requests beautifulsoup4\nimport requests\nfrom bs4 import BeautifulSoup\n\n# This is a conceptual example. Scraping a real site requires inspecting its HTML.\nURL = \"http://example.com\"\ntry:\n    response = requests.get(URL)\n    # Create a BeautifulSoup object to parse the HTML\n    soup = BeautifulSoup(response.content, 'html.parser')\n\n    # Find the first <h1> tag and get its text\n    title = soup.find('h1').text\n    print(f\"The title of the page is: '{title}'\")\n\n    # Find the first <p> tag\n    paragraph = soup.find('p').text\n    print(f\"The first paragraph says: '{paragraph}'\")\nexcept Exception as e:\n    print(f\"Could not scrape the website. Error: {e}\")",
        "quiz": [
          {
            "question": "What is web scraping?",
            "options": ["Designing websites", "Automatically extracting data from websites", "Securing websites", "Testing website speed"],
            "correctAnswer": "Automatically extracting data from websites"
          },
          {
            "question": "Which library is most commonly used to parse HTML content in Python?",
            "options": ["requests", "json", "BeautifulSoup", "os"],
            "correctAnswer": "BeautifulSoup"
          },
          {
            "question": "Which library is used to download the webpage's HTML?",
            "options": ["requests", "bs4", "parser", "html"],
            "correctAnswer": "requests"
          },
          {
            "question": "In BeautifulSoup, which method is typically used to find the first occurrence of a tag?",
            "options": ["find()", "find_all()", "select()", "get()"],
            "correctAnswer": "find()"
          },
          {
            "question": "Is it always okay to scrape any website?",
            "options": ["Yes, all data on the internet is free", "No, you should always check a website's terms of service and `robots.txt` file first"],
            "correctAnswer": "No, you should always check a website's terms of service and `robots.txt` file first"
          }
        ],
        "pacing": "medium"
      },
      {
        "id": "25",
        "title": "Virtual Environments and pip",
        "description": "Learn to manage project dependencies with virtual environments and the pip package manager.",
        "content": [
          "As you work on more Python projects, you'll start using third-party libraries (code written by other people). A problem arises when Project A needs version 1.0 of a library, but Project B needs version 2.0. Installing these system-wide can cause conflicts.",
          "A **virtual environment** solves this problem. It's an isolated, self-contained directory that contains a specific version of Python plus all the libraries required for a particular project. This keeps your project dependencies separate from other projects and from your system's global Python installation.",
          "**`pip`** is the Package Installer for Python. It's the command-line tool you use to install, upgrade, and remove packages from the Python Package Index (PyPI). When you have a virtual environment activated, `pip` will install packages *inside* that environment only.",
          "It's a standard practice to keep a list of your project's dependencies in a file, conventionally named `requirements.txt`. You can generate this file with `pip freeze > requirements.txt`. This allows another developer to easily install the exact same set of libraries by running `pip install -r requirements.txt`."
        ],
        "codeExample": "# You would run these commands in your terminal, not in a Python script.\n\n# 1. Go to your project folder and create a virtual environment\n# python -m venv myenv\n\n# 2. Activate the environment\n# On Windows: .\\myenv\\Scripts\\activate\n# On Mac/Linux: source myenv/bin/activate\n\n# 3. Once activated, your terminal prompt will change.\n# Now, install a package. It will be installed only in 'myenv'.\n# pip install requests\n\n# 4. Save your dependencies to a file.\n# pip freeze > requirements.txt\n\n# 5. When you're done, deactivate the environment.\n# deactivate\n\nprint(\"The commands above are for your terminal to manage project dependencies.\")",
        "quiz": [
          {
            "question": "What is the primary purpose of a virtual environment?",
            "options": ["To make your code run faster", "To isolate project dependencies and avoid conflicts", "To write Python code", "To share your code online"],
            "correctAnswer": "To isolate project dependencies and avoid conflicts"
          },
          {
            "question": "What is `pip`?",
            "options": ["A Python code editor", "A Python version manager", "The standard package installer for Python", "A type of virtual environment"],
            "correctAnswer": "The standard package installer for Python"
          },
          {
            "question": "Which command creates a virtual environment named `venv`?",
            "options": ["pip create venv", "python -m venv venv", "virtualenv create venv", "python new venv"],
            "correctAnswer": "python -m venv venv"
          },
          {
            "question": "What is the common name for the file used to list a project's dependencies?",
            "options": ["packages.json", "dependencies.yml", "pip.conf", "requirements.txt"],
            "correctAnswer": "requirements.txt"
          },
          {
            "question": "Which command installs all packages from a `requirements.txt` file?",
            "options": ["pip install all", "pip requirements.txt", "pip install -r requirements.txt", "pip load requirements.txt"],
            "correctAnswer": "pip install -r requirements.txt"
          }
        ],
        "pacing": "medium"
      },
      {
        "id": "26",
        "title": "Introduction to Testing with `unittest`",
        "description": "Understand the importance of testing and learn the basics of Python's `unittest` framework.",
        "content": [
          "Writing code that works is only part of the job; ensuring it works correctly is just as important. **Automated testing** is the practice of writing code to test your application code. This provides a safety net, ensuring that new changes don't break existing functionality (this is called preventing **regressions**).",
          "Python's standard library includes the **`unittest`** framework for writing tests. While other popular frameworks like `pytest` exist, `unittest` is a great place to start.",
          "With `unittest`, you create a test file (e.g., `test_my_code.py`). Inside, you create a class that inherits from `unittest.TestCase`. Each individual test is a method within this class whose name starts with `test_`.",
          "Within each test method, you use special **assertion methods** (like `self.assertEqual()`, `self.assertTrue()`, `self.assertIn()`) to check if the result of your code is what you expect it to be. If an assertion fails, the test fails, and the framework reports the error."
        ],
        "codeExample": "import unittest\n\n# A simple function we want to test\ndef add_numbers(a, b):\n    return a + b\n\n# A test case class for our function\n# This would normally be in a separate file like 'test_adder.py'\nclass TestAddNumbers(unittest.TestCase):\n\n    def test_two_positives(self):\n        \"\"\"Test adding two positive numbers.\"\"\"\n        self.assertEqual(add_numbers(5, 10), 15)\n\n    def test_one_negative(self):\n        \"\"\"Test adding a positive and a negative number.\"\"\"\n        self.assertEqual(add_numbers(5, -2), 3)\n\n    def test_two_negatives(self):\n        \"\"\"Test adding two negative numbers.\"\"\"\n        self.assertEqual(add_numbers(-5, -5), -10)\n\n# To run the tests, you would typically use the command line:\n# python -m unittest test_adder.py\nprint(\"This example shows how to structure a test case with unittest.\")",
        "quiz": [
          {
            "question": "Why is testing important in software development?",
            "options": ["To make the code longer", "To ensure code quality and prevent regressions", "To slow down development", "To replace comments"],
            "correctAnswer": "To ensure code quality and prevent regressions"
          },
          {
            "question": "What is the name of Python's built-in testing framework?",
            "options": ["pytest", "nose2", "unittest", "doctest"],
            "correctAnswer": "unittest"
          },
          {
            "question": "In `unittest`, test methods must start with...",
            "options": ["assert_", "check_", "test_", "verify_"],
            "correctAnswer": "test_"
          },
          {
            "question": "Which assertion `unittest` method checks if two values are equal?",
            "options": ["assertTrue()", "assertIs()", "assertEqual()", "assertIn()"],
            "correctAnswer": "assertEqual()"
          },
          {
            "question": "Test case classes in `unittest` must inherit from which class?",
            "options": ["unittest.Test", "unittest.Suite", "unittest.Case", "unittest.TestCase"],
            "correctAnswer": "unittest.TestCase"
          }
        ],
        "pacing": "medium"
      },
      {
        "id": "27",
        "title": "Debugging Python Code",
        "description": "Learn techniques and tools for finding and fixing bugs in your code.",
        "content": [
          "No matter how experienced you are, your code will have bugs. **Debugging** is the essential skill of finding and fixing these bugs. Being good at debugging will save you countless hours of frustration.",
          "The simplest debugging technique is using **`print()` statements**. You can strategically place `print(my_variable)` in your code to see the state of your variables at different points and figure out where things went wrong. While simple, it's surprisingly effective.",
          "For more complex issues, you need a more powerful tool: a **debugger**. Python's built-in debugger is called **`pdb`**. It allows you to pause your program's execution at a specific point (called a **breakpoint**).",
          "Once paused, you can step through your code line by line, inspect the values of all variables at that moment, and execute code to see what happens. This gives you a much deeper insight into what your program is doing. You can set a breakpoint in your code by importing `pdb` and then calling `pdb.set_trace()`."
        ],
        "codeExample": "import pdb\n\ndef buggy_function(items):\n    total = 0\n    for item in items:\n        # Let's set a breakpoint here to inspect 'item' and 'total'\n        pdb.set_trace()\n        total += item\n    return total\n\n# When you run this, the program will pause at the breakpoint.\n# In the terminal, you can type 'item' or 'total' to see their values.\n# Type 'c' (continue) to exit the debugger and finish the program.\n\n# numbers = [10, '20', 30] # This would cause a TypeError\n# print(buggy_function(numbers))\n\nprint(\"The pdb module allows interactive debugging. Uncomment the lines above to try it.\")",
        "quiz": [
          {
            "question": "What is debugging?",
            "options": ["Writing new code", "The process of finding and fixing bugs", "Optimizing code speed", "Commenting code"],
            "correctAnswer": "The process of finding and fixing bugs"
          },
          {
            "question": "What is the simplest debugging technique?",
            "options": ["Using a professional debugger", "Asking a friend", "Using `print()` statements", "Rewriting the code"],
            "correctAnswer": "Using `print()` statements"
          },
          {
            "question": "What is Python's built-in debugger module called?",
            "options": ["debug", "pdb", "pydebug", "debugger"],
            "correctAnswer": "pdb"
          },
          {
            "question": "What does `pdb.set_trace()` do?",
            "options": ["It prints the call stack", "It ends the program", "It sets a breakpoint and starts the debugger", "It ignores all errors"],
            "correctAnswer": "It sets a breakpoint and starts the debugger"
          },
          {
            "question": "In a debugger, what does 'stepping through' the code mean?",
            "options": ["Executing the code very slowly", "Executing the code line by line", "Jumping to the end of the function", "Deleting lines of code"],
            "correctAnswer": "Executing the code line by line"
          }
        ],
        "pacing": "medium"
      },
      {
        "id": "28",
        "title": "Python Best Practices (PEP 8)",
        "description": "Learn about PEP 8, the official style guide for Python code, to write clean and readable code.",
        "content": [
          "Writing code that works is one thing; writing code that is clean, readable, and maintainable is another. **PEP 8** (Python Enhancement Proposal 8) is the official style guide for Python code. It provides a set of conventions that most Python developers follow.",
          "Following PEP 8 makes your code more consistent and easier for other Python programmers (including your future self!) to read and understand. Key guidelines include: **Indentation** should be 4 spaces per level. **Line length** should be limited to 79 characters to improve readability.",
          "**Naming conventions** are also crucial. Use `snake_case` for functions and variables (e.g., `my_variable`, `calculate_sum`). Use `PascalCase` (also called `CamelCase`) for class names (e.g., `MyClass`). Use `UPPERCASE_SNAKE_CASE` for constants.",
          "Tools like linters (e.g., `flake8`) and auto-formatters (e.g., `black` or `autopep8`) can automatically check your code for PEP 8 compliance and even fix many issues for you. Integrating these tools into your workflow is a great habit to build."
        ],
        "codeExample": "# Good PEP 8 style\n\nCONSTANT_VALUE = 3.14\n\ndef calculate_area(radius):\n    return CONSTANT_VALUE * radius * radius\n\nclass Circle:\n    def __init__(self, radius):\n        self.radius = radius\n\n    def get_area(self):\n        return calculate_area(self.radius)\n\nmy_circle = Circle(10)\nprint(f\"The area is: {my_circle.get_area()}\")",
        "quiz": [
          {
            "question": "What is PEP 8?",
            "options": ["A Python enhancement proposal for a new feature", "The official style guide for Python code", "A library for code formatting", "A version of Python"],
            "correctAnswer": "The official style guide for Python code"
          },
          {
            "question": "According to PEP 8, what is the preferred way to indent code?",
            "options": ["2 spaces", "Tabs", "4 spaces", "8 spaces"],
            "correctAnswer": "4 spaces"
          },
          {
            "question": "What is the recommended naming convention for functions and variables?",
            "options": ["camelCase", "PascalCase", "kebab-case", "snake_case"],
            "correctAnswer": "snake_case"
          },
          {
            "question": "What is the recommended naming convention for classes?",
            "options": ["camelCase", "PascalCase (or CamelCase)", "snake_case", "UPPER_CASE"],
            "correctAnswer": "PascalCase (or CamelCase)"
          },
          {
            "question": "Why is following a style guide like PEP 8 important?",
            "options": ["It's required for the code to run", "It improves code readability and consistency", "It makes the code run faster", "It adds more features to the language"],
            "correctAnswer": "It improves code readability and consistency"
          }
        ],
        "pacing": "medium"
      },
      {
        "id": "29",
        "title": "Advanced Data Structures: `collections`",
        "description": "Go beyond lists and dictionaries with the powerful data structures in the `collections` module.",
        "content": [
          "The `collections` module provides specialized, high-performance container datatypes that are alternatives to Python's general-purpose built-in containers like `dict`, `list`, `set`, and `tuple`.",
          "**`defaultdict`**: This is like a regular dictionary, but you provide a default factory function when you create it. If you try to access a key that doesn't exist, it will automatically create it with the default value instead of raising a `KeyError`. This is incredibly useful for grouping or counting items.",
          "**`Counter`**: A `Counter` is a `dict` subclass for counting hashable objects. It's a collection where elements are stored as dictionary keys and their counts are stored as dictionary values. It's perfect for tallying up items in a list.",
          "**`deque`**: A `deque` (pronounced 'deck') is a double-ended queue. It's like a list but provides fast appends and pops from both ends. This makes it ideal for implementing queues and stacks where you need efficient additions and removals from the beginning and end of the sequence."
        ],
        "codeExample": "from collections import defaultdict, Counter, deque\n\n# defaultdict example\ns = [('yellow', 1), ('blue', 2), ('yellow', 3), ('blue', 4), ('red', 1)]\nd = defaultdict(list)\nfor k, v in s:\n    d[k].append(v)\nprint(f\"defaultdict: {sorted(d.items())}\")\n\n# Counter example\nword_list = ['red', 'blue', 'red', 'green', 'blue', 'blue']\ncounts = Counter(word_list)\nprint(f\"Counter: {counts}\")\n\n# deque example\nq = deque(['Eric', 'John', 'Michael'])\nq.append('Terry')\nq.appendleft('Graham')\nprint(f\"deque: {q}\")\nprint(f\"Popped from left: {q.popleft()}\")",
        "quiz": [
          {
            "question": "What is the primary benefit of a `defaultdict`?",
            "options": ["It's faster than a regular dict", "It prevents `KeyError` by providing a default value for missing keys", "It can only store integers", "It maintains insertion order"],
            "correctAnswer": "It prevents `KeyError` by providing a default value for missing keys"
          },
          {
            "question": "Which `collections` class is best suited for tallying the frequency of items in a list?",
            "options": ["deque", "defaultdict", "Counter", "namedtuple"],
            "correctAnswer": "Counter"
          },
          {
            "question": "What does `deque` stand for?",
            "options": ["Decorated queue", "Double-ended queue", "Default queue", "Dynamic queue"],
            "correctAnswer": "Double-ended queue"
          },
          {
            "question": "If you need fast appends and pops from both the beginning and end of a sequence, which data structure is most efficient?",
            "options": ["list", "tuple", "deque", "set"],
            "correctAnswer": "deque"
          },
          {
            "question": "Accessing a non-existent key in a `defaultdict(int)` will result in what?",
            "options": ["A KeyError", "A value of None", "A value of 0", "A TypeError"],
            "correctAnswer": "A value of 0"
          }
        ],
        "pacing": "medium"
      },
      {
        "id": "30",
        "title": "Advanced Argument Unpacking",
        "description": "Master writing flexible functions that can accept a variable number of arguments using `*args` and `**kwargs`.",
        "content": [
          "You've learned how to define functions with a fixed number of arguments. But what if you want to create a function that can accept any number of positional or keyword arguments? This is where `*args` and `**kwargs` come in.",
          "**`*args` (Arguments)**: The syntax `*args` in a function definition allows you to pass a variable number of positional arguments. Inside the function, `args` will be a tuple containing all the positional arguments that were passed.",
          "**`**kwargs` (Keyword Arguments)**: The syntax `**kwargs` allows you to pass a variable number of keyword arguments. Inside the function, `kwargs` will be a dictionary containing all the keyword arguments that were passed, with the argument names as keys.",
          "You can also use the `*` and `**` operators when calling a function to 'unpack' a list/tuple or a dictionary into positional or keyword arguments, respectively. This is a powerful feature for passing arguments programmatically."
        ],
        "codeExample": "# Function using *args and **kwargs\ndef flexible_function(*args, **kwargs):\n    print(f\"Positional arguments (args): {args}\")\n    print(f\"Keyword arguments (kwargs): {kwargs}\")\n\n# Call the function with various arguments\nflexible_function(1, 2, 3, name=\"Alice\", age=30)\n\n# Unpacking a list and dictionary\nmy_list = ['a', 'b']\nmy_dict = {'x': 100, 'y': 200}\n\n# This is equivalent to flexible_function('a', 'b', x=100, y=200)\nflexible_function(*my_list, **my_dict)",
        "quiz": [
          {
            "question": "In a function definition, what type of object is `*args`?",
            "options": ["A list", "A tuple", "A dictionary", "A set"],
            "correctAnswer": "A tuple"
          },
          {
            "question": "In a function definition, what type of object is `**kwargs`?",
            "options": ["A list", "A tuple", "A dictionary", "A set"],
            "correctAnswer": "A dictionary"
          },
          {
            "question": "What is the primary purpose of `*args`?",
            "options": ["To accept only keyword arguments", "To accept a variable number of positional arguments", "To accept only two arguments", "To unpack a dictionary when calling a function"],
            "correctAnswer": "To accept a variable number of positional arguments"
          },
          {
            "question": "If you call `my_func(name='Bob', age=40)`, what will `kwargs` be inside `def my_func(**kwargs):`?",
            "options": ["('name', 'age')", "{'name': 'Bob', 'age': 40}", "['Bob', 40]", "{'Bob': 'name', 40: 'age'}"],
            "correctAnswer": "{'name': 'Bob', 'age': 40}"
          },
          {
            "question": "The names 'args' and 'kwargs' are mandatory.",
            "options": ["True", "False"],
            "correctAnswer": "False"
          }
        ],
        "pacing": "medium"
      }
    ],
    "advanced": [
       {
        "id": "31",
        "title": "Context Managers and `with`",
        "description": "Learn how to properly manage resources like files and network connections using the `with` statement.",
        "content": [
          "You've already used the `with` statement for file handling. This is an example of a **context manager**. A context manager is an object that defines a temporary context for a block of code, ensuring that resources are properly acquired and released.",
          "The primary benefit is resource management. When you enter a `with` block, the context manager's `__enter__` method is called. When you exit the block (either normally or through an exception), its `__exit__` method is called. This guarantees that cleanup code (like closing a file or a database connection) is always executed.",
          "While files are the most common example, you can create your own context managers. You can do this by defining a class with `__enter__` and `__exit__` methods, or more easily by using the `@contextmanager` decorator from the `contextlib` module on a generator function.",
          "Understanding context managers is crucial for writing robust Python code that doesn't leak resources."
        ],
        "codeExample": "from contextlib import contextmanager\n\n# A simple generator-based context manager\n@contextmanager\ndef simple_timer(name):\n    import time\n    print(f\"Entering timer '{name}'...\")\n    start_time = time.time()\n    try:\n        yield\n    finally:\n        end_time = time.time()\n        print(f\"Exiting timer '{name}'. Duration: {end_time - start_time:.2f}s\")\n\n# Using the context manager\nwith simple_timer(\"My Task\"):\n    print(\"Doing some work...\")\n    # Simulate a 1-second task\n    time.sleep(1)",
        "quiz": [
          {
            "question": "What is the primary purpose of a context manager?",
            "options": ["To time code execution", "To simplify function calls", "To manage resources and ensure cleanup", "To create new data types"],
            "correctAnswer": "To manage resources and ensure cleanup"
          },
          {
            "question": "A class-based context manager must implement which two special methods?",
            "options": ["__start__ and __stop__", "__begin__ and __end__", "__enter__ and __exit__", "__init__ and __del__"],
            "correctAnswer": "__enter__ and __exit__"
          },
          {
            "question": "Which method of a context manager is called when exiting a `with` block?",
            "options": ["__exit__", "__enter__", "__del__", "__close__"],
            "correctAnswer": "__exit__"
          },
          {
            "question": "Is the `__exit__` method called if an exception occurs inside the `with` block?",
            "options": ["Yes", "No"],
            "correctAnswer": "Yes"
          },
          {
            "question": "Which module provides the `@contextmanager` decorator?",
            "options": ["context", "managers", "withtools", "contextlib"],
            "correctAnswer": "contextlib"
          }
        ],
        "pacing": "fast"
      },
      {
        "id": "32",
        "title": "Advanced OOP: Properties",
        "description": "Control attribute access with Python's `property` decorator for cleaner, more maintainable classes.",
        "content": [
          "Sometimes you want to add logic when getting, setting, or deleting an attribute's value. You could create explicit getter and setter methods (e.g., `get_name()`, `set_name()`), but this can make the code clunky. Python's `property` decorator provides a more 'Pythonic' way.",
          "The `@property` decorator lets you turn a class method into a 'getter' for an attribute. This means you can call the method without parentheses, just like accessing a regular attribute, but custom logic will run behind the scenes.",
          "To create a 'setter' for this property, you use another decorator named after the getter method, like `@my_property.setter`. This method will be called whenever someone tries to assign a value to the attribute (e.g., `obj.my_property = value`). This is the perfect place to add validation logic.",
          "Using properties allows you to start with simple public attributes and later add getter/setter logic without changing the public API of your class, which is great for maintainability."
        ],
        "codeExample": "class Product:\n    def __init__(self, price):\n        self._price = price # Note the underscore for the 'private' attribute\n\n    @property\n    def price(self):\n        \"\"\"This is the 'getter' method.\"\"\"\n        return self._price\n\n    @price.setter\n    def price(self, value):\n        \"\"\"This is the 'setter' method with validation.\"\"\"\n        if value < 0:\n            raise ValueError(\"Price cannot be negative.\")\n        self._price = value\n\n# Create a product\nshirt = Product(20)\n\n# Access the price using the getter (no parentheses)\nprint(f\"The price is: ${shirt.price}\")\n\n# Change the price using the setter\nshirt.price = 25\nprint(f\"The new price is: ${shirt.price}\")\n\n# This will raise a ValueError\ntry:\n    shirt.price = -10\nexcept ValueError as e:\n    print(f\"Error: {e}\")",
        "quiz": [
          {
            "question": "Which decorator is used to create a 'getter' method for an attribute?",
            "options": ["@getter", "@property", "@get", "@attribute"],
            "correctAnswer": "@property"
          },
          {
            "question": "How do you define a 'setter' for a property named `value`?",
            "options": ["@setter(value)", "@value.setter", "@set.value", "def set_value(self, new_val):"],
            "correctAnswer": "@value.setter"
          },
          {
            "question": "What is a major benefit of using properties?",
            "options": ["They make code run faster.", "They allow you to add logic (like validation) to attribute access.", "They make attributes private.", "They are required for all classes."],
            "correctAnswer": "They allow you to add logic (like validation) to attribute access."
          },
          {
            "question": "If a class has a property named `temperature`, how do you access its getter?",
            "options": ["obj.temperature()", "obj.get_temperature()", "obj.temperature", "property.get(obj, 'temperature')"],
            "correctAnswer": "obj.temperature"
          },
          {
            "question": "It's a common convention to name the actual stored attribute with a leading underscore (e.g., `_price`). Why?",
            "options": ["It's a requirement for properties to work.", "It signifies to other developers that this attribute is intended for internal use.", "It makes the attribute truly private.", "It improves performance."],
            "correctAnswer": "It signifies to other developers that this attribute is intended for internal use."
          }
        ],
        "pacing": "fast"
      },
      {
        "id": "33",
        "title": "Advanced OOP: Magic Methods",
        "description": "Customize the behavior of your classes by implementing Python's special 'dunder' methods.",
        "content": [
          "Magic methods, also known as 'dunder' (double underscore) methods, are special methods you can define in your classes that start and end with double underscores (e.g., `__init__`, `__len__`). They are not meant to be called directly. Instead, Python calls them for you in response to specific operations.",
          "For example, when you use the `+` operator on two objects, Python calls the `__add__` method. When you call `len(my_object)`, Python calls `my_object.__len__()`. When you `print(my_object)`, Python calls `my_object.__str__()`.",
          "By implementing these methods, you can make your custom objects behave like built-in types. This allows you to integrate your objects more seamlessly into the Python language, making them more intuitive to use.",
          "Common magic methods include `__str__` for a user-friendly string representation, `__repr__` for an unambiguous developer-friendly representation, `__len__` for length, and comparison methods like `__eq__` (==), `__lt__` (<), etc."
        ],
        "codeExample": "class Vector:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def __repr__(self):\n        \"\"\"Unambiguous representation, for developers.\"\"\"\n        return f\"Vector({self.x}, {self.y})\"\n\n    def __str__(self):\n        \"\"\"User-friendly representation.\"\"\"\n        return f\"({self.x}, {self.y})\"\n\n    def __add__(self, other):\n        \"\"\"Defines behavior for the '+' operator.\"\"\"\n        return Vector(self.x + other.x, self.y + other.y)\n\nv1 = Vector(2, 3)\nv2 = Vector(3, 4)\n\n# __add__ is called\nv3 = v1 + v2\n\n# __str__ is called by print()\nprint(f\"{v1} + {v2} = {v3}\")\n\n# __repr__ is called when inspecting the object\nprint(repr(v3))",
        "quiz": [
          {
            "question": "What is another name for 'magic methods'?",
            "options": ["Private methods", "Dunder methods", "Special methods", "Both B and C"],
            "correctAnswer": "Both B and C"
          },
          {
            "question": "Which magic method is called when you use the `len()` function on an object?",
            "options": ["__length__", "__size__", "__len__", "__count__"],
            "correctAnswer": "__len__"
          },
          {
            "question": "What is the primary purpose of the `__str__` method?",
            "options": ["To provide a formal, unambiguous representation for developers.", "To define the object's length.", "To provide a readable, user-friendly string representation.", "To convert the object to a string for file storage."],
            "correctAnswer": "To provide a readable, user-friendly string representation."
          },
          {
            "question": "To overload the `==` operator for your custom class, which method should you implement?",
            "options": ["__equals__", "__is_equal__", "__eq__", "__compare__"],
            "correctAnswer": "__eq__"
          },
          {
            "question": "Are magic methods typically called directly (e.g., `my_object.__add__(other)`)?",
            "options": ["Yes, always", "No, Python calls them implicitly based on the operation being performed"],
            "correctAnswer": "No, Python calls them implicitly based on the operation being performed"
          }
        ],
        "pacing": "fast"
      },
      {
        "id": "34",
        "title": "Testing with `pytest`",
        "description": "Level up your testing skills with `pytest`, a powerful and popular testing framework.",
        "content": [
          "While `unittest` is built-in, many developers prefer `pytest` for its simpler syntax, powerful features, and extensive plugin ecosystem. `pytest` makes writing tests faster and more enjoyable.",
          "`pytest` uses plain `assert` statements instead of the `self.assertEqual()` style methods from `unittest`. This makes tests more concise and readable. `pytest` is smart enough to introspect the `assert` statement and provide detailed output on what failed.",
          "One of pytest's most powerful features is **fixtures**. A fixture is a function that provides a fixed baseline of data or a system state for your tests. You can reuse fixtures across multiple tests, making your test setup much cleaner and more maintainable.",
          "To get started, you just need to `pip install pytest` and then write test files (e.g., `test_something.py`) with test functions (e.g., `def test_addition():`). `pytest` will automatically discover and run your tests."
        ],
        "codeExample": "# You would need to run 'pip install pytest' first.\n# This code would be in a file like 'test_calculation.py'.\n\n# A function we want to test\ndef add(a, b):\n    return a + b\n\n# A simple pytest test function\ndef test_add_positive_numbers():\n    # pytest uses a plain assert statement\n    assert add(2, 3) == 5\n\ndef test_add_negative_numbers():\n    assert add(-1, -1) == -2\n\n# To run the tests, you would navigate to the directory in your terminal\n# and simply run the command: pytest\nprint(\"pytest simplifies test writing with plain assert statements.\")",
        "quiz": [
          {
            "question": "What does `pytest` use for assertions?",
            "options": ["`self.assertEqual()`", "`self.assertTrue()`", "The plain `assert` keyword", "`check.equals()`"],
            "correctAnswer": "The plain `assert` keyword"
          },
          {
            "question": "By default, `pytest` looks for test files with what naming pattern?",
            "options": ["`test_*.py` or `*_test.py`", "`check_*.py`", "`test.py`", "`*.test.py`"],
            "correctAnswer": "`test_*.py` or `*_test.py`"
          },
          {
            "question": "What is a `pytest` fixture used for?",
            "options": ["To time the test execution", "To provide a reusable setup/teardown for tests (e.g., data, connections)", "To format the test output", "To run tests in parallel"],
            "correctAnswer": "To provide a reusable setup/teardown for tests (e.g., data, connections)"
          },
          {
            "question": "Which command is typically used to run all tests in a project?",
            "options": ["`run-pytest`", "`python -m unittest`", "`pytest`", "`python test`"],
            "correctAnswer": "`pytest`"
          },
          {
            "question": "Compared to `unittest`, `pytest` generally leads to...",
            "options": ["More verbose test code", "Less readable test code", "More concise and readable test code", "Fewer features"],
            "correctAnswer": "More concise and readable test code"
          }
        ],
        "pacing": "medium"
      },
      {
        "id": "35",
        "title": "Working with CSV Files",
        "description": "Learn to read and write Comma-Separated Values (CSV) data, a common data exchange format.",
        "content": [
          "CSV (Comma-Separated Values) is a ubiquitous, simple text format for storing tabular data (like spreadsheets or database records). Each line in a CSV file represents a row, with values in that row separated by a comma.",
          "Python's standard library includes the `csv` module to make working with these files easy and robust. It correctly handles various edge cases, like values that contain commas or line breaks themselves.",
          "To read a CSV file, you typically use `csv.reader` which gives you an iterator that yields each row as a list of strings. For a more convenient approach, `csv.DictReader` treats each row as a dictionary, using the header row as keys.",
          "To write data, you use `csv.writer` and its `writerow` or `writerows` methods. Similarly, `csv.DictWriter` lets you write a list of dictionaries, which can be very convenient. You just need to make sure to open the file with `newline=''` to avoid extra blank rows in your output."
        ],
        "codeExample": "import csv\n\n# --- Writing to a CSV file ---\nheaders = ['name', 'department', 'birth_month']\ndata = [\n    {'name': 'John Smith', 'department': 'Accounting', 'birth_month': 'November'},\n    {'name': 'Erica Meyers', 'department': 'IT', 'birth_month': 'March'}\n]\n\nwith open('employees.csv', 'w', newline='') as f:\n    writer = csv.DictWriter(f, fieldnames=headers)\n    writer.writeheader()\n    writer.writerows(data)\n\nprint(\"employees.csv has been created.\")\n\n# --- Reading from a CSV file ---\nprint(\"\\nReading from employees.csv:\")\nwith open('employees.csv', 'r') as f:\n    reader = csv.DictReader(f)\n    for row in reader:\n        print(dict(row))",
        "quiz": [
          {
            "question": "What does CSV stand for?",
            "options": ["Computer System Values", "Comma-Separated Values", "Code Style Verification", "Common Shared Values"],
            "correctAnswer": "Comma-Separated Values"
          },
          {
            "question": "Which function from the `csv` module is used to read a CSV file row-by-row into dictionaries?",
            "options": ["csv.reader", "csv.read", "csv.DictReader", "csv.read_dict"],
            "correctAnswer": "csv.DictReader"
          },
          {
            "question": "Why is it important to open the file with `newline=''` when writing a CSV?",
            "options": ["To improve performance", "To prevent the `csv` module from adding extra blank rows", "To encrypt the file", "It is not important"],
            "correctAnswer": "To prevent the `csv` module from adding extra blank rows"
          },
          {
            "question": "The `csv.writer` object's `writerow` method takes what as an argument?",
            "options": ["A dictionary", "A single string", "An iterable (like a list or tuple)", "An integer"],
            "correctAnswer": "An iterable (like a list or tuple)"
          },
          {
            "question": "What does `csv.DictWriter.writeheader()` do?",
            "options": ["Writes the data rows to the file", "Writes the first row of the CSV file using the fieldnames provided", "Reads the header from the file", "Closes the file"],
            "correctAnswer": "Writes the first row of the CSV file using the fieldnames provided"
          }
        ],
        "pacing": "medium"
      },
      {
        "id": "36",
        "title": "Working with Dates and Times",
        "description": "Master the `datetime` module for handling dates, times, and time calculations in Python.",
        "content": [
          "Working with dates and times is a common task in programming. Python's `datetime` module, part of the standard library, provides powerful classes for manipulating dates and times.",
          "The main classes you'll work with are: `date` (for year, month, day), `time` (for hour, minute, second, microsecond), `datetime` (combines both date and time), and `timedelta` (for representing a duration or difference between two dates/times).",
          "You can get the current date and time using `datetime.now()`. You can perform arithmetic with date and time objects, for example, by adding a `timedelta` to a `datetime` to find a future date.",
          "A crucial part of working with dates is parsing them from strings and formatting them into strings. The `strptime()` (string parse time) method is used to convert a string into a `datetime` object, and `strftime()` (string format time) does the opposite. Both use special format codes (like `%Y` for a 4-digit year, `%m` for month, `%d` for day) to define the format."
        ],
        "codeExample": "from datetime import datetime, timedelta\n\n# Get the current time\nnow = datetime.now()\nprint(f\"Current datetime: {now}\")\n\n# Format the datetime into a readable string\nformatted_string = now.strftime(\"%A, %B %d, %Y %I:%M %p\")\nprint(f\"Formatted string: {formatted_string}\")\n\n# Calculate a future date\nthree_weeks_from_now = now + timedelta(weeks=3)\nprint(f\"Three weeks from now will be: {three_weeks_from_now.date()}\")\n\n# Parse a string into a datetime object\ndate_string = \"2023-01-20\"\ndate_object = datetime.strptime(date_string, \"%Y-%m-%d\")\nprint(f\"Parsed date object: {date_object}\")",
        "quiz": [
          {
            "question": "Which `datetime` class represents a duration of time?",
            "options": ["date", "time", "datetime", "timedelta"],
            "correctAnswer": "timedelta"
          },
          {
            "question": "Which method converts a `datetime` object into a formatted string?",
            "options": ["strftime()", "strptime()", "format()", "parse()"],
            "correctAnswer": "strftime()"
          },
          {
            "question": "Which method parses a string into a `datetime` object?",
            "options": ["strftime()", "strptime()", "format()", "parse()"],
            "correctAnswer": "strptime()"
          },
          {
            "question": "What does the format code `%Y` represent in `strftime`/`strptime`?",
            "options": ["Two-digit year", "The day of the year", "Four-digit year", "The abbreviated year"],
            "correctAnswer": "Four-digit year"
          },
          {
            "question": "How would you get the current local date and time?",
            "options": ["datetime.now()", "datetime.today()", "datetime.current()", "Both A and B can be used"],
            "correctAnswer": "datetime.now()"
          }
        ],
        "pacing": "medium"
      },
      {
        "id": "37",
        "title": "Packaging Your Python Project",
        "description": "Learn how to package your Python code so it can be distributed and installed by others using `pip`.",
        "content": [
          "So you've written a useful Python script or library. How do you share it with others so they can easily install and use it? The answer is packaging.",
          "Modern Python packaging revolves around the `pyproject.toml` file. This file is the new standard for configuring your project's build system and metadata (like the project name, version, author, and dependencies).",
          "The process generally involves: 1) Structuring your code in a standard layout (e.g., putting your source code in a `src` directory). 2) Creating a `pyproject.toml` file to define your project. 3) Using a build tool like `build` to create distribution packages (usually a 'wheel' file and a 'source distribution').",
          "Once you have these distribution files, you can upload them to the Python Package Index (PyPI), the official third-party software repository for Python. After that, anyone in the world can install your package by simply running `pip install your-package-name`."
        ],
        "codeExample": "# This is not Python code, but the content of a pyproject.toml file.\n\n# [build-system]\n# requires = [\"hatchling\"]\n# build-backend = \"hatchling.build\"\n# \n# [project]\n# name = \"my-awesome-package\"\n# version = \"0.0.1\"\n# authors = [\n#   { name=\"Your Name\", email=\"you@example.com\" },\n# ]\n# description = \"A small example package\"\n# requires-python = \">=3.8\"\n# classifiers = [\n#     \"Programming Language :: Python :: 3\",\n#     \"License :: OSI Approved :: MIT License\",\n#     \"Operating System :: OS Independent\",\n# ]\n\nprint(\"Packaging is configured through a 'pyproject.toml' file.\")\nprint(\"You would use command-line tools like 'pip install build' and 'python -m build' to create packages.\")",
        "quiz": [
          {
            "question": "What is the modern, standard configuration file for a Python package?",
            "options": ["`setup.py`", "`requirements.txt`", "`pyproject.toml`", "`package.json`"],
            "correctAnswer": "`pyproject.toml`"
          },
          {
            "question": "What is PyPI?",
            "options": ["The Python Programming Interface", "A Python code linter", "The official Python Package Index for third-party software", "A Python virtual environment manager"],
            "correctAnswer": "The official Python Package Index for third-party software"
          },
          {
            "question": "Which file format is the preferred, modern distribution format for Python packages?",
            "options": [".zip", ".tar.gz", "Wheel (.whl)", ".egg"],
            "correctAnswer": "Wheel (.whl)"
          },
          {
            "question": "What command would someone use to install your package from PyPI?",
            "options": ["`pip download your-package-name`", "`pip install your-package-name`", "`pypi install your-package-name`", "`python get your-package-name`"],
            "correctAnswer": "`pip install your-package-name`"
          },
          {
            "question": "What is the purpose of the `src` layout in a Python project?",
            "options": ["It's required by law.", "It clearly separates your source code from other project files like tests and documentation.", "It makes your code run faster.", "It's where you store images and other assets."],
            "correctAnswer": "It clearly separates your source code from other project files like tests and documentation."
          }
        ],
        "pacing": "fast"
      },
      {
        "id": "38",
        "title": "Iterators and Iterables Deep Dive",
        "description": "Gain a deeper understanding of Python's iteration protocol.",
        "content": [
          "You've used `for` loops extensively, but how do they actually work? The magic is in Python's iteration protocol, which involves two concepts: iterables and iterators.",
          "An **iterable** is any object that can be looped over. It's anything that can provide an iterator. Examples include lists, tuples, strings, and dictionaries. An object is iterable if it implements the `__iter__` magic method.",
          "An **iterator** is an object that represents a stream of data. It produces the next value in the stream when you call `next()` on it. An iterator must implement the `__next__` method. It also implements the `__iter__` method (which just returns itself), making all iterators also iterables.",
          "When you write `for item in my_list:`, Python first calls `iter(my_list)` to get an iterator. Then, in each loop iteration, it calls `next()` on that iterator to get the next item. When there are no more items, the iterator raises a `StopIteration` exception, which tells the `for` loop to terminate. Understanding this distinction is key to mastering advanced topics like generators."
        ],
        "codeExample": "my_list = [1, 2, 3]\n\n# Get an iterator from the iterable list\nmy_iterator = iter(my_list)\n\nprint(f\"Type of my_list: {type(my_list)}\")\nprint(f\"Type of my_iterator: {type(my_iterator)}\")\n\n# Manually call next() on the iterator\nprint(\"Calling next() manually:\")\nprint(next(my_iterator)) # Output: 1\nprint(next(my_iterator)) # Output: 2\nprint(next(my_iterator)) # Output: 3\n\n# This next call would raise StopIteration\ntry:\n    next(my_iterator)\nexcept StopIteration:\n    print(\"StopIteration was raised.\")",
        "quiz": [
          {
            "question": "What makes an object an 'iterable'?",
            "options": ["It has a `__next__` method", "It has a `__iter__` method", "It's a list", "It can be sliced"],
            "correctAnswer": "It has a `__iter__` method"
          },
          {
            "question": "What does the `iter()` built-in function do?",
            "options": ["It returns the next item in a sequence.", "It creates a list from a tuple.", "It calls an object's `__iter__` method to get an iterator.", "It checks if an object is an iterator."],
            "correctAnswer": "It calls an object's `__iter__` method to get an iterator."
          },
          {
            "question": "What exception is raised by an iterator when it has no more items?",
            "options": ["`EndOfStreamError`", "`StopIteration`", "`IterationError`", "`NoMoreItems`"],
            "correctAnswer": "`StopIteration`"
          },
          {
            "question": "Is a list an iterator?",
            "options": ["Yes", "No"],
            "correctAnswer": "No"
          },
          {
            "question": "Is an iterator an iterable?",
            "options": ["Yes", "No"],
            "correctAnswer": "Yes"
          }
        ],
        "pacing": "medium"
      },
      {
        "id": "39",
        "title": "Generator Expressions",
        "description": "Create memory-efficient iterators on the fly with a syntax similar to list comprehensions.",
        "content": [
          "You've learned about generator functions (using `yield`). Python also provides **generator expressions**, which are a high-performance, memory-efficient generalization of list comprehensions and generator functions.",
          "The syntax is almost identical to a list comprehension, but you use parentheses `()` instead of square brackets `[]`.",
          "For example, `my_list_comp = [x*x for x in range(10)]` creates a full list in memory. In contrast, `my_gen_exp = (x*x for x in range(10))` creates a generator object. It doesn't compute any of the values until you start iterating over it.",
          "This makes generator expressions perfect for when you are iterating over the results only once, especially with very large datasets. You get the benefit of lazy evaluation without having to write a full generator function."
        ],
        "codeExample": "import sys\n\n# List comprehension (creates a full list in memory)\nlist_comp = [i for i in range(1000)]\n\n# Generator expression (creates a generator object, very little memory used)\ngen_exp = (i for i in range(1000))\n\nprint(\"Memory usage:\")\nprint(f\"List Comprehension: {sys.getsizeof(list_comp)} bytes\")\nprint(f\"Generator Expression: {sys.getsizeof(gen_exp)} bytes\")\n\n# We can still iterate over the generator expression\nsum_of_squares = sum(x*x for x in range(10))\nprint(f\"\\nSum of squares from generator: {sum_of_squares}\")",
        "quiz": [
          {
            "question": "What is the syntax for a generator expression?",
            "options": ["`[x for x in iterable]`", "`{x for x in iterable}`", "`(x for x in iterable)`", "`lambda x: x for x in iterable`"],
            "correctAnswer": "`(x for x in iterable)`"
          },
          {
            "question": "What is the primary advantage of a generator expression over a list comprehension?",
            "options": ["They are faster for small lists", "They are easier to write", "They are more memory-efficient due to lazy evaluation", "They can be used as dictionary keys"],
            "correctAnswer": "They are more memory-efficient due to lazy evaluation"
          },
          {
            "question": "What does a generator expression return?",
            "options": ["A list", "A tuple", "A generator object", "A set"],
            "correctAnswer": "A generator object"
          },
          {
            "question": "If you need to iterate over the results multiple times, which should you choose?",
            "options": ["Generator expression", "List comprehension"],
            "correctAnswer": "List comprehension"
          },
          {
            "question": "Which of the following is a valid use case for a generator expression?",
            "options": ["`my_list = (x for x in range(5))`", "`sum((x for x in range(100)))`", "`my_dict = {(x, x*x) for x in range(5)}`", "`my_set = [x for x in range(5)]`"],
            "correctAnswer": "`sum((x for x in range(100)))`"
          }
        ],
        "pacing": "fast"
      },
      {
        "id": "40",
        "title": "Advanced Decorators",
        "description": "Explore decorators that accept arguments and preserve function metadata.",
        "content": [
          "Basic decorators are powerful, but we can make them more flexible. What if you want to pass arguments to the decorator itself? You can do this by adding another layer of function nesting. You create a function that takes the decorator arguments and returns the actual decorator.",
          "Another common issue with simple decorators is that they obscure the original function's metadata (like its name `__name__` and docstring `__doc__`). The function being called is actually the `wrapper` function, so introspection tools see the wrapper's metadata, not the original's.",
          "The solution is to use `functools.wraps`. This is a decorator that you apply to your `wrapper` function. It copies the metadata from the original function (`func`) to the `wrapper` function, making your decorators much more transparent and easier to debug.",
          "These advanced techniques allow you to build powerful, configurable, and robust decorators for a wide range of applications."
        ],
        "codeExample": "import functools\n\n# A decorator that accepts an argument\ndef repeat(num_times):\n    def decorator_repeat(func):\n        @functools.wraps(func) # Preserves metadata\n        def wrapper(*args, **kwargs):\n            for _ in range(num_times):\n                value = func(*args, **kwargs)\n            return value\n        return wrapper\n    return decorator_repeat\n\n# Using the decorator with an argument\n@repeat(num_times=3)\ndef greet(name):\n    \"\"\"Prints a friendly greeting.\"\"\"\n    print(f\"Hello, {name}!\")\n\ngreet(\"Alice\")\n\n# Check the preserved metadata\nprint(f\"\\nFunction name: {greet.__name__}\")\nprint(f\"Function docstring: {greet.__doc__}\")",
        "quiz": [
          {
            "question": "What is the purpose of `functools.wraps`?",
            "options": ["To time the execution of a function", "To copy metadata from the original function to the wrapper function", "To allow decorators to accept arguments", "To wrap the function in a class"],
            "correctAnswer": "To copy metadata from the original function to the wrapper function"
          },
          {
            "question": "How do you create a decorator that accepts its own arguments?",
            "options": ["By adding an extra layer of function nesting", "By using a class instead of a function", "It's not possible", "By using the `@` symbol twice"],
            "correctAnswer": "By adding an extra layer of function nesting"
          },
          {
            "question": "Without `functools.wraps`, what would `my_decorated_function.__name__` typically return?",
            "options": ["`my_decorated_function`", "`wrapper`", "`func`", "It would raise an error"],
            "correctAnswer": "`wrapper`"
          },
          {
            "question": "In a decorator's `wrapper` function, why is it good practice to use `*args` and `**kwargs`?",
            "options": ["It is a syntax requirement", "It makes the decorator generic, allowing it to work on any function regardless of its arguments", "It improves performance", "It is only for decorators that accept arguments"],
            "correctAnswer": "It makes the decorator generic, allowing it to work on any function regardless of its arguments"
          },
          {
            "question": "Where do you apply the `@functools.wraps(func)` decorator?",
            "options": ["On the outermost function", "On the function being decorated", "On the inner `wrapper` function", "At the end of the file"],
            "correctAnswer": "On the inner `wrapper` function"
          }
        ],
        "pacing": "fast"
      },
      {
        "id": "41",
        "title": "Partial Functions",
        "description": "Create new functions with pre-filled arguments from existing functions using `functools.partial`.",
        "content": [
          "The `functools` module provides another useful tool called `partial`. A partial function is a new function created by 'freezing' some of the arguments of an existing function.",
          "This is useful when you have a function that takes several arguments, but you frequently call it with the same values for some of those arguments. You can create a new, simpler function that already has those arguments filled in.",
          "For example, if you have a `power(base, exponent)` function, you could create a `square(base)` function by creating a partial where the `exponent` is always 2. Or a `cube(base)` function where the `exponent` is 3.",
          "This helps reduce code duplication and can make your code more readable by creating specialized versions of more generic functions."
        ],
        "codeExample": "from functools import partial\n\n# A generic function to raise a number to a power\ndef power(base, exponent):\n    return base ** exponent\n\n# Create a new function 'square' where the exponent is always 2\nsquare = partial(power, exponent=2)\n\n# Create a new function 'cube' where the exponent is always 3\ncube = partial(power, exponent=3)\n\n# Use the new, simpler functions\nprint(f\"3 squared is: {square(3)}\")\nprint(f\"3 cubed is: {cube(3)}\")\n\n# You can still use the original function\nprint(f\"10 to the power of 5 is: {power(10, 5)}\")",
        "quiz": [
          {
            "question": "What does `functools.partial` do?",
            "options": ["It makes a function run faster", "It creates a new function with some arguments of an existing function pre-filled", "It splits a function into two smaller functions", "It decorates a function"],
            "correctAnswer": "It creates a new function with some arguments of an existing function pre-filled"
          },
          {
            "question": "If you have `f = partial(my_func, 10)`, what happens when you call `f(20)`?",
            "options": ["It calls `my_func(20)`", "It calls `my_func(10, 20)`", "It calls `my_func(20, 10)`", "It raises an error"],
            "correctAnswer": "It calls `my_func(10, 20)`"
          },
          {
            "question": "Which of the following is a good use case for `partial`?",
            "options": ["To create a function that always raises an error", "When you want to reduce the number of arguments you repeatedly pass to a function", "To combine two functions into one", "To make a function accept `*args`"],
            "correctAnswer": "When you want to reduce the number of arguments you repeatedly pass to a function"
          },
          {
            "question": "Can `partial` be used to freeze both positional and keyword arguments?",
            "options": ["True", "False"],
            "correctAnswer": "True"
          },
          {
            "question": "Creating a partial function `p = partial(f, ...)` immediately calls the original function `f`.",
            "options": ["True", "False"],
            "correctAnswer": "False"
          }
        ],
        "pacing": "medium"
      },
      {
        "id": "42",
        "title": "Regular Expressions (Regex) Basics",
        "description": "Learn the basics of using regular expressions for powerful pattern matching in strings.",
        "content": [
          "Regular expressions (or 'regex') are a powerful mini-language used for finding and manipulating patterns within strings. While they can look intimidating, they are an essential tool for many text-processing tasks.",
          "Python's `re` module provides all the necessary functions for working with regex. The most common functions are `re.search()` (to find the first match for a pattern anywhere in a string), `re.match()` (to find a match only at the beginning of a string), `re.findall()` (to find all non-overlapping matches), and `re.sub()` (to substitute matches with a new string).",
          "Regex patterns are built using special metacharacters. For example, `.` matches any character, `*` matches the previous character zero or more times, `+` matches one or more times, `\\d` matches any digit, and `\\s` matches any whitespace character. Square brackets `[]` can be used to define a set of characters to match (e.g., `[aeiou]`).",
          "Learning regex is a skill that takes practice, but it's incredibly powerful for tasks like validating user input (e.g., checking if a string is a valid email address), parsing log files, and scraping data from text."
        ],
        "codeExample": "import re\n\ntext = \"The agent's phone number is 408-555-1234. Call soon!\"\n\n# Pattern to find a phone number (3 digits, hyphen, 3 digits, hyphen, 4 digits)\nphone_pattern = r'\\d{3}-\\d{3}-\\d{4}'\n\n# Search for the pattern in the text\nmatch = re.search(phone_pattern, text)\n\nif match:\n    found_number = match.group(0)\n    print(f\"Phone number found: {found_number}\")\nelse:\n    print(\"No phone number found.\")\n\n# Find all words that start with 'a' or 's'\nwords = \"A sample sentence showing some stuff.\"\nfound_words = re.findall(r'\\b[as]\\w*', words, re.IGNORECASE)\nprint(f\"Words found: {found_words}\")",
        "quiz": [
          {
            "question": "What is the purpose of the `re` module in Python?",
            "options": ["To read files", "To make network requests", "To work with regular expressions", "To manage resources"],
            "correctAnswer": "To work with regular expressions"
          },
          {
            "question": "Which `re` function finds all non-overlapping matches of a pattern in a string?",
            "options": ["`re.search()`", "`re.match()`", "`re.sub()`", "`re.findall()`"],
            "correctAnswer": "`re.findall()`"
          },
          {
            "question": "In a regex pattern, what does `\\d` typically match?",
            "options": ["Any character", "A whitespace character", "A digit character (0-9)", "A word character"],
            "correctAnswer": "A digit character (0-9)"
          },
          {
            "question": "What is the difference between `re.search()` and `re.match()`?",
            "options": ["There is no difference.", "`re.search()` finds a match anywhere, while `re.match()` only checks for a match at the beginning of the string.", "`re.match()` is faster.", "`re.search()` returns a string, `re.match()` returns an object."],
            "correctAnswer": "`re.search()` finds a match anywhere, while `re.match()` only checks for a match at the beginning of the string."
          },
          {
            "question": "What does the `+` quantifier mean in a regular expression?",
            "options": ["Match the preceding element one or more times.", "Match the preceding element zero or more times.", "Match the preceding element zero or one time.", "Match a literal plus sign."],
            "correctAnswer": "Match the preceding element one or more times."
          }
        ],
        "pacing": "medium"
      },
      {
        "id": "43",
        "title": "Logging",
        "description": "Go beyond `print()` statements and learn to use Python's powerful `logging` module for better application monitoring.",
        "content": [
          "While `print()` is great for simple debugging, it has limitations in larger applications. You can't easily turn it off, filter messages, or direct output to different places (like a file and the console). The `logging` module solves these problems.",
          "The `logging` module provides a flexible framework for emitting log messages from Python programs. It defines several levels of severity: `DEBUG`, `INFO`, `WARNING`, `ERROR`, and `CRITICAL`. This allows you to filter messages based on their importance.",
          "You can configure the logging system to control the format of your log messages (e.g., adding a timestamp or the file name) and where they go (the 'handler'). For example, you can have a `StreamHandler` to print to the console and a `FileHandler` to save logs to a file.",
          "Using logging from the start is a best practice for writing maintainable applications. It allows you to get valuable insight into what your application is doing in a development environment and, more importantly, in production."
        ],
        "codeExample": "import logging\n\n# Basic configuration to set the level and format\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(levelname)s - %(message)s'\n)\n\n# These messages will be logged because they are INFO or higher\nlogging.info(\"This is an informational message.\")\nlogging.warning(\"This is a warning message.\")\nlogging.error(\"This is an error message.\")\n\n# This message will NOT be logged because its level (DEBUG) is lower than the configured level (INFO)\nlogging.debug(\"This is a debug message.\")\n\n# You can also log variable data\nuser = 'Alice'\nlogging.info(f\"User {user} logged in successfully.\")",
        "quiz": [
          {
            "question": "What is a key advantage of the `logging` module over using `print()`?",
            "options": ["It's faster.", "It can log messages with different severity levels.", "It can only print to the console.", "It requires less code."],
            "correctAnswer": "It can log messages with different severity levels."
          },
          {
            "question": "Which of these logging levels is the highest (most severe)?",
            "options": ["DEBUG", "INFO", "WARNING", "CRITICAL"],
            "correctAnswer": "CRITICAL"
          },
          {
            "question": "If the logging level is set to `WARNING`, will a message logged with `logging.INFO()` be displayed?",
            "options": ["Yes", "No"],
            "correctAnswer": "No"
          },
          {
            "question": "What is a 'handler' in the context of the logging module?",
            "options": ["A function that processes log messages", "A severity level", "An object that determines the destination of log messages (e.g., console, file)", "The format of a log message"],
            "correctAnswer": "An object that determines the destination of log messages (e.g., console, file)"
          },
          {
            "question": "What function is used for simple, one-time configuration of the logging system?",
            "options": ["`logging.setup()`", "`logging.configure()`", "`logging.basicConfig()`", "`logging.init()`"],
            "correctAnswer": "`logging.basicConfig()`"
          }
        ],
        "pacing": "medium"
      },
      {
        "id": "44",
        "title": "Concurrency with `threading`",
        "description": "An introduction to concurrency and how to use threads for parallel tasks.",
        "content": [
          "**Concurrency** is the concept of having multiple tasks running in overlapping time periods. It's about dealing with lots of things at once. This is different from **parallelism**, which is about doing lots of things at once. Concurrency is the structure, parallelism is the execution.",
          "In Python, a common way to achieve concurrency is with **threads**. A thread is a separate flow of execution. The `threading` module in the standard library allows you to create and manage threads.",
          "Threading is most effective for **I/O-bound** tasks. These are tasks where the program spends most of its time waiting for an external resource, like a network response, a database query, or reading a file from a disk. While one thread is waiting, the Python interpreter can switch to another thread to do useful work.",
          "Due to Python's Global Interpreter Lock (GIL), threading is not effective for **CPU-bound** tasks (heavy mathematical calculations), as only one thread can execute Python bytecode at a time. For those tasks, the `multiprocessing` module is a better choice."
        ],
        "codeExample": "import threading\nimport time\n\ndef fetch_data(name, delay):\n    print(f\"Thread {name}: starting data fetch...\")\n    time.sleep(delay) # Simulate a network request\n    print(f\"Thread {name}: finished fetching.\")\n\n# Create two threads\nthread1 = threading.Thread(target=fetch_data, args=(\"API_1\", 2))\nthread2 = threading.Thread(target=fetch_data, args=(\"API_2\", 3))\n\nstart_time = time.time()\nprint(\"Main: Starting threads.\")\n# Start both threads\nthread1.start()\nthread2.start()\n\n# Wait for both threads to complete before moving on\nthread1.join()\nthread2.join()\nend_time = time.time()\n\nprint(f\"Main: Both threads are finished in {end_time - start_time:.2f} seconds.\")",
        "quiz": [
          {
            "question": "What is concurrency?",
            "options": ["Running code at the exact same time", "The ability to manage multiple tasks in overlapping time periods", "A way to write code faster", "A debugging technique"],
            "correctAnswer": "The ability to manage multiple tasks in overlapping time periods"
          },
          {
            "question": "Which module is used for threading in Python?",
            "options": ["multiprocessing", "asyncio", "threading", "concurrent"],
            "correctAnswer": "threading"
          },
          {
            "question": "What does `thread.start()` do?",
            "options": ["It runs the thread's target function immediately", "It prepares the thread to be run", "It schedules the thread to be run and starts its execution", "It stops the thread"],
            "correctAnswer": "It schedules the thread to be run and starts its execution"
          },
          {
            "question": "What is the purpose of `thread.join()`?",
            "options": ["To combine two threads into one", "To stop the thread", "To make the main program wait until the thread has finished its execution", "To start the thread"],
            "correctAnswer": "To make the main program wait until the thread has finished its execution"
          },
          {
            "question": "Threading is most effective for which type of tasks?",
            "options": ["CPU-bound tasks (heavy calculations)", "I/O-bound tasks (waiting for network/disk)", "All tasks equally", "Only for printing text"],
            "correctAnswer": "I/O-bound tasks (waiting for network/disk)"
          }
        ],
        "pacing": "fast"
      },
      {
        "id": "45",
        "title": "Asynchronous Programming with `asyncio`",
        "description": "Learn the modern approach to concurrency in Python using `async` and `await`.",
        "content": [
          "`asyncio` is a library to write single-threaded concurrent code using coroutines, multiplexing I/O access over an event loop, and running tasks concurrently. It's an alternative to threading and is particularly well-suited for high-level structured network code.",
          "The core keywords are `async` and `await`. You define an asynchronous function, or **coroutine**, with `async def`. This makes it possible to use the `await` keyword inside it. `await` passes function control back to the event loop, which can then schedule another task to run.",
          "This is a form of **cooperative multitasking**. Instead of the operating system deciding when to switch tasks (like in threading), your code explicitly says 'I am about to wait for something, you can run something else now' using `await`. This avoids many of the complexities and potential bugs associated with threading.",
          "`asyncio` is the foundation for many high-performance Python web frameworks (like FastAPI and Quart) and is a crucial skill for modern network programming in Python."
        ],
        "codeExample": "import asyncio\nimport time\n\nasync def say_after(delay, what):\n    await asyncio.sleep(delay)\n    print(what)\n\nasync def main():\n    print(f\"started at {time.strftime('%X')}\")\n\n    await say_after(1, 'hello')\n    await say_after(2, 'world')\n\n    print(f\"finished at {time.strftime('%X')}\")\n\n# To run an async function, you use asyncio.run()\n# Note: This won't run in the playground, but is the correct way to execute it.\n# asyncio.run(main())\n\nprint(\"asyncio is used for modern, high-performance network applications.\")",
        "quiz": [
          {
            "question": "What keyword is used to define a coroutine function?",
            "options": ["`def async`", "`function async`", "`async def`", "`coroutine`"],
            "correctAnswer": "`async def`"
          },
          {
            "question": "What does the `await` keyword do?",
            "options": ["It pauses the entire program.", "It passes control back to the event loop so another task can run.", "It creates a new thread.", "It makes a function run faster."],
            "correctAnswer": "It passes control back to the event loop so another task can run."
          },
          {
            "question": "`asyncio` is a form of...",
            "options": ["Preemptive multitasking", "Cooperative multitasking", "Parallel processing", "Multi-threading"],
            "correctAnswer": "Cooperative multitasking"
          },
          {
            "question": "`asyncio` is generally best suited for what kind of tasks?",
            "options": ["CPU-bound tasks", "I/O-bound network tasks", "Memory-intensive tasks", "All tasks equally"],
            "correctAnswer": "I/O-bound network tasks"
          },
          {
            "question": "How do you run a top-level async function `main()`?",
            "options": ["`main()`", "`run(main())`", "`asyncio.start(main)`", "`asyncio.run(main())`"],
            "correctAnswer": "`asyncio.run(main())`"
          }
        ],
        "pacing": "fast"
      }
    ]
  }
}
