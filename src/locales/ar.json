
{
  "theme": {
    "light": "فاتح",
    "dark": "داكن",
    "system": "النظام"
  },
  "home": {
    "hero": {
      "title": "Python Prep: من الصفر إلى الاحتراف.",
      "subtitle": "دليلك الشامل والمتكامل خطوة بخطوة لإتقان لغة بايثون. دروس منظمة، اختبارات تفاعلية، وملاحظات مدعومة بالذكاء الاصطناعي.",
      "cta": "ابدأ رحلتك التعليمية"
    },
    "why": {
      "title": "لماذا تعلم بايثون؟",
      "cards": {
        "beginner": {
          "title": "سهلة للمبتدئين",
          "text": "بناء جملة بايثون البسيط والنظيف يجعلها واحدة من أسهل لغات البرمجة للتعلم."
        },
        "versatile": {
          "title": "متعددة الاستخدامات",
          "text": "من تطوير الويب وعلوم البيانات إلى الذكاء الاصطناعي والأتمتة، يمكن لبايثون أن تفعل كل شيء."
        },
        "demand": {
          "title": "طلب مرتفع",
          "text": "مطورون بايثون مطلوبون بشدة في سوق العمل، مع رواتب تنافسية."
        }
      }
    },
    "learn": {
      "title": "ماذا ستتعلم",
      "more": "...وأكثر من ذلك بكثير!"
    },
    "finalCta": {
      "title": "هل أنت مستعد للبدء؟",
      "subtitle": "درسك الأول على بعد نقرة واحدة فقط. ابدأ رحلتك لتصبح خبيرًا في بايثون اليوم.",
      "cta": "ابدأ التعلم الآن"
    },
    "footer": {
      "rights": "Python Prep. جميع الحقوق محفوظة.",
      "designedBy": "تصميم <a href='https://www.linkedin.com/in/yehia-mohammed-1518a1222?utm_source=share&utm_campaign=share_via&utm_content=profile&utm_medium=android_app' target='_blank' rel='noopener noreferrer' class='text-primary hover:underline'>المهندس يحيى محمد</a>."
    }
  },
  "sidebar": {
    "loading": "جار التحميل",
    "yourProgress": "تقدمك",
    "complete": "مكتمل",
    "downloadCourse": "تحميل الدورة",
    "description": "الوصف",
    "content": "محتوى الدرس",
    "codeExample": "مثال الكود",
    "quiz": "اختبار",
    "levels": {
      "beginner": "مبتدئ",
      "intermediate": "متوسط",
      "advanced": "متقدم"
    }
  },
  "lesson": {
    "playground": {
      "title": "ملعب الأكواد",
      "description": "جرب المفاهيم من هذا الدرس. تم ملء مثال الكود مسبقًا من أجلك."
    },
    "quiz": {
      "title": "وقت الاختبار!",
      "description": "اختبر معلوماتك في هذا الدرس."
    }
  },
  "codeRunner": {
    "placeholder": "أدخل كود بايثون الخاص بك هنا",
    "run": "تشغيل الكود",
    "explain": "شرح الكود",
    "output": "الناتج",
    "running": "جاري تشغيل الكود",
    "explainingTitle": "الذكاء الاصطناعي يشرح...",
    "explainingDesc": "يقوم مدرسنا الذكي بتوليد شرح لك.",
    "explanationTitle": "شرح الكود بالذكاء الاصطناعي"
  },
  "quiz": {
    "incomplete": {
      "title": "اختبار غير مكتمل",
      "description": "يرجى الإجابة على جميع الأسئلة قبل الإرسال."
    },
    "submit": "إرسال الاختبار",
    "results": {
      "title": "اكتمل الاختبار!",
      "score": "لقد حصلت على {score}٪."
    },
    "feedback": {
      "analyzing": "جاري تحليل نتائجك...",
      "generating": "يقوم الذكاء الاصطناعي بتوليد ملاحظات مخصصة لك.",
      "title": "ملاحظات مخصصة من مدرس الذكاء الاصطناعي"
    },
    "tryAgain": "حاول مرة أخرى",
    "nextLesson": "الدرس التالي",
    "courseComplete": "تهانينا! لقد أكملت الدورة بنجاح!"
  },
  "curriculum": {
    "beginner": [
      {
        "id": "1",
        "title": "مقدمة إلى بايثون",
        "description": "تعلم أساسيات لغة بايثون ولماذا هي لغة شائعة للمبتدئين والخبراء على حد سواء.",
        "content": [
          "أهلاً بك في عالم بايثون! بايثون هي لغة برمجة عالية المستوى ومُفسَّرة. لنفصّل ذلك. 'عالية المستوى' تعني أنها مصممة لتكون سهلة القراءة والكتابة للبشر، باستخدام كلمات تشبه اللغة الإنجليزية. 'مُفسَّرة' تعني أن الكود يتم تشغيله سطراً بسطر بواسطة برنامج يسمى المفسّر، مما يجعل الاختبار وتصحيح الأخطاء أسرع. لا تحتاج إلى خطوة 'ترجمة' منفصلة.",
          "فلسفة بايثون الأساسية، التي أنشأها جيدو فان روسوم وصدرت لأول مرة في عام 1991، تدور حول قابلية قراءة الكود. إحدى الميزات الفريدة التي ستواجهها هي استخدامها للمسافات البيضاء (المسافة البادئة) لتحديد كتل الكود، مثل الحلقات أو الدوال. على عكس العديد من اللغات الأخرى التي تستخدم الأقواس المعقوفة `{}`, مظهر بايثون النظيف يجبرك على كتابة كود منظم جيدًا منذ البداية.",
          "تعد براعة بايثون سببًا رئيسيًا لشعبيتها. إنها لغة للأغراض العامة، مما يعني أنها ليست متخصصة في شيء واحد فقط. تستخدمها الشركات الكبرى لتطوير الويب (مثل انستغرام وسبوتيفاي)، وتحليل البيانات والتعلم الآلي، والحوسبة العلمية، والبرامج النصية للأتمتة لتسهيل حياتك، وأكثر من ذلك بكثير. ستمنحك هذه الدورة الأساس لاستكشاف أي من هذه المجالات المثيرة.",
          "لنبدأ بأول برنامج تقليدي: طباعة 'أهلاً بالعالم!'. في بايثون، هذا بسيط بشكل لا يصدق. تستخدم الدالة المضمنة `print()`، وتمرر النص الذي تريد عرضه داخل الأقواس وعلامات الاقتباس. جربها في ساحة اللعب أدناه!"
        ],
        "codeExample": "print(\"أهلاً بالعالم!\")",
        "quiz": [
          {
            "question": "من هو مبتكر لغة بايثون؟",
            "options": ["جيمس جوسلينج", "جيدو فان روسوم", "بيارن ستروستروب", "دينيس ريتشي"],
            "correctAnswer": "جيدو فان روسوم"
          },
          {
            "question": "ما هو التركيز الأساسي لفلسفة تصميم بايثون؟",
            "options": ["سرعة التنفيذ", "قابلية قراءة الكود", "إدارة الذاكرة", "بناء الجملة المعقد"],
            "correctAnswer": "قابلية قراءة الكود"
          },
          {
            "question": "ماذا يعني أن بايثون لغة 'مفسرة'؟",
            "options": ["يتم تحويل الكود إلى لغة الآلة قبل تشغيله", "يتم تشغيل الكود مباشرة سطرًا بسطر بواسطة برنامج آخر", "يجب كتابة الكود في محرر معين", "يمكن استخدام الكود فقط لتطوير الويب"],
            "correctAnswer": "يتم تشغيل الكود مباشرة سطرًا بسطر بواسطة برنامج آخر"
          },
          {
            "question": "أي من التالي ليس استخدامًا شائعًا لبايثون؟",
            "options": ["علوم البيانات", "تطوير الويب", "الذكاء الاصطناعي", "تنسيق صفحات الويب"],
            "correctAnswer": "تنسيق صفحات الويب"
          },
          {
            "question": "كيف تكتب تعليقًا من سطر واحد في بايثون؟",
            "options": ["// هذا تعليق", "/* هذا تعليق */", "# هذا تعليق", "<!-- هذا تعليق -->"],
            "correctAnswer": "# هذا تعليق"
          }
        ],
        "pacing": "medium"
      },
      {
        "id": "2",
        "title": "المتغيرات وأنواع البيانات",
        "description": "فهم كيفية تخزين وإدارة البيانات في بايثون باستخدام المتغيرات وأنواع البيانات المختلفة.",
        "content": [
          "فكر في المتغيرات على أنها حاويات مُعنونة يمكنك تخزين المعلومات فيها. في بايثون، تقوم بإنشاء متغير وإعطائه قيمة في خطوة واحدة باستخدام عامل الإسناد `=`. على سبيل المثال، `player_score = 100` ينشئ متغيرًا يسمى `player_score` ويضع الرقم 100 بداخله. بايثون لغة ديناميكية النوع، مما يعني أنك لست مضطرًا لإخبار بايثون بنوع البيانات الذي سيحتويه المتغير. فهي تكتشف ذلك تلقائيًا.",
          "تأتي بايثون مع العديد من أنواع البيانات الأساسية للتعامل مع أنواع مختلفة من المعلومات. الأكثر شيوعًا هي: **النصوص (`str`)** للنصوص، مثل `'أهلاً'` أو `\"بايثون\"`؛ **الأعداد الصحيحة (`int`)** للأرقام الكاملة، مثل `10` أو `-50`؛ **الأعداد العشرية (`float`)** للأرقام ذات الفاصلة العشرية، مثل `3.14` أو `-0.5`؛ و **القيم المنطقية (`bool`)** التي يمكن أن تكون فقط `True` أو `False`، وتستخدم للعمليات المنطقية.",
          "يمكنك إعادة تعيين قيم مختلفة للمتغيرات، وحتى أنواع مختلفة، في أي وقت. على سبيل المثال، يمكنك البدء بـ `my_variable = 10` ثم لاحقًا تقول `my_variable = 'الآن أنا نص'`. على الرغم من أن هذا ممكن، إلا أنه من الممارسات الجيدة عمومًا الحفاظ على تناسق نوع بيانات المتغير لتجنب الارتباك.",
          "إذا لم تكن متأكدًا في أي وقت من نوع البيانات الذي يحمله المتغير، يمكنك استخدام الدالة المضمنة `type()`. على سبيل المثال، `print(type(player_score))` سيطبع `<class 'int'>`، مما يخبرك بأنه عدد صحيح. هذه أداة مفيدة جدًا لتصحيح الأخطاء."
        ],
        "codeExample": "name = \"أليس\"      # نص (str)\nage = 30           # عدد صحيح (int)\nheight = 5.5       # عدد عشري (float)\nis_student = True   # قيمة منطقية (bool)\n\n# لنتحقق من نوع المتغير 'age'\nprint(f\"المتغير 'name' من النوع: {type(name)}\")\nprint(f\"المتغير 'age' من النوع: {type(age)}\")",
        "quiz": [
          {
            "question": "أي من الطرق التالية هي الطريقة الصحيحة لتعيين سلسلة نصية لمتغير؟",
            "options": ["string name = 'بوب'", "name = 'بوب'", "name := 'بوب'", "let name = 'بوب'"],
            "correctAnswer": "name = 'بوب'"
          },
          {
            "question": "ماذا ستعيد الدالة `type(10.5)`؟",
            "options": ["int", "string", "float", "double"],
            "correctAnswer": "float"
          },
          {
            "question": "ما هو نوع البيانات المنطقي (boolean)؟",
            "options": ["عدد صحيح", "سلسلة من الأحرف", "رقم به فاصلة عشرية", "قيمة تكون إما True أو False"],
            "correctAnswer": "قيمة تكون إما True أو False"
          },
          {
            "question": "إذا قمت بتشغيل `x = 5` ثم `x = 'hello'`، فما هو نوع بيانات `x`؟",
            "options": ["int", "str", "error", "bool"],
            "correctAnswer": "str"
          },
          {
            "question": "يمكن أن تبدأ أسماء المتغيرات في بايثون برقم.",
            "options": ["صحيح", "خطأ"],
            "correctAnswer": "خطأ"
          }
        ],
        "pacing": "medium"
      },
      {
        "id": "3",
        "title": "تدفق التحكم: If/Else",
        "description": "تعلم كيفية اتخاذ القرارات في الكود الخاص بك باستخدام العبارات الشرطية.",
        "content": [
          "غالبًا ما تحتاج البرامج إلى اتخاذ قرارات وتنفيذ أكواد مختلفة بناءً على شروط معينة. وهذا ما يسمى بتدفق التحكم. الطريقة الأساسية للتحكم في التدفق في بايثون هي باستخدام عبارات `if` و `elif` و `else`.",
          "تتحقق عبارة `if` مما إذا كان الشرط `True`. إذا كان كذلك، يتم تشغيل كتلة الكود المزاحة تحتها. على سبيل المثال: `if temperature > 30: print('إنه يوم حار!')`. الشرط `temperature > 30` هو تعبير يتم تقييمه إلى `True` أو `False`.",
          "ماذا لو كان الشرط الأول خاطئًا؟ يمكنك استخدام عبارة `elif` (اختصار لـ 'else if') للتحقق من شرط آخر. يمكنك الحصول على أي عدد تريده من عبارات `elif`. يقوم البرنامج بالتحقق منها بالترتيب ويقوم بتشغيل الكود لأول واحدة تكون `True`.",
          "أخيرًا، توفر عبارة `else` كتلة من الكود لتشغيلها إذا لم تكن أي من شروط `if` أو `elif` السابقة `True`. إنها بمثابة خيار افتراضي لأي حالة أخرى. عبارة `else` اختيارية."
        ],
        "codeExample": "age = 18\n\nif age < 13:\n    print(\"أنت طفل.\")\nelif age >= 13 and age < 20:\n    print(\"أنت مراهق.\")\nelse:\n    print(\"أنت بالغ.\")",
        "quiz": [
          {
            "question": "ما هي الكلمة المفتاحية المستخدمة لشروط 'else if' في بايثون؟",
            "options": ["elseif", "else if", "elif", "case"],
            "correctAnswer": "elif"
          },
          {
            "question": "في الكود المثال، ماذا سيتم طباعته إذا كان `age` يساوي 25؟",
            "options": ["أنت طفل.", "أنت مراهق.", "أنت بالغ.", "لن يتم طباعة أي شيء."],
            "correctAnswer": "أنت بالغ."
          },
          {
            "question": "أي من هذه المعاملات يتحقق من المساواة؟",
            "options": ["=", "==", "===", "!="],
            "correctAnswer": "=="
          },
          {
            "question": "هل يمكن أن توجد عبارة `if` بدون كتلة `else`؟",
            "options": ["نعم", "لا"],
            "correctAnswer": "نعم"
          },
          {
            "question": "ما هو الغرض من عبارة `else`؟",
            "options": ["للتحقق من شرط إضافي", "لتشغيل كود إذا كانت جميع الشروط السابقة خاطئة", "لإنهاء البرنامج", "لتعريف متغير"],
            "correctAnswer": "لتشغيل كود إذا كانت جميع الشروط السابقة خاطئة"
          }
        ],
        "pacing": "medium"
      },
      {
        "id": "4",
        "title": "الدوال",
        "description": "اكتشف كيفية كتابة كتل من التعليمات البرمجية القابلة لإعادة الاستخدام باستخدام الدوال.",
        "content": [
          "كلما أصبحت برامجك أكبر، ستجد نفسك تكتب نفس قطعة الكود مرارًا وتكرارًا. تسمح لك الدوال بتجميع كتلة من الكود، وإعطائها اسمًا، وإعادة استخدامها كلما احتجت إليها. يُعرف هذا المبدأ باسم DRY (لا تكرر نفسك).",
          "تقوم بتعريف دالة باستخدام الكلمة المفتاحية `def`، متبوعة باسم الدالة، وقوسين `()`، ونقطتين `:`. يجب أن يكون كل الكود التابع للدالة مزاحًا تحتها. على سبيل المثال: `def greet(): print('أهلاً!')`.",
          "تصبح الدوال أكثر قوة عندما تمرر إليها البيانات. تسمى المتغيرات داخل القوسين **parameters (معلمات)**. عند استدعاء الدالة، تسمى القيم التي تمررها **arguments (وسائط)**. على سبيل المثال، في `def greet(name):`، `name` هو معلمة.",
          "غالبًا ما تقوم الدالة بإجراء عملية حسابية وتحتاج إلى إرسال نتيجة مرة أخرى. يتم استخدام الكلمة المفتاحية `return` لهذا الغرض. عند تنفيذ عبارة `return`، تتوقف الدالة وترسل القيمة المحددة مرة أخرى إلى حيث تم استدعاؤها. يمكن للدالة إرجاع أي نوع بيانات: رقم، نص، قائمة، أو حتى دالة أخرى!"
        ],
        "codeExample": "# دالة تأخذ اسمًا وتعيد تحية\ndef greet_person(name):\n    return f\"أهلاً، {name}! مرحباً بك في بايثون.\"\n\n# استدعاء الدالة وتخزين النتيجة في متغير\ngreeting = greet_person(\"يحيى\")\nprint(greeting)\n\n# استدعاء آخر بوسيط مختلف\nprint(greet_person(\"طالب\"))",
        "quiz": [
          {
            "question": "ما هي الكلمة المفتاحية المستخدمة لتعريف دالة في بايثون؟",
            "options": ["function", "def", "fun", "define"],
            "correctAnswer": "def"
          },
          {
            "question": "ماذا تفعل الكلمة المفتاحية `return` في الدالة؟",
            "options": ["تطبع قيمة على وحدة التحكم", "توقف تنفيذ الدالة", "تمرر البيانات مرة أخرى خارج الدالة", "تحدد اسم الدالة"],
            "correctAnswer": "تمرر البيانات مرة أخرى خارج الدالة"
          },
          {
            "question": "في `def my_func(param1):`، ماذا يطلق على `param1`؟",
            "options": ["وسيط (Argument)", "متغير (Variable)", "معلمة (Parameter)", "قيمة مرتجعة (Return value)"],
            "correctAnswer": "معلمة (Parameter)"
          },
          {
            "question": "هل يمكن استدعاء دالة دون تعريفها أولاً؟",
            "options": ["نعم", "لا"],
            "correctAnswer": "لا"
          },
          {
            "question": "يجب أن تحتوي الدالة دائمًا على عبارة `return`.",
            "options": ["صحيح", "خطأ"],
            "correctAnswer": "خطأ"
          }
        ],
        "pacing": "medium"
      },
      {
        "id": "5",
        "title": "القوائم (Lists) والصفوف (Tuples)",
        "description": "تعرف على أنواع بيانات التسلسل في بايثون: القوائم (القابلة للتغيير) والصفوف (غير القابلة للتغيير).",
        "content": [
          "لتخزين مجموعة من العناصر، غالبًا ما تحتاج إلى نوع بيانات تسلسلي. التسلسل الأكثر شيوعًا في بايثون هو **القائمة (list)**. القائمة هي مجموعة مرتبة من العناصر، وهي **قابلة للتغيير (mutable)**، مما يعني أنه يمكنك تغيير محتوياتها بعد إنشائها. تُعرَّف القوائم باستخدام الأقواس المربعة `[]`، مع فصل العناصر بفاصلة.",
          "يمكنك الوصول إلى أي عنصر في القائمة باستخدام **فهرسه (index)** - وهو موضعه في القائمة. يبدأ الفهرس من 0. لذا، بالنسبة لـ `my_list = ['a', 'b', 'c']`، فإن `my_list[0]` هو `'a'`. يمكنك إضافة عناصر إلى النهاية باستخدام التابع `.append()`، وإزالة العناصر باستخدام `.remove()` (حسب القيمة) أو `.pop()` (حسب الفهرس).",
          "**الصف (tuple)** هو مجموعة مرتبة أخرى، تشبه القائمة، ولكن مع اختلاف جوهري واحد: إنه **غير قابل للتغيير (immutable)**. بمجرد إنشاء الصف، لا يمكنك إضافة أو إزالة أو تغيير عناصره. تُعرَّف الصفوف باستخدام الأقواس المستديرة `()`. قد تستخدم صفًا للبيانات التي لا ينبغي أن تتغير، مثل إحداثيات `(x, y)` لنقطة.",
          "لماذا نستخدم الصف إذا كان أقل مرونة؟ عدم قابليته للتغيير يجعله متوقعًا ويمكن أن يكون أكثر كفاءة في استخدام الذاكرة بشكل طفيف. كما يمكن استخدامه كمفاتيح في القاموس (وهو ما سنراه لاحقًا)، بينما لا يمكن استخدام القوائم."
        ],
        "codeExample": "# قائمة من الأرقام\nnumbers = [1, 2, 3, 5, 8]\nprint(f\"القائمة الأصلية: {numbers}\")\n\n# إضافة عنصر إلى القائمة\nnumbers.append(13)\nprint(f\"القائمة بعد الإضافة: {numbers}\")\n\n# الوصول إلى عنصر حسب الفهرس\nprint(f\"العنصر الثالث هو: {numbers[2]}\")\n\n# صف من النصوص\nweekdays = (\"الاثنين\", \"الثلاثاء\", \"الأربعاء\")\nprint(f\"أول يوم في الأسبوع هو: {weekdays[0]}\")",
        "quiz": [
          {
            "question": "ما الرمز المستخدم لإنشاء قائمة؟",
            "options": ["()", "{}", "[]", "<>"],
            "correctAnswer": "[]"
          },
          {
            "question": "ما هو الفرق الرئيسي بين القائمة والصف؟",
            "options": ["القوائم مرتبة والصفوف ليست كذلك", "القوائم يمكن أن تحتوي على أي نوع بيانات، والصفوف تحتوي فقط على أرقام", "القوائم قابلة للتغيير، والصفوف غير قابلة للتغيير", "القوائم تستخدم الفهارس، والصفوف لا تستخدمها"],
            "correctAnswer": "القوائم قابلة للتغيير، والصفوف غير قابلة للتغيير"
          },
          {
            "question": "كيف تضيف عنصرًا إلى نهاية قائمة تسمى `my_list`؟",
            "options": ["my_list.add('new')", "my_list.append('new')", "my_list.insert('new')", "my_list.push('new')"],
            "correctAnswer": "my_list.append('new')"
          },
          {
            "question": "ما هو فهرس العنصر الأول في قائمة أو صف؟",
            "options": ["1", "0", "-1", "A"],
            "correctAnswer": "0"
          },
          {
            "question": "إذا حاولت تغيير عنصر في صف، ماذا يحدث؟",
            "options": ["يتم تحديث العنصر", "يتم إنشاء صف جديد", "تحصل على خطأ من نوع TypeError", "يتم إزالة العنصر"],
            "correctAnswer": "تحصل على خطأ من نوع TypeError"
          }
        ],
        "pacing": "medium"
      },
      {
        "id": "6",
        "title": "القواميس (Dictionaries) والمجموعات (Sets)",
        "description": "استكشف القواميس لأزواج المفتاح-القيمة والمجموعات للعناصر الفريدة.",
        "content": [
          "**القاموس (dictionary)** هو مجموعة تخزن البيانات في أزواج **مفتاح-قيمة (key-value pairs)**. بدلاً من الوصول إلى العناصر عن طريق فهرس رقمي، يمكنك الوصول إليها باستخدام مفتاح فريد. تُعرَّف القواميس باستخدام الأقواس المعقوفة `{}`. على سبيل المثال: `student = {'name': 'Alice', 'id': 123}`. هنا، `'name'` و `'id'` هما المفاتيح.",
          "القواميس قابلة للتغيير، لذا يمكنك إضافة أزواج مفتاح-قيمة جديدة (مثل `student['grade'] = 'A'`)، وتعديل القيم الموجودة (مثل `student['id'] = 456`)، وإزالة الأزواج. وهي مفيدة بشكل لا يصدق لتخزين المعلومات المنظمة حيث يكون لكل قطعة بيانات تسمية واضحة.",
          "**المجموعة (set)** هي مجموعة *غير مرتبة* من العناصر *الفريدة*. هذا يعني أن المجموعة لا يمكن أن تحتوي على عناصر مكررة، ولا يمكنك الاعتماد على وجود العناصر في أي ترتيب معين. تُنشأ المجموعات أيضًا باستخدام الأقواس المعقوفة، لكنها لا تحتوي على أزواج مفتاح-قيمة: `unique_numbers = {1, 2, 3, 2, 1}` ستؤدي إلى `{1, 2, 3}`.",
          "المجموعات محسّنة للغاية للتحقق مما إذا كان العنصر موجودًا في المجموعة. كما أنها رائعة لعمليات المجموعات الرياضية مثل الاتحاد (`|`)، والتقاطع (`&`)، والفرق (`-`)."
        ],
        "codeExample": "# قاموس لتخزين معلومات السيارة\ncar_info = {\n  \"brand\": \"Ford\",\n  \"model\": \"Mustang\",\n  \"year\": 1964\n}\n\n# الوصول إلى قيمة باستخدام مفتاحها\nprint(f\"طراز السيارة هو: {car_info['model']}\")\n\n# إضافة زوج مفتاح-قيمة جديد\ncar_info[\"color\"] = \"red\"\nprint(f\"القاموس المحدث: {car_info}\")\n\n# مجموعة من الأرقام (تتم إزالة التكرارات تلقائيًا)\nnumbers_set = {1, 5, 10, 5, 2, 1}\nprint(f\"مجموعة الأرقام الفريدة هي: {numbers_set}\")",
        "quiz": [
          {
            "question": "كيف تصل إلى القيمة المرتبطة بالمفتاح 'brand' في `my_dict`؟",
            "options": ["my_dict(brand)", "my_dict['brand']", "my_dict.get_brand()", "my_dict[0]"],
            "correctAnswer": "my_dict['brand']"
          },
          {
            "question": "ما هي السمة الرئيسية للمجموعة؟",
            "options": ["تحافظ على العناصر بترتيب معين", "تخزن العناصر المكررة", "تخزن العناصر الفريدة فقط", "تستخدم أزواج مفتاح-قيمة"],
            "correctAnswer": "تخزن العناصر الفريدة فقط"
          },
          {
            "question": "أي بنية بيانات تستخدم أزواج مفتاح-قيمة؟",
            "options": ["List", "Tuple", "Set", "Dictionary"],
            "correctAnswer": "Dictionary"
          },
          {
            "question": "ماذا يحدث إذا حاولت إضافة عنصر مكرر إلى مجموعة؟",
            "options": ["تُصدر خطأ", "تضيف العنصر المكرر", "لا تفعل شيئًا وتبقى المجموعة دون تغيير", "تستبدل العنصر الأصلي"],
            "correctAnswer": "لا تفعل شيئًا وتبقى المجموعة دون تغيير"
          },
          {
            "question": "كيف تضيف زوج مفتاح-قيمة جديد، 'price': 5000، إلى قاموس يسمى `car`؟",
            "options": ["car.append('price', 5000)", "car.add({'price': 5000})", "car['price'] = 5000", "add key 'price' value 5000 to car"],
            "correctAnswer": "car['price'] = 5000"
          }
        ],
        "pacing": "medium"
      },
      {
        "id": "7",
        "title": "حلقات For",
        "description": "تعلم كيفية التكرار عبر التسلسلات مثل القوائم والصفوف والنصوص باستخدام حلقات for.",
        "content": [
          "تُستخدم **حلقة for** للتكرار، أو المرور على، عناصر تسلسل (مثل قائمة، صف، قاموس، مجموعة، أو نص). تسمح لك بتنفيذ كتلة من الكود لكل عنصر في التسلسل.",
          "الصيغة هي `for item in sequence:`. في كل تكرار للحلقة، سيحتوي المتغير `item` على العنصر الحالي من `sequence`، وسيتم تنفيذ كتلة الكود المزاحة.",
          "الشريك الشائع لحلقة `for` هو الدالة `range()`. تولد `range()` تسلسلاً من الأرقام، وهو أمر مفيد عندما تريد تكرار إجراء عددًا معينًا من المرات. على سبيل المثال، `range(5)` تولد الأرقام 0, 1, 2, 3, 4. بينما `range(2, 6)` ستولد 2, 3, 4, 5.",
          "يمكنك المرور عبر هياكل بيانات مختلفة بطرق مختلفة. بالنسبة للقائمة، تحصل على كل عنصر. بالنسبة للنص، تحصل على كل حرف. بالنسبة للقاموس، بشكل افتراضي، تحصل على كل مفتاح. يمكنك أيضًا استخدام توابع مثل `.values()` أو `.items()` للمرور عبر قيم القاموس أو أزواج المفتاح-القيمة على التوالي."
        ],
        "codeExample": "fruits = [\"تفاح\", \"موز\", \"كرز\"]\n\n# المرور على كل عنصر في القائمة وطباعته\nprint(\"فواكهي المفضلة هي:\")\nfor fruit in fruits:\n  print(f\"- {fruit}\")\n\n# استخدام range() لطباعة الأرقام\nprint(\"\\nالعد من 0 إلى 4:\")\nfor i in range(5):\n  print(i)",
        "quiz": [
          {
            "question": "ما هو استخدام حلقة for؟",
            "options": ["اتخاذ القرارات", "تعريف دالة", "التكرار عبر تسلسل", "تخزين البيانات"],
            "correctAnswer": "التكرار عبر تسلسل"
          },
          {
            "question": "في `for x in my_list:`، ما هو `x`؟",
            "options": ["فهرس العنصر الحالي", "القائمة نفسها", "العنصر الحالي في التسلسل", "عداد"],
            "correctAnswer": "العنصر الحالي في التسلسل"
          },
          {
            "question": "ما الأرقام التي ستنتجها `range(1, 4)`؟",
            "options": ["1, 2, 3, 4", "1, 2, 3", "0, 1, 2, 3", "1, 4"],
            "correctAnswer": "1, 2, 3"
          },
          {
            "question": "كيف يمكنك المرور على كل من المفاتيح والقيم في قاموس `my_dict`؟",
            "options": ["for k, v in my_dict.items():", "for k, v in my_dict:", "for item in my_dict.values():", "for item in my_dict.keys():"],
            "correctAnswer": "for k, v in my_dict.items():"
          },
          {
            "question": "ماذا سيكون ناتج `for char in \"مرحبا!\": print(char)`؟",
            "options": ["مرحبا!", "م\\nر\\nح\\nب\\nا\\n!", "خطأ", "['م', 'ر', 'ح', 'ب', 'ا', '!']"],
            "correctAnswer": "م\\nر\\nح\\nب\\nا\\n!"
          }
        ],
        "pacing": "medium"
      },
      {
        "id": "8",
        "title": "حلقات While",
        "description": "فهم كيفية تنفيذ كتلة من التعليمات البرمجية طالما كان الشرط صحيحًا.",
        "content": [
          "بينما تُستخدم حلقة `for` للتكرار عبر تسلسل، تُستخدم **حلقة while** لتكرار كتلة من الكود طالما ظل شرط معين `True`. ستستمر الحلقة في العمل حتى يصبح الشرط `False`.",
          "الصيغة هي `while condition:`. تتحقق الحلقة من `condition` *قبل* كل تكرار. إذا كان صحيحًا، يتم تنفيذ كتلة الكود المزاحة. إذا كان خاطئًا، تنتهي الحلقة.",
          "جزء حاسم من حلقة `while` هو التأكد من أن شيئًا ما داخل الحلقة سيجعل الشرط في النهاية خاطئًا. إذا لم يحدث ذلك، ستنشئ **حلقة لا نهائية**، والتي ستعمل إلى الأبد وتتسبب في تعطل برنامجك. عادةً، يتضمن هذا عدادًا يتم زيادته أو أي تغيير آخر في الحالة.",
          "يمكنك التحكم في تدفق حلقة `while` بعبارتين خاصتين. عبارة `break` ستنهي الحلقة فورًا، بغض النظر عن الشرط. عبارة `continue` ستتخطى بقية التكرار الحالي وتقفز مرة أخرى إلى الأعلى للتحقق من الشرط مرة أخرى."
        ],
        "codeExample": "count = 5\n\n# ستقوم هذه الحلقة بالعد التنازلي من 5 إلى 1\nwhile count > 0:\n  print(f\"العد التنازلي: {count}\")\n  count -= 1  # هذا أمر بالغ الأهمية لتجنب حلقة لا نهائية!\n\nprint(\"انطلاق!\")",
        "quiz": [
          {
            "question": "متى تتوقف حلقة while؟",
            "options": ["بعد عدد ثابت من التكرارات", "عندما يصبح شرطها خاطئًا", "عندما ينتهي البرنامج", "عند استدعاء دالة"],
            "correctAnswer": "عندما يصبح شرطها خاطئًا"
          },
          {
            "question": "ما هي 'الحلقة اللانهائية'؟",
            "options": ["حلقة تعمل ببطء شديد", "حلقة لا تنتهي أبدًا لأن شرطها يظل دائمًا صحيحًا", "حلقة تستخدم الكثير من الذاكرة", "حلقة بها خطأ"],
            "correctAnswer": "حلقة لا تنتهي أبدًا لأن شرطها يظل دائمًا صحيحًا"
          },
          {
            "question": "ماذا تفعل عبارة `break` داخل الحلقة؟",
            "options": ["تتخطى بقية التكرار الحالي", "تخرج من الحلقة تمامًا", "توقف الحلقة مؤقتًا", "تعيد تشغيل الحلقة"],
            "correctAnswer": "تخرج من الحلقة تمامًا"
          },
          {
            "question": "ماذا تفعل عبارة `continue` داخل الحلقة؟",
            "options": ["تتخطى بقية التكرار الحالي وتنتقل إلى التالي", "تخرج من الحلقة تمامًا", "تنهي البرنامج", "تستمر من بداية نفس التكرار"],
            "correctAnswer": "تتخطى بقية التكرار الحالي وتنتقل إلى التالي"
          },
          {
            "question": "ما الذي يجب أن تتذكره لتضمينه في حلقة while لتجنب حلقة لا نهائية؟",
            "options": ["عبارة طباعة", "عبارة break", "طريقة لتغيير المتغير في الشرط (مثل i += 1)", "عبارة return"],
            "correctAnswer": "طريقة لتغيير المتغير في الشرط (مثل i += 1)"
          }
        ],
        "pacing": "medium"
      },
      {
        "id": "9",
        "title": "معالجة النصوص",
        "description": "تعلم طرقًا مختلفة للعمل مع النصوص وتنسيقها.",
        "content": [
          "النصوص هي واحدة من أكثر أنواع البيانات التي ستتعامل معها شيوعًا. توفر بايثون مجموعة غنية من **التوابع (methods)** المضمنة لمعالجتها. شيء أساسي يجب تذكره هو أن النصوص **غير قابلة للتغيير (immutable)**. هذا يعني أن توابع النصوص لا تغير النص الأصلي أبدًا؛ بل تعيد دائمًا نصًا جديدًا معدلاً.",
          "بعض التوابع الأكثر فائدة هي: `.lower()` و `.upper()` لتغيير حالة الأحرف؛ `.strip()` لإزالة المسافات البيضاء من البداية والنهاية؛ `.replace(old, new)` لاستبدال أجزاء من النص؛ و `.split(separator)` لتقسيم النص إلى قائمة من النصوص الصغيرة.",
          "يعد دمج النصوص أيضًا مهمة شائعة. يمكنك استخدام عامل `+` لربطها، ولكن الطريقة الأحدث والأكثر قوة هي استخدام **f-strings** (formatted string literals). بوضع حرف `f` قبل علامة الاقتباس الافتتاحية، يمكنك تضمين المتغيرات والتعبيرات مباشرة داخل النص عن طريق تغليفها بأقواس معقوفة `{}`. غالبًا ما يكون هذا أكثر قابلية للقراءة وكفاءة.",
          "يمكنك أيضًا التحقق من وجود نص فرعي داخل نص أكبر باستخدام الكلمة المفتاحية `in`، والتي تعيد قيمة منطقية (`True` أو `False`). على سبيل المثال: `'py' in 'python'` سيتم تقييمه إلى `True`."
        ],
        "codeExample": "my_string = \"  أهلاً، عالم بايثون!  \"\n\n# استخدام strip() و upper()\ncleaned_upper = my_string.strip().upper()\nprint(f\"نص منظف وبأحرف كبيرة: {cleaned_upper}\")\n\n# استخدام replace()\nnew_string = cleaned_upper.replace(\"بايثون\", \"البرمجة\")\nprint(f\"النص المستبدل: {new_string}\")\n\n# تنسيق F-string\nlanguage = \"بايثون\"\nyear = 1991\nprint(f\"تم إصدار {language} لأول مرة في عام {year}.\")",
        "quiz": [
          {
            "question": "أي دالة تحول النص إلى أحرف كبيرة؟",
            "options": ["capitalize()", "upper()", "to_upper()", "uppercase()"],
            "correctAnswer": "upper()"
          },
          {
            "question": "ماذا تفعل دالة `strip()`؟",
            "options": ["تزيل جميع الأحرف من النص", "تزيل المسافات البيضاء البادئة واللاحقة", "تقسم النص إلى قائمة", "تستبدل حرفًا"],
            "correctAnswer": "تزيل المسافات البيضاء البادئة واللاحقة"
          },
          {
            "question": "إذا كان `s = 'abc'`، هل `s.upper()` يغير قيمة `s`؟",
            "options": ["نعم، s تصبح 'ABC'", "لا، تعيد نصًا جديدًا 'ABC' ولكن s تظل 'abc'"],
            "correctAnswer": "لا، تعيد نصًا جديدًا 'ABC' ولكن s تظل 'abc'"
          },
          {
            "question": "كيف تبدأ f-string؟",
            "options": ["بحرف 'f' قبل علامة الاقتباس الافتتاحية", "بكلمة 'fmt' قبل علامة الاقتباس الافتتاحية", "بعلامة '%' داخل النص", "بـ .format() في النهاية"],
            "correctAnswer": "بحرف 'f' قبل علامة الاقتباس الافتتاحية"
          },
          {
            "question": "ماذا تعيد `\"a-b-c\".split('-')`؟",
            "options": ["['a', 'b', 'c']", "('a', 'b', 'c')", "\"abc\"", "\"a b c\""],
            "correctAnswer": "['a', 'b', 'c']"
          }
        ],
        "pacing": "medium"
      },
      {
        "id": "10",
        "title": "التعامل مع الملفات",
        "description": "تعلم كيفية القراءة من الملفات والكتابة إليها على جهاز الكمبيوتر الخاص بك.",
        "content": [
          "من المتطلبات الشائعة للبرامج قراءة البيانات من الملفات أو كتابة البيانات إليها للتخزين الدائم. تجعل بايثون هذه العملية مباشرة. الدالة الرئيسية لهذا هي `open()`.",
          "تأخذ الدالة `open()` وسيطين رئيسيين: مسار الملف و **الوضع (mode)**. الوضع هو نص يحدد كيفية تفاعلك مع الملف. الأوضاع الأكثر شيوعًا هي: `'r'` للقراءة (افتراضي)، `'w'` للكتابة (سيكتب فوق الملف إذا كان موجودًا)، و `'a'` للإلحاق (يضيف إلى نهاية الملف).",
          "تعتبر من أفضل الممارسات استخدام عبارة `with` عند التعامل مع الملفات. صيغة `with open('filename', 'r') as f:` تنشئ سياقًا يكون فيه الملف مفتوحًا. الميزة الرئيسية هي أن بايثون ستغلق الملف تلقائيًا نيابة عنك بمجرد الخروج من الكتلة المزاحة، حتى لو حدثت أخطاء.",
          "بمجرد فتح الملف، يمكنك استخدام توابع مثل `.read()` للحصول على المحتوى بالكامل كنص واحد، أو `.readline()` للحصول على سطر واحد في كل مرة، أو `.readlines()` للحصول على جميع الأسطر كقائمة من النصوص. للكتابة، تستخدم التابع `.write()`."
        ],
        "codeExample": "# سيقوم هذا الكود بإنشاء ملف جديد يسمى 'demo.txt'\n# الوضع 'w' يعني أننا نكتب فيه.\nwith open(\"demo.txt\", \"w\", encoding='utf-8') as f:\n    f.write(\"هذا هو السطر الأول.\\n\")\n    f.write(\"هذا هو السطر الثاني.\\n\")\n\nprint(\"تم إنشاء 'demo.txt'.\")\n\n# الآن، لنقرأ المحتوى مرة أخرى من الملف.\n# الوضع 'r' يعني أننا نقرأ.\nwith open(\"demo.txt\", \"r\", encoding='utf-8') as f:\n    content = f.read()\n    print(\"\\nمحتوى 'demo.txt':\")\n    print(content)",
        "quiz": [
          {
            "question": "ما هو الوضع لفتح ملف للكتابة، والذي سيكتب فوق المحتوى الموجود؟",
            "options": ["'r'", "'x'", "'w'", "'a'"],
            "correctAnswer": "'w'"
          },
          {
            "question": "لماذا يوصى باستخدام بناء `with open(...)`؟",
            "options": ["يعمل بشكل أسرع", "يغلق الملف تلقائيًا", "يمكنه فتح أي نوع من الملفات", "يشفر الملف"],
            "correctAnswer": "يغلق الملف تلقائيًا"
          },
          {
            "question": "ماذا يفعل فتح ملف في وضع الإلحاق (`'a'`)؟",
            "options": ["يحذف الملف", "يقرأ الملف", "يكتب فوق محتوى الملف", "يضيف محتوى جديدًا إلى نهاية الملف"],
            "correctAnswer": "يضيف محتوى جديدًا إلى نهاية الملف"
          },
          {
            "question": "أي دالة تقرأ محتوى ملف بالكامل في سلسلة نصية واحدة؟",
            "options": ["read()", "readline()", "readlines()", "get_content()"],
            "correctAnswer": "read()"
          },
          {
            "question": "إذا فتحت ملفًا موجودًا في وضع الكتابة (`'w'`)، فماذا يحدث لمحتواه الأصلي؟",
            "options": ["يتم إضافة المحتوى الجديد إلى النهاية", "يحدث خطأ", "يتم مسح المحتوى الأصلي", "يتم نقل المحتوى الأصلي إلى ملف نسخ احتياطي"],
            "correctAnswer": "يتم مسح المحتوى الأصلي"
          }
        ],
        "pacing": "medium"
      },
      {
        "id": "11",
        "title": "معالجة الاستثناءات",
        "description": "تعلم كيفية التعامل مع الأخطاء بأمان باستخدام كتل try...except.",
        "content": [
          "تسمى الأخطاء التي تحدث أثناء تنفيذ البرنامج **استثناءات (exceptions)**. إذا لم يتعامل برنامجك مع استثناء، فسوف يتعطل ويعرض رسالة خطأ. يتوقع المبرمجون الجيدون الأخطاء المحتملة ويكتبون كودًا للتعامل معها بأمان.",
          "آلية بايثون لمعالجة الأخطاء هي كتلة `try...except`. تضع الكود الذي قد يسبب خطأ داخل كتلة `try`. إذا حدث خطأ، يتوقف الكود داخل كتلة `try` عن التنفيذ، وتبحث بايثون عن كتلة `except` مطابقة للتعامل مع هذا النوع المحدد من الخطأ.",
          "يمكن أن يكون لديك كتل `except` متعددة للتعامل مع أنواع مختلفة من الاستثناءات، مثل `ZeroDivisionError` للقسمة على صفر أو `FileNotFoundError` عندما لا يكون الملف موجودًا. يمكنك أيضًا الحصول على كتلة `except` عامة تلتقط أي استثناء.",
          "اختياريًا، يمكنك تضمين كتلة `finally`. سيتم تشغيل الكود الموجود داخل `finally` بغض النظر عن أي شيء - سواء حدث استثناء أم لا. هذا مفيد لإجراءات التنظيف، مثل إغلاق ملف أو اتصال شبكة."
        ],
        "codeExample": "numerator = 10\ndenominator = 0\n\ntry:\n  # هذا السطر سيسبب خطأ ZeroDivisionError\n  result = numerator / denominator\n  print(result)\nexcept ZeroDivisionError:\n  # تعمل هذه الكتلة لأن الخطأ المحدد قد حدث\n  print(\"خطأ: لا يمكنك القسمة على صفر!\")\nfinally:\n  # ستعمل هذه الكتلة بغض النظر عن أي شيء\n  print(\"انتهت محاولة الحساب.\")",
        "quiz": [
          {
            "question": "أي كتلة تحتوي على الكود الذي قد يسبب استثناءً؟",
            "options": ["except", "finally", "try", "if"],
            "correctAnswer": "try"
          },
          {
            "question": "ما هو الغرض من كتلة `finally`؟",
            "options": ["لمعالجة الخطأ", "للتسبب في خطأ", "لتنفيذ كود سواء حدث خطأ أم لا", "للإبلاغ عن الخطأ للمستخدم"],
            "correctAnswer": "لتنفيذ كود سواء حدث خطأ أم لا"
          },
          {
            "question": "ما نوع الخطأ الذي تثيره القسمة على صفر؟",
            "options": ["TypeError", "ValueError", "ZeroDivisionError", "SyntaxError"],
            "correctAnswer": "ZeroDivisionError"
          },
          {
            "question": "هل يمكنك الحصول على كتل `except` متعددة لكتلة `try` واحدة؟",
            "options": ["لا، يسمح بواحدة فقط", "نعم، للتعامل مع أنواع مختلفة من الاستثناءات"],
            "correctAnswer": "نعم، للتعامل مع أنواع مختلفة من الاستثناءات"
          },
          {
            "question": "ماذا يحدث إذا حدث استثناء ولم تكن هناك كتلة `except` للتعامل معه؟",
            "options": ["يستمر البرنامج كالمعتاد", "يتعطل البرنامج ويعرض رسالة خطأ", "يتجاهل البرنامج الخطأ بصمت", "يسأل البرنامج المستخدم ماذا يفعل"],
            "correctAnswer": "يتعطل البرنامج ويعرض رسالة خطأ"
          }
        ],
        "pacing": "medium"
      },
      {
        "id": "12",
        "title": "مقدمة في البرمجة الشيئية (OOP)",
        "description": "فهم المفاهيم الأساسية للبرمجة الشيئية (OOP).",
        "content": [
          "البرمجة الشيئية (OOP) هي طريقة للتفكير في الكود الخاص بك وهيكلته. بدلاً من سلسلة من الدوال، تقوم بتنظيم برنامجك حول **الكائنات (objects)**. الكائن هو وحدة قائمة بذاتها تجمع بين البيانات (تسمى **attributes أو سمات**) والدوال التي تعمل على تلك البيانات (تسمى **methods أو توابع**).",
          "**الفئة (Class)** هي المخطط أو القالب لإنشاء الكائنات. على سبيل المثال، يمكن أن يكون لديك فئة `Car` تحدد ما يمتلكه كل السيارات (سمات مثل `color`، `brand`) وما يمكنها القيام به (توابع مثل `start_engine()`، `drive()`). السيارة الفعلية، مثل سيارة فورد حمراء معينة، ستكون **كائنًا (object)** (أو **instance أو نسخة**) تم إنشاؤه من فئة `Car` تلك.",
          "هناك أربعة مبادئ رئيسية للبرمجة الشيئية: **التغليف (Encapsulation)** (تجميع البيانات والتوابع معًا)، **التجريد (Abstraction)** (إخفاء تفاصيل التنفيذ المعقدة وإظهار الميزات الضرورية فقط)، **الوراثة (Inheritance)** (السماح لفئة جديدة بتبني خصائص وتوابع فئة موجودة)، و**تعدد الأشكال (Polymorphism)** (السماح بمعاملة كائنات من فئات مختلفة ككائنات من فئة رئيسية مشتركة).",
          "سوف نستكشف هذه المفاهيم بالتفصيل في الدروس القادمة. في الوقت الحالي، فقط افهم أن البرمجة الشيئية تساعد في إنشاء كود معياري وقابل لإعادة الاستخدام ومنظم جيدًا، خاصة للتطبيقات الكبيرة والمعقدة."
        ],
        "codeExample": "# هذا مجرد مثال مفاهيمي. سنقوم بتعريف فئة في الدرس التالي.\n\n# هذا هو 'المخطط' لسيارة.\nclass Car:\n  # السمات (البيانات) والتوابع (الكود) ستوضع هنا.\n  # على سبيل المثال: اللون، العلامة التجارية، start_engine()، drive()\n  pass\n\n# هنا ننشئ 'كائنين' (نسختين) متميزتين من فئة السيارة.\nmy_car = Car()\nyour_car = Car()\n\nprint(\"لقد أنشأنا كائنين من فئة السيارة من مخطط الفئة.\")",
        "quiz": [
          {
            "question": "ما هي 'الفئة' (Class) في البرمجة الشيئية؟",
            "options": ["جزء من البيانات", "دالة", "مخطط لإنشاء الكائنات", "كائن بحد ذاته"],
            "correctAnswer": "مخطط لإنشاء الكائنات"
          },
          {
            "question": "ما هو 'الكائن' (Object) في البرمجة الشيئية؟",
            "options": ["نوع من المتغيرات", "نسخة من فئة", "نموذج برمجي", "ملف"],
            "correctAnswer": "نسخة من فئة"
          },
          {
            "question": "أي من التالي ليس مفهومًا أساسيًا في البرمجة الشيئية؟",
            "options": ["الوراثة", "تعدد الأشكال", "التغليف", "التكرار"],
            "correctAnswer": "التكرار"
          },
          {
            "question": "يُطلق على مفهوم تجميع البيانات والدوال التي تعمل على تلك البيانات داخل وحدة واحدة ...؟",
            "options": ["الوراثة", "التجريد", "التغليف", "تعدد الأشكال"],
            "correctAnswer": "التغليف"
          },
          {
            "question": "تُعرف قدرة الكائن على اتخاذ أشكال عديدة بـ ...؟",
            "options": ["الوراثة", "تعدد الأشكال", "التغليف", "التجريد"],
            "correctAnswer": "تعدد الأشكال"
          }
        ],
        "pacing": "medium"
      },
      {
        "id": "13",
        "title": "الفئات والكائنات",
        "description": "تعلم كيفية تعريف الفئات الخاصة بك وإنشاء الكائنات في بايثون.",
        "content": [
          "لتعريف فئة (المخطط)، تستخدم الكلمة المفتاحية `class` متبوعة باسم الفئة (حسب العرف، بـ `CamelCase`). كل شيء مزاح تحت هذا السطر ينتمي إلى الفئة.",
          "تحتوي كل فئة تقريبًا على تابع خاص يسمى `__init__()`. هذا التابع هو **المُنشئ (constructor)**؛ يتم استدعاؤه تلقائيًا كلما أنشأت كائنًا جديدًا من الفئة. وظيفته الأساسية هي تهيئة سمات الكائن.",
          "يجب أن تكون المعلمة الأولى لأي تابع داخل فئة هي `self`. `self` هو متغير خاص يشير إلى نسخة الكائن نفسه. يسمح لك بالوصول إلى سمات وتوابع ذلك الكائن المحدد. عند استدعاء تابع مثل `my_dog.bark()`، تمرر بايثون تلقائيًا `my_dog` كوسيط `self`.",
          "تسمى الدوال المعرفة داخل فئة **توابع (methods)**. إنها تحدد سلوكيات الكائن. السمات هي متغيرات تنتمي إلى الكائن وتخزن بياناته."
        ],
        "codeExample": "class Dog:\n  # التابع المُنشئ\n  def __init__(self, name, age):\n    # هذه سمات النسخة\n    self.name = name\n    self.age = age\n\n  # هذا تابع نسخة\n  def bark(self):\n    return f\"{self.name} يقول نباح!\"\n\n# إنشاء نسخة (كائن) من فئة الكلب\nmy_dog = Dog(\"فيدو\", 5)\n\n# الوصول إلى السمات واستدعاء التوابع باستخدام التدوين النقطي\nprint(f\"اسم كلبي هو {my_dog.name}.\")\nprint(f\"عمره {my_dog.age} سنوات.\")\nprint(my_dog.bark())",
        "quiz": [
          {
            "question": "ما هو اسم دالة المُنشئ في فئة بايثون؟",
            "options": ["__main__", "__construct__", "__init__", "__setup__"],
            "correctAnswer": "__init__"
          },
          {
            "question": "إلى ماذا يشير المعلم `self`؟",
            "options": ["الفئة نفسها", "النسخة الحالية من الفئة", "متغير عام", "الفئة الأصل"],
            "correctAnswer": "النسخة الحالية من الفئة"
          },
          {
            "question": "كيف تنشئ نسخة من فئة تسمى `Cat`؟",
            "options": ["my_cat = Cat", "my_cat = new Cat()", "my_cat = Cat()", "create Cat() as my_cat"],
            "correctAnswer": "my_cat = Cat()"
          },
          {
            "question": "تسمى المتغيرات التي تنتمي إلى نسخة...",
            "options": ["سمات الفئة", "سمات عامة", "سمات النسخة", "سمات ثابتة"],
            "correctAnswer": "سمات النسخة"
          },
          {
            "question": "تسمى الدوال المعرفة داخل فئة...",
            "options": ["إجراءات", "توابع (Methods)", "تعاريف", "لامدا"],
            "correctAnswer": "توابع (Methods)"
          }
        ],
        "pacing": "medium"
      },
      {
        "id": "14",
        "title": "الوراثة وتعدد الأشكال",
        "description": "تعلم كيفية إنشاء فئات جديدة من فئات موجودة وكيف يمكن للكائنات مشاركة السلوكيات.",
        "content": [
          "**الوراثة (Inheritance)** هي ميزة قوية في البرمجة الشيئية تسمح لك بإنشاء فئة جديدة ترث السمات والتوابع من فئة موجودة. تسمى الفئة الجديدة **الفئة الفرعية (child class)** (أو الفئة المشتقة)، والفئة التي ترث منها تسمى **الفئة الأصل (parent class)** (أو الفئة الأساسية). هذا يعزز إعادة استخدام الكود.",
          "تقوم بتعريف فئة فرعية عن طريق وضع اسم الفئة الأصل بين قوسين بعد اسم الفئة الفرعية: `class ChildClass(ParentClass):`.",
          "يمكن للفئة الفرعية **تجاوز (override)** تابع من أصلها. هذا يعني توفير تنفيذ جديد لتابع معرف بالفعل في الأصل. هذا مفيد لتخصيص السلوك، كما هو موضح في المثال حيث لدى `Cat` و `Dog` توابع `speak` مختلفة.",
          "**تعدد الأشكال (Polymorphism)** يعني حرفيًا 'أشكال متعددة'. في البرمجة، يشير إلى القدرة على استخدام واجهة مشتركة لأنواع مختلفة من الكائنات. نظرًا لأن كل من `Cat` و `Dog` يرثان من `Animal`، يمكننا معاملتهما ككائنات `Animal`. يمكن أن يكون لدينا دالة تأخذ أي كائن `Animal` وتستدعي تابعه `.speak()`، وسيعمل بشكل صحيح لكل من القطط والكلاب، مما ينتج عنه نتائج مختلفة. هذا يجعل الكود أكثر مرونة وقابلية للتوسيع."
        ],
        "codeExample": "# الفئة الأصل (الفئة الأساسية)\nclass Animal:\n  def __init__(self, name):\n    self.name = name\n  \n  def speak(self):\n    return f\"{self.name} يصدر صوتًا.\"\n\n# الفئة الفرعية (الفئة المشتقة)\nclass Dog(Animal):\n  # تجاوز تابع speak\n  def speak(self):\n    return f\"{self.name} ينبح.\"\n\n# فئة فرعية أخرى\nclass Cat(Animal):\n  # تجاوز تابع speak\n  def speak(self):\n    return f\"{self.name} يموء.\"\n\nmy_dog = Dog(\"بادي\")\nmy_cat = Cat(\"ويسكرز\")\n\nprint(my_dog.speak()) # يستدعي نسخة الكلب\nprint(my_cat.speak()) # يستدعي نسخة القط",
        "quiz": [
          {
            "question": "ما هي الفائدة الأساسية للوراثة؟",
            "options": ["كود أسرع", "إعادة استخدام الكود", "بناء جملة أبسط", "إدارة ذاكرة أفضل"],
            "correctAnswer": "إعادة استخدام الكود"
          },
          {
            "question": "كيف تشير إلى أن فئة `Child` ترث من `Parent`؟",
            "options": ["class Child(Parent):", "class Child inherits Parent:", "class Child extends Parent:", "class Child < Parent:"],
            "correctAnswer": "class Child(Parent):"
          },
          {
            "question": "عندما توفر فئة فرعية تنفيذها الخاص لدالة معرفة بالفعل في فئتها الأصل، يطلق على ذلك...؟",
            "options": ["تحميل زائد للدالة", "تجاوز الدالة", "إخفاء الدالة", "نسخ الدالة"],
            "correctAnswer": "تجاوز الدالة"
          },
          {
            "question": "المفهوم الموضح بـ `my_dog.speak()` و `my_cat.speak()` اللذين يعيدان نتائج مختلفة لتوابع بنفس الاسم هو...؟",
            "options": ["الوراثة", "التغليف", "تعدد الأشكال", "التجريد"],
            "correctAnswer": "تعدد الأشكال"
          },
          {
            "question": "تسمى الفئة التي يتم الوراثة منها...",
            "options": ["فئة فرعية", "فئة مشتقة", "فئة فرعية (Subclass)", "فئة أصل (أو فئة أساسية)"],
            "correctAnswer": "فئة أصل (أو فئة أساسية)"
          }
        ],
        "pacing": "fast"
      },
      {
        "id": "15",
        "title": "الوحدات النمطية والحزم",
        "description": "تعلم كيفية تنظيم الكود الخاص بك في وحدات نمطية وحزم.",
        "content": [
          "مع نمو مشاريعك، يصبح وضع كل الكود في ملف واحد فوضويًا وغير قابل للإدارة. حل بايثون هو **الوحدات النمطية (modules)**. الوحدة النمطية هي ببساطة ملف بايثون (بامتداد `.py`) يحتوي على دوال وفئات ومتغيرات. يمكنك بعد ذلك **استيراد (import)** تلك الوحدة النمطية إلى ملف آخر لاستخدام محتوياتها.",
          "يمكنك استيراد وحدة نمطية بأكملها باستخدام `import module_name`. ستصل بعد ذلك إلى دوالها مثل `module_name.function_name()`. بدلاً من ذلك، يمكنك استيراد أجزاء محددة من وحدة نمطية باستخدام `from module_name import function_name`. يتيح لك هذا استدعاء `function_name()` مباشرة.",
          "تأتي بايثون مع **مكتبة قياسية** ضخمة مليئة بالوحدات النمطية المفيدة التي يمكنك استيرادها دون تثبيت أي شيء إضافي. تعد وحدة `math` للعمليات الرياضية المتقدمة، و `random` للأرقام العشوائية، و `datetime` للعمل مع التواريخ والأوقات أمثلة شائعة.",
          "للمشاريع الأكبر حجمًا، يمكنك تجميع الوحدات النمطية ذات الصلة معًا في **حزمة (package)**. الحزمة هي مجرد دليل يحتوي على وحدات بايثون وملف خاص (غالبًا ما يكون فارغًا) يسمى `__init__.py`. يخبر هذا الملف بايثون بأنه يجب معاملة الدليل كحزمة، مما يسمح لك بتنظيم الكود الخاص بك في هيكل هرمي."
        ],
        "codeExample": "# 1. استيراد وحدة math بأكملها\nimport math\nprint(f\"قيمة باي تقريبًا {math.pi}\")\n\n# 2. استيراد دالة معينة من وحدة datetime\nfrom datetime import date\ntoday = date.today()\nprint(f\"تاريخ اليوم هو {today}\")\n\n# 3. استيراد وحدة وإعطائها اسمًا مستعارًا أقصر\nimport random as rd\nrandom_number = rd.randint(1, 100)\nprint(f\"رقم عشوائي هو: {random_number}\")",
        "quiz": [
          {
            "question": "ما هي وحدة بايثون النمطية؟",
            "options": ["دالة مضمنة", "ملف بايثون يحتوي على كود", "مجلد من النصوص البرمجية", "نوع من الفئات"],
            "correctAnswer": "ملف بايثون يحتوي على كود"
          },
          {
            "question": "ما هي الكلمة المفتاحية المستخدمة لجلب كود وحدة نمطية إلى النص البرمجي الحالي؟",
            "options": ["include", "use", "import", "load"],
            "correctAnswer": "import"
          },
          {
            "question": "كيف تستورد الثابت `pi` فقط من وحدة `math`؟",
            "options": ["import math.pi", "from math import pi", "import pi from math", "using math.pi"],
            "correctAnswer": "from math import pi"
          },
          {
            "question": "ماذا تسمى مجموعة من الوحدات النمطية في دليل؟",
            "options": ["مكتبة", "مجموعة", "حزمة", "مجموعة (Set)"],
            "correctAnswer": "حزمة"
          },
          {
            "question": "ما هو الغرض من `import math as m`؟",
            "options": ["لإنشاء نسخة من وحدة math", "لإعطاء وحدة math اسمًا مستعارًا أقصر، `m`", "لاستيراد وحدة تسمى 'm'", "لتشغيل الدالة الرئيسية لوحدة math"],
            "correctAnswer": "لإعطاء وحدة math اسمًا مستعارًا أقصر، `m`"
          }
        ],
        "pacing": "medium"
      },
      {
        "id": "16",
        "title": "مكتبة بايثون القياسية",
        "description": "استكشف بعضًا من أكثر الوحدات النمطية فائدة المضمنة مع بايثون.",
        "content": [
          "إحدى أعظم نقاط قوة بايثون هي فلسفتها 'البطاريات متضمنة'. يتجسد هذا في **مكتبة بايثون القياسية**، وهي مجموعة ضخمة من الوحدات النمطية والحزم التي يتم تثبيتها تلقائيًا مع بايثون. لا تحتاج إلى تنزيلها أو تثبيتها بشكل منفصل؛ ما عليك سوى `import` لها.",
          "يعد استكشاف المكتبة القياسية أمرًا أساسيًا لتصبح مبرمج بايثون فعالًا، حيث إنها توفر أدوات لمجموعة واسعة من المهام الشائعة، مما يوفر عليك كتابة كل شيء من البداية.",
          "بعض الوحدات النمطية الأساسية التي يجب معرفتها هي: **`os`** للتفاعل مع نظام التشغيل (مثل العمل مع الملفات والأدلة)، **`sys`** للوصول إلى المعلمات والوظائف الخاصة بالنظام (مثل وسائط سطر الأوامر)، **`random`** لتوليد أرقام عشوائية واتخاذ خيارات عشوائية، و **`json`** لترميز وفك ترميز بيانات JSON.",
          "هذا مجرد غيض من فيض. هناك وحدات نمطية للتعامل مع الملفات المضغوطة، والعمل مع الشبكات، وإجراء العمليات الحسابية، وأكثر من ذلك بكثير. تعد وثائق بايثون الرسمية أفضل مكان لاستكشاف جميع الوحدات النمطية المتاحة."
        ],
        "codeExample": "import random\nimport os\nimport platform\n\n# استخدام وحدة random لاختيار خيار عشوائي\nchoices = ['حجر', 'ورقة', 'مقص']\ncomputer_choice = random.choice(choices)\nprint(f\"اختار الكمبيوتر: {computer_choice}\")\n\n# استخدام وحدة os للحصول على دليل العمل الحالي\ncurrent_directory = os.getcwd()\nprint(f\"يعمل هذا البرنامج في: {current_directory}\")\n\n# استخدام وحدة platform للحصول على معلومات نظام التشغيل\nos_name = platform.system()\nprint(f\"أنت تعمل على: {os_name}\")",
        "quiz": [
          {
            "question": "أي وحدة نمطية ستستخدمها للحصول على الدليل الحالي؟",
            "options": ["sys", "os", "path", "system"],
            "correctAnswer": "os"
          },
          {
            "question": "لتوليد عدد عشري عشوائي بين 0.0 و 1.0، ستستخدم...",
            "options": ["random.randint(0, 1)", "random.random()", "random.float()", "random.uniform(0, 1)"],
            "correctAnswer": "random.random()"
          },
          {
            "question": "هل تحتاج إلى تثبيت الوحدات النمطية من المكتبة القياسية باستخدام pip؟",
            "options": ["نعم، دائمًا", "لا، تأتي مع بايثون", "فقط على ويندوز", "فقط على ماك"],
            "correctAnswer": "لا، تأتي مع بايثون"
          },
          {
            "question": "تُستخدم وحدة `json` لـ...",
            "options": ["العمل مع كود جافا سكريبت", "إنشاء واجهات مستخدم", "تحليل وتوليد بيانات JSON", "العمليات الرياضية"],
            "correctAnswer": "تحليل وتوليد بيانات JSON"
          },
          {
            "question": "أي وحدة نمطية توفر الوصول إلى معلمات ووظائف خاصة بالنظام؟",
            "options": ["os", "sys", "system", "platform"],
            "correctAnswer": "sys"
          }
        ],
        "pacing": "medium"
      },
      {
        "id": "17",
        "title": "List Comprehensions",
        "description": "تعلم طريقة موجزة لإنشاء القوائم.",
        "content": [
          "تقدم بايثون العديد من الطرق لكتابة كود أنيق وفعال في نفس الوقت. تعد **List Comprehensions** مثالاً مثالياً على ذلك. فهي توفر صيغة مدمجة وقابلة للقراءة لإنشاء قائمة بناءً على تسلسل موجود.",
          "تتكون list comprehension من أقواس مربعة `[]` تحتوي على تعبير، متبوعًا بعبارة `for`. على سبيل المثال، لإنشاء قائمة من المربعات من 0 إلى 9، يمكنك كتابة حلقة for، أو يمكنك استخدام list comprehension: `squares = [x**2 for x in range(10)]`.",
          "الصيغة الأساسية هي `[expression for item in iterable]`. غالبًا ما تكون هذه الصيغة أقصر وأوضح بكثير من حلقة `for` التقليدية التي تهيئ قائمة فارغة وتضيف إليها في كل تكرار.",
          "يمكنك أيضًا إضافة شرط `if` في النهاية لتصفية العناصر من التسلسل الأصلي. تصبح الصيغة `[expression for item in iterable if condition]`. يتم تقييم التعبير فقط للعناصر التي يكون الشرط فيها صحيحًا. هذا يجعلها قوية بشكل لا يصدق لتحويل وتصفية البيانات في سطر واحد."
        ],
        "codeExample": "# طريقة تقليدية للحصول على الأرقام الزوجية\neven_numbers_loop = []\nfor i in range(1, 11):\n  if i % 2 == 0:\n    even_numbers_loop.append(i)\nprint(f\"باستخدام حلقة: {even_numbers_loop}\")\n\n# فعل الشيء نفسه باستخدام list comprehension\neven_numbers_comp = [i for i in range(1, 11) if i % 2 == 0]\nprint(f\"باستخدام comprehension: {even_numbers_comp}\")\n\n# يمكنك أيضًا تحويل البيانات\nsquares_of_evens = [i**2 for i in range(1, 11) if i % 2 == 0]\nprint(f\"مربعات الأرقام الزوجية: {squares_of_evens}\")",
        "quiz": [
          {
            "question": "ما هي الفائدة الرئيسية من list comprehensions؟",
            "options": ["تعمل بشكل أسرع", "توفر بناء جملة أكثر إيجازًا وقابلية للقراءة لإنشاء القوائم", "يمكنها القيام بأشياء لا تستطيع حلقات for القيام بها", "تستخدم ذاكرة أقل"],
            "correctAnswer": "توفر بناء جملة أكثر إيجازًا وقابلية للقراءة لإنشاء القوائم"
          },
          {
            "question": "أي من هذه هي list comprehension صالحة؟",
            "options": ["(x for x in range(5))", "[x for x in range(5)]", "{x for x in range(5)}", "list(x for x in range(5))"],
            "correctAnswer": "[x for x in range(5)]"
          },
          {
            "question": "كيف يمكنك إنشاء قائمة بجميع الأحرف الكبيرة في سلسلة نصية `s`؟",
            "options": ["[char.upper() for char in s]", "[char for char in s if char.isupper()]", "{char for char in s if char.isupper()}", "[char.upper() if char.islower() for char in s]"],
            "correctAnswer": "[char for char in s if char.isupper()]"
          },
          {
            "question": "هل يمكنك تضمين شرط `if` في list comprehension؟",
            "options": ["لا، يُسمح فقط بحلقات for", "نعم، لتصفية العناصر", "نعم، ولكن في البداية فقط", "لا، هذا يتطلب دالة لامدا"],
            "correctAnswer": "نعم، لتصفية العناصر"
          },
          {
            "question": "ماذا تُقيّم `[num * 2 for num in [1, 2, 3]]`؟",
            "options": ["[1, 2, 3]", "[1, 4, 9]", "[2, 4, 6]", "[2, 2, 2]"],
            "correctAnswer": "[2, 4, 6]"
          }
        ],
        "pacing": "fast"
      },
      {
        "id": "18",
        "title": "دوال لامدا",
        "description": "تعلم كيفية إنشاء دوال صغيرة ومجهولة الاسم بسرعة.",
        "content": [
          "**دالة لامدا** هي دالة صغيرة ذات تعبير واحد ليس لها اسم (إنها **مجهولة**). يتم تعريفها باستخدام الكلمة المفتاحية `lambda`.",
          "الصيغة هي `lambda arguments: expression`. يمكن للدالة أن تأخذ أي عدد من الوسائط، ولكن يمكن أن يكون لها تعبير واحد فقط. يتم تقييم التعبير وإرجاعه عند استدعاء الدالة. فكر فيها كاختصار لدالة `def` بسيطة مع عبارة `return` واحدة.",
          "لماذا نستخدمها؟ دوال لامدا مفيدة عندما تحتاج إلى دالة بسيطة لفترة قصيرة من الزمن، ولا تريد تشويش الكود الخاص بك بتعريف دالة `def` كاملة. تُستخدم بشكل شائع جدًا كوسائط للدوال ذات الترتيب الأعلى (الدوال التي تأخذ دوال أخرى كوسائط)، مثل `map`، `filter`، أو عند الفرز.",
          "على سبيل المثال، إذا كنت ترغب في فرز قائمة من الصفوف بناءً على العنصر الثاني من كل صف، يمكنك توفير دالة لامدا للوسيط `key` في التابع `sort()`: `my_list.sort(key=lambda x: x[1])`. هذا أكثر نظافة بكثير من تعريف دالة منفصلة لهذا الاستخدام لمرة واحدة فقط."
        ],
        "codeExample": "# دالة لامدا تضيف 10 إلى رقم\nadd_ten = lambda x: x + 10\nprint(f\"15 + 10 = {add_ten(15)}\")\n\n# دالة لامدا تضرب رقمين\nmultiply = lambda x, y: x * y\nprint(f\"5 * 6 = {multiply(5, 6)}\")\n\n# استخدام دالة لامدا لفرز قائمة من الصفوف حسب العنصر الثاني\npoints = [(1, 5), (9, 2), (4, 7)]\npoints.sort(key=lambda point: point[1])\nprint(f\"النقاط المرتبة حسب المحور Y: {points}\")",
        "quiz": [
          {
            "question": "ما هي الكلمة المفتاحية المستخدمة لإنشاء دالة لامدا؟",
            "options": ["def", "anon", "lambda", "function"],
            "correctAnswer": "lambda"
          },
          {
            "question": "ما هو القيد الرئيسي لدوال لامدا؟",
            "options": ["يمكن أن يكون لها وسيط واحد فقط", "لا يمكن تخزينها في متغير", "يمكن أن تحتوي على تعبير واحد فقط", "لا يمكن استخدامها مع القوائم"],
            "correctAnswer": "يمكن أن تحتوي على تعبير واحد فقط"
          },
          {
            "question": "ما هي الدالة 'المجهولة'؟",
            "options": ["دالة سرية", "دالة بدون اسم", "دالة غير آمنة", "دالة لا تعيد شيئًا"],
            "correctAnswer": "دالة بدون اسم"
          },
          {
            "question": "أي من هذه هي دالة لامدا صالحة تضيف رقمين؟",
            "options": ["lambda a, b: return a + b", "lambda a, b: a + b", "lambda (a, b): a + b", "def lambda(a, b): a + b"],
            "correctAnswer": "lambda a, b: a + b"
          },
          {
            "question": "متى تستخدم دوال لامدا بشكل شائع؟",
            "options": ["كدوال مستقلة", "لتعريف دوال الفئة", "كوسائط لدوال من الدرجة الأعلى", "لإدخال/إخراج الملفات"],
            "correctAnswer": "كوسائط لدوال من الدرجة الأعلى"
          }
        ],
        "pacing": "fast"
      },
      {
        "id": "19",
        "title": "Map، Filter، و Reduce",
        "description": "تعرف على الدوال المضمنة القوية للعمل مع الكائنات القابلة للتكرار.",
        "content": [
          "تتضمن بايثون العديد من الدوال القوية لأسلوب برمجة يسمى **البرمجة الوظيفية**. `map` و `filter` و `reduce` هي ثلاثة من أشهر هذه الدوال.",
          "تقوم دالة **`map()`** بتطبيق دالة معينة على كل عنصر من عناصر كائن قابل للتكرار (مثل قائمة) وتعيد كائن map (يمكن تحويله إلى قائمة). على سبيل المثال، `map(lambda x: x * 2, [1, 2, 3])` ستطبق دالة المضاعفة على كل رقم.",
          "تنشئ دالة **`filter()`** مكررًا من عناصر كائن قابل للتكرار والتي تعيد الدالة لها `True`. إنها تقوم بشكل أساسي بتصفية التسلسل. يجب أن تعيد الدالة التي يتم تمريرها إلى `filter` قيمة منطقية. على سبيل المثال، `filter(lambda x: x > 10, numbers)` ستحتفظ فقط بالأرقام الأكبر من 10.",
          "دالة **`reduce()`** مختلفة قليلاً. إنها جزء من وحدة `functools` وتقوم بتطبيق دالة من وسيطين بشكل تراكمي على عناصر تسلسل، لتقليل التسلسل إلى قيمة واحدة. على سبيل المثال، `reduce(lambda x, y: x + y, [1, 2, 3, 4])` ستحسب `((1+2)+3)+4` للحصول على المجموع."
        ],
        "codeExample": "from functools import reduce\n\nnumbers = [1, 2, 3, 4, 5, 6, 7, 8]\n\n# Map: إنشاء قائمة جديدة بمربع كل رقم\nsquares = list(map(lambda x: x**2, numbers))\nprint(f\"المربعات: {squares}\")\n\n# Filter: إنشاء قائمة جديدة بالأرقام الفردية فقط\nodds = list(filter(lambda x: x % 2 != 0, numbers))\nprint(f\"الأرقام الفردية: {odds}\")\n\n# Reduce: إيجاد حاصل ضرب جميع الأرقام في القائمة\nproduct = reduce(lambda x, y: x * y, numbers)\nprint(f\"حاصل ضرب جميع الأرقام: {product}\")",
        "quiz": [
          {
            "question": "أي دالة ستستخدمها لتطبيق نفس العملية على كل عنصر في قائمة؟",
            "options": ["filter", "reduce", "map", "apply"],
            "correctAnswer": "map"
          },
          {
            "question": "أي دالة ستستخدمها لإنشاء قائمة جديدة تحتوي فقط على العناصر التي تحقق شرطًا معينًا؟",
            "options": ["filter", "reduce", "map", "select"],
            "correctAnswer": "filter"
          },
          {
            "question": "أي وحدة نمطية تحتوي على دالة `reduce`؟",
            "options": ["itertools", "collections", "functools", "math"],
            "correctAnswer": "functools"
          },
          {
            "question": "يجب أن تعيد الدالة التي يتم تمريرها إلى `filter()`...",
            "options": ["رقمًا", "سلسلة نصية", "قيمة منطقية (True أو False)", "قائمة"],
            "correctAnswer": "قيمة منطقية (True أو False)"
          },
          {
            "question": "ما هي نتيجة `reduce(lambda x, y: x + y, [1, 2, 3])`؟",
            "options": ["3", "5", "6", "خطأ"],
            "correctAnswer": "6"
          }
        ],
        "pacing": "fast"
      },
      {
        "id": "20",
        "title": "المزخرفات (Decorators)",
        "description": "تعلم كيفية تعديل أو تحسين الدوال دون تغيير الكود الخاص بها.",
        "content": [
          "في بايثون، تعد الدوال 'مواطنين من الدرجة الأولى'، مما يعني أنه يمكنك معاملتها مثل أي متغير آخر: يمكنك تمريرها كوسائط لدوال أخرى، ويمكنك أن يكون لديك دوال تعيد دوال أخرى. هذه الإمكانية هي ما يجعل **المزخرفات (decorators)** ممكنة.",
          "المزخرف هو دالة تأخذ دالة أخرى كوسيط، وتضيف نوعًا من الوظائف ('زخرفة')، ثم تعيد دالة جديدة محسنة. يتيح لك هذا تعديل أو توسيع سلوك الدوال دون تغيير شفرتها المصدرية بشكل دائم.",
          "الطريقة الأكثر شيوعًا لتطبيق مزخرف هي باستخدام صيغة `@`، وهي مجرد 'سكر نحوي'. وضع `@my_decorator` على السطر قبل `def my_function():` يعادل كتابة `my_function = my_decorator(my_function)` بعد تعريف الدالة.",
          "تُستخدم المزخرفات بشكل شائع للمهام التي تنطبق على العديد من الدوال، مثل تسجيل استدعاءات الدوال، وتوقيت مدة تشغيل الدالة، والتحقق من أذونات المستخدم قبل تشغيل دالة حرجة، أو إدارة معاملات قاعدة البيانات."
        ],
        "codeExample": "# هذا هو المزخرف الخاص بنا\ndef uppercase_decorator(function):\n    def wrapper():\n        # الحصول على النتيجة الأصلية\n        original_result = function()\n        # تعديلها\n        modified_result = original_result.upper()\n        return modified_result\n    return wrapper\n\n# تطبيق المزخرف على دالتنا\n@uppercase_decorator\ndef say_greeting():\n    return \"أهلاً بك\"\n\n# استدعاء الدالة الآن يستدعي النسخة المغلفة\nprint(say_greeting())",
        "quiz": [
          {
            "question": "ما هو المزخرف في بايثون؟",
            "options": ["نوع من الفئات", "دالة تعدل دالة أخرى", "بناء جملة للتعليقات", "طريقة لتنسيق الكود"],
            "correctAnswer": "دالة تعدل دالة أخرى"
          },
          {
            "question": "ما الرمز المستخدم لتطبيق مزخرف؟",
            "options": ["#", "$", "&", "@"],
            "correctAnswer": "@"
          },
          {
            "question": "ماذا تعيد دالة المزخرف عادةً؟",
            "options": ["الدالة الأصلية، غير معدلة", "دالة جديدة (غلاف)", "قيمة منطقية", "لا شيء"],
            "correctAnswer": "دالة جديدة (غلاف)"
          },
          {
            "question": "هل يمكنك تطبيق مزخرفات متعددة على دالة واحدة؟",
            "options": ["لا، يُسمح بواحدة فقط", "نعم، يتم تطبيقها من الأسفل إلى الأعلى"],
            "correctAnswer": "نعم، يتم تطبيقها من الأسفل إلى الأعلى"
          },
          {
            "question": "حالة استخدام شائعة للمزخرفات هي...",
            "options": ["الحسابات الرياضية", "تسجيل أو توقيت تنفيذ الدالة", "تخزين البيانات", "تعريف المتغيرات"],
            "correctAnswer": "تسجيل أو توقيت تنفيذ الدالة"
          }
        ],
        "pacing": "fast"
      },
      {
        "id": "21",
        "title": "المولدات (Generators)",
        "description": "تعلم كيفية إنشاء المكررات بطريقة بسيطة وفعالة من حيث الذاكرة.",
        "content": [
          "**مولد (generator)** بايثون هو نوع خاص من المكررات. إنها دالة، بدلاً من إرجاع قيمة واحدة باستخدام `return`، 'تنتج' سلسلة من القيم واحدة تلو الأخرى باستخدام الكلمة المفتاحية `yield`.",
          "عند استدعاء دالة عادية، فإنها تعمل حتى تكتمل وتعيد قيمة. عند استدعاء دالة مولد، فإنها تعيد **كائن مولد**. لا يعمل الكود الموجود داخل الدالة حتى تبدأ في التكرار عليه، عادةً عن طريق استدعاء `next()` على كائن المولد أو استخدامه في حلقة `for`.",
          "في كل مرة يتم فيها مصادفة `yield`، توقف الدالة تنفيذها مؤقتًا وترسل القيمة. في المرة التالية التي تستدعي فيها `next()` عليها، تستأنف الدالة التنفيذ من حيث توقفت، مع بقاء جميع متغيراتها المحلية سليمة.",
          "الميزة الأساسية للمولدات هي **كفاءتها في استخدام الذاكرة**. فهي تنتج العناصر بسرعة ولا تخزن التسلسل بأكمله في الذاكرة. وهذا يجعلها مثالية للعمل مع مجموعات بيانات كبيرة جدًا، أو قراءة ملفات كبيرة، أو توليد تسلسلات لا نهائية حيث يكون تخزين كل شيء مستحيلاً."
        ],
        "codeExample": "# دالة المولد هذه تنتج أرقامًا من 0 حتى (ولكن لا تشمل) max\ndef number_generator(max):\n    n = 0\n    while n < max:\n        print(f\"- إنتاج {n}\")\n        yield n\n        n += 1\n\n# استخدام المولد في حلقة for\nprint(\"التكرار عبر المولد:\")\nfor number in number_generator(4):\n    print(f\"  تم استلام {number}\")",
        "quiz": [
          {
            "question": "ما هي الكلمة المفتاحية المستخدمة في دالة المولد لإنتاج قيمة؟",
            "options": ["return", "generate", "yield", "produce"],
            "correctAnswer": "yield"
          },
          {
            "question": "ما هي الميزة الرئيسية لاستخدام المولدات؟",
            "options": ["إنها أسرع من الدوال العادية", "إنها فعالة من حيث الذاكرة", "إنها أسهل في الكتابة", "يمكن استخدامها كمزخرفات"],
            "correctAnswer": "إنها فعالة من حيث الذاكرة"
          },
          {
            "question": "ماذا يحدث عند استدعاء دالة المولد؟",
            "options": ["تنفذ الدالة بأكملها وتعيد قائمة", "تعيد كائن مولد", "تثير خطأ على الفور", "تطبع جميع القيم على وحدة التحكم"],
            "correctAnswer": "تعيد كائن مولد"
          },
          {
            "question": "كيف تحصل على القيمة التالية من مولد `gen`؟",
            "options": ["gen.next()", "next(gen)", "gen.get()", "gen.yield()"],
            "correctAnswer": "next(gen)"
          },
          {
            "question": "ماذا يحدث عندما ينتج المولد جميع قيمه وتستدعي `next()` عليه مرة أخرى؟",
            "options": ["يبدأ من جديد من البداية", "يثير استثناء StopIteration", "يعيد None", "ينتظر المزيد من البيانات"],
            "correctAnswer": "يثير استثناء StopIteration"
          }
        ],
        "pacing": "fast"
      },
      {
        "id": "22",
        "title": "العمل مع JSON",
        "description": "تعلم كيفية تحليل وإنشاء بيانات JSON، وهو تنسيق شائع لتبادل البيانات.",
        "content": [
          "JSON (JavaScript Object Notation) هو تنسيق خفيف الوزن ومستند إلى نص لتبادل البيانات. إنه المعيار الفعلي لواجهات برمجة التطبيقات على الويب وملفات التكوين لأنه سهل القراءة للبشر وسهل التحليل للآلات.",
          "تجعل وحدة `json` في بايثون، وهي جزء من المكتبة القياسية، العمل مع بيانات JSON سلسًا. فهي تربط كائنات بايثون بمكافئاتها في JSON. على سبيل المثال، يصبح قاموس بايثون `{}` كائن JSON `{}`, وتصبح قائمة بايثون `[]` مصفوفة JSON `[]`, ويصبح `None` `null`.",
          "لتحويل كائن بايثون (مثل قاموس أو قائمة) إلى سلسلة بتنسيق JSON، تستخدم التابع `json.dumps()` (dump string). يمكنك تمرير `indent=4` لجعل السلسلة الناتجة منسقة بشكل جيد وقابلة للقراءة.",
          "للقيام بالعكس - تحليل سلسلة بتنسيق JSON إلى كائن بايثون - تستخدم التابع `json.loads()` (load string). سيعيد هذا عادةً قاموسًا أو قائمة بايثون يمكنك بعد ذلك التعامل معها في الكود الخاص بك."
        ],
        "codeExample": "import json\n\n# قاموس بايثون\nperson_dict = {\n    'name': 'يحيى',\n    'age': 30,\n    'isStudent': False,\n    'courses': ['تاريخ', 'علوم الحاسب']\n}\n\n# 1. تحويل قاموس بايثون إلى سلسلة JSON (serialization)\njson_string = json.dumps(person_dict, indent=4, ensure_ascii=False)\nprint(\"--- سلسلة JSON ---\")\nprint(json_string)\n\n# 2. تحويل سلسلة JSON مرة أخرى إلى قاموس بايثون (deserialization)\nparsed_dict = json.loads(json_string)\nprint(\"\\n--- القاموس المحلل ---\")\nprint(parsed_dict)\nprint(f\"الاسم هو: {parsed_dict['name']}\")",
        "quiz": [
          {
            "question": "ماذا يرمز JSON؟",
            "options": ["Java Standard Object Notation", "JavaScript Object Notation", "JavaScript Ordered Notation", "Java Source Object Notation"],
            "correctAnswer": "JavaScript Object Notation"
          },
          {
            "question": "أي دالة `json` تحول قاموس بايثون إلى سلسلة JSON؟",
            "options": ["json.load()", "json.loads()", "json.dump()", "json.dumps()"],
            "correctAnswer": "json.dumps()"
          },
          {
            "question": "أي دالة `json` تحلل سلسلة JSON إلى كائن بايثون؟",
            "options": ["json.load()", "json.loads()", "json.dump()", "json.dumps()"],
            "correctAnswer": "json.loads()"
          },
          {
            "question": "ما هو نوع بيانات بايثون الذي يتوافق معه كائن JSON عادةً؟",
            "options": ["قائمة", "صف", "قاموس", "مجموعة"],
            "correctAnswer": "قاموس"
          },
          {
            "question": "في `json.dumps(data, indent=4)`، ما هو الغرض من `indent=4`؟",
            "options": ["يجعل سلسلة JSON أكثر إحكامًا", "يضيف 4 مسافات من المسافة البادئة للطباعة الجميلة", "يشفر البيانات 4 مرات", "يحد من عمق JSON إلى 4 مستويات"],
            "correctAnswer": "يضيف 4 مسافات من المسافة البادئة للطباعة الجميلة"
          }
        ],
        "pacing": "medium"
      },
      {
        "id": "23",
        "title": "مقدمة في واجهات برمجة التطبيقات (APIs)",
        "description": "فهم ما هي واجهات برمجة التطبيقات وكيفية التفاعل معها باستخدام بايثون.",
        "content": [
          "API تعني **واجهة برمجة التطبيقات (Application Programming Interface)**. في جوهرها، API هي مجموعة من القواعد والبروتوكولات التي تسمح لتطبيقين برمجيين مختلفين بالتواصل مع بعضهما البعض. إنها عقد يحدد كيف يمكن لبرنامج ما أن يطلب خدمات أو بيانات من برنامج آخر.",
          "في تطوير الويب الحديث، ستتفاعل باستمرار مع واجهات برمجة التطبيقات على الويب. تتيح لك هذه الواجهات جلب البيانات من خدمات خارجية عبر الإنترنت. على سبيل المثال، عندما يعرض لك تطبيق ما حالة الطقس، فمن المحتمل أنه يستدعي واجهة برمجة تطبيقات خدمة الطقس. هذا يوفر على المطورين عناء بناء البنية التحتية الخاصة بهم لتتبع الطقس.",
          "الطريقة الأكثر شيوعًا للتفاعل مع واجهات برمجة التطبيقات على الويب هي باستخدام طلبات HTTP. المكتبة الخارجية الأكثر شيوعًا لهذا في بايثون هي `requests`. إنها تبسط عملية إجراء أنواع مختلفة من الطلبات، مثل طلب `GET` لاسترداد البيانات، أو طلب `POST` لإرسال بيانات جديدة.",
          "عندما تقوم بطلب ناجح إلى واجهة برمجة تطبيقات، فإنها تعيد استجابة. تتضمن هذه الاستجابة **رمز حالة (status code)** (على سبيل المثال، `200` للنجاح، `404` لغير موجود) وغالبًا ما تحتوي على نص يحتوي على البيانات المطلوبة، عادةً بتنسيق JSON. يمكنك بعد ذلك استخدام التابع `response.json()` لتحليل هذه البيانات إلى قاموس بايثون."
        ],
        "codeExample": "# قد تحتاج إلى تشغيل 'pip install requests' في الطرفية أولاً\nimport requests\nimport json\n\n# نقطة نهاية API لنكتة عشوائية\nURL = \"https://official-joke-api.appspot.com/random_joke\"\n\nprint(\"جاري جلب نكتة عشوائية من واجهة برمجة التطبيقات...\")\n# إجراء طلب GET إلى واجهة برمجة التطبيقات\nresponse = requests.get(URL)\n\n# التحقق مما إذا كان الطلب ناجحًا (رمز الحالة 200)\nif response.status_code == 200:\n    # تحليل استجابة JSON إلى قاموس بايثون\n    data = response.json()\n    print(\"\\nالمقدمة: \" + data['setup'])\n    print(\"النكتة: \" + data['punchline'])\nelse:\n    print(f\"فشل في الحصول على البيانات. رمز الحالة: {response.status_code}\")",
        "quiz": [
          {
            "question": "ماذا تعني API؟",
            "options": ["واجهة بروتوكول التطبيق", "واجهة برمجة التطبيقات", "ربط برمجي متقدم", "مثيل بروتوكول التطبيق"],
            "correctAnswer": "واجهة برمجة التطبيقات"
          },
          {
            "question": "أي مكتبة تستخدم بشكل شائع لتقديم طلبات HTTP في بايثون؟",
            "options": ["http", "urllib", "requests", "web"],
            "correctAnswer": "requests"
          },
          {
            "question": "ما هو رمز حالة HTTP الذي يشير إلى طلب ناجح؟",
            "options": ["200", "404", "500", "301"],
            "correctAnswer": "200"
          },
          {
            "question": "أي طريقة HTTP تستخدم عادةً لاسترداد البيانات من واجهة برمجة التطبيقات؟",
            "options": ["POST", "GET", "DELETE", "PUT"],
            "correctAnswer": "GET"
          },
          {
            "question": "بعد الحصول على استجابة من `requests.get()`، أي طريقة تستخدم لتحليل محتوى JSON؟",
            "options": ["response.text", "response.content", "response.json()", "response.parse()"],
            "correctAnswer": "response.json()"
          }
        ],
        "pacing": "medium"
      },
      {
        "id": "24",
        "title": "أساسيات كشط الويب",
        "description": "تعلم كيفية استخراج البيانات من مواقع الويب باستخدام Requests و BeautifulSoup.",
        "content": [
          "**كشط الويب (Web scraping)** هو عملية استخراج البيانات تلقائيًا من مواقع الويب. إنها تقنية مفيدة عندما تكون البيانات التي تريدها متاحة على موقع ويب ولكن ليس من خلال واجهة برمجة تطبيقات منظمة. على سبيل المثال، قد تقوم بكشط أسعار المنتجات من موقع للتجارة الإلكترونية أو العناوين الرئيسية من موقع إخباري.",
          "تتضمن العملية بشكل عام خطوتين رئيسيتين. أولاً، تستخدم مكتبة مثل `requests` لتنزيل محتوى HTML الخام لصفحة ويب، تمامًا كما يفعل متصفحك. يمنحك هذا الكود المصدري للصفحة كنص.",
          "ثانيًا، يصعب التعامل مع HTML الخام. لذا، تستخدم مكتبة تحليل لتحويل نص HTML إلى كائن منظم يمكنك التنقل فيه. المكتبة الأكثر شيوعًا لهذا في بايثون هي **`BeautifulSoup`**. تتيح لك البحث عن المعلومات واستخراجها عن طريق العثور على علامات HTML محددة (مثل `<h1>` أو `<p>`)، أو عناصر ذات فئات أو معرفات CSS محددة.",
          "**ملاحظة هامة:** كن دائمًا محترمًا عند الكشط. تحقق من ملف `robots.txt` الخاص بالموقع (على سبيل المثال، `example.com/robots.txt`) وشروط الخدمة الخاصة به لمعرفة ما إذا كانوا يسمحون بالكشط. يمكن أن يؤدي الكشط بقوة مفرطة إلى إرهاق خوادم موقع الويب ويعتبر ممارسة سيئة."
        ],
        "codeExample": "# ملاحظة: ستحتاج إلى تثبيت هذه المكتبات أولاً:\n# pip install requests beautifulsoup4\nimport requests\nfrom bs4 import BeautifulSoup\n\n# هذا مثال مفاهيمي. يتطلب كشط موقع حقيقي فحص HTML الخاص به.\nURL = \"http://example.com\"\ntry:\n    response = requests.get(URL)\n    # إنشاء كائن BeautifulSoup لتحليل HTML\n    soup = BeautifulSoup(response.content, 'html.parser')\n\n    # العثور على أول علامة <h1> والحصول على نصها\n    title = soup.find('h1').text\n    print(f\"عنوان الصفحة هو: '{title}'\")\n\n    # العثور على أول علامة <p>\n    paragraph = soup.find('p').text\n    print(f\"الفقرة الأولى تقول: '{paragraph}'\")\nexcept Exception as e:\n    print(f\"لم يتمكن من كشط الموقع. خطأ: {e}\")",
        "quiz": [
          {
            "question": "ما هو كشط الويب؟",
            "options": ["تصميم مواقع الويب", "استخراج البيانات تلقائيًا من مواقع الويب", "تأمين مواقع الويب", "اختبار سرعة موقع الويب"],
            "correctAnswer": "استخراج البيانات تلقائيًا من مواقع الويب"
          },
          {
            "question": "أي مكتبة تستخدم بشكل شائع لتحليل محتوى HTML في بايثون؟",
            "options": ["requests", "json", "BeautifulSoup", "os"],
            "correctAnswer": "BeautifulSoup"
          },
          {
            "question": "أي مكتبة تستخدم لتنزيل HTML لصفحة الويب؟",
            "options": ["requests", "bs4", "parser", "html"],
            "correctAnswer": "requests"
          },
          {
            "question": "في BeautifulSoup، أي تابع يستخدم عادة للعثور على أول ظهور لعلامة؟",
            "options": ["find()", "find_all()", "select()", "get()"],
            "correctAnswer": "find()"
          },
          {
            "question": "هل من المقبول دائمًا كشط أي موقع ويب؟",
            "options": ["نعم، جميع البيانات على الإنترنت مجانية", "لا، يجب عليك دائمًا التحقق من شروط خدمة موقع الويب وملف `robots.txt` أولاً"],
            "correctAnswer": "لا، يجب عليك دائمًا التحقق من شروط خدمة موقع الويب وملف `robots.txt` أولاً"
          }
        ],
        "pacing": "medium"
      },
      {
        "id": "25",
        "title": "البيئات الافتراضية و pip",
        "description": "تعلم كيفية إدارة تبعيات المشروع باستخدام البيئات الافتراضية ومدير الحزم pip.",
        "content": [
          "عندما تعمل على المزيد من مشاريع بايثون، ستبدأ في استخدام مكتبات خارجية (كود كتبه أشخاص آخرون). تنشأ مشكلة عندما يحتاج المشروع (أ) إلى الإصدار 1.0 من مكتبة، بينما يحتاج المشروع (ب) إلى الإصدار 2.0. يمكن أن يتسبب تثبيت هذه المكتبات على مستوى النظام في حدوث تعارضات.",
          "**البيئة الافتراضية** تحل هذه المشكلة. إنها دليل معزول ومستقل يحتوي على إصدار معين من بايثون بالإضافة إلى جميع المكتبات المطلوبة لمشروع معين. هذا يحافظ على تبعيات مشروعك منفصلة عن المشاريع الأخرى وعن تثبيت بايثون العالمي في نظامك.",
          "**`pip`** هو مثبت الحزم لبايثون. إنها أداة سطر الأوامر التي تستخدمها لتثبيت الحزم وترقيتها وإزالتها من فهرس حزم بايثون (PyPI). عندما تكون لديك بيئة افتراضية نشطة، سيقوم `pip` بتثبيت الحزم *داخل* تلك البيئة فقط.",
          "من الممارسات القياسية الاحتفاظ بقائمة من تبعيات مشروعك في ملف، يسمى تقليديًا `requirements.txt`. يمكنك إنشاء هذا الملف باستخدام `pip freeze > requirements.txt`. يتيح هذا لمطور آخر تثبيت نفس مجموعة المكتبات بسهولة عن طريق تشغيل `pip install -r requirements.txt`."
        ],
        "codeExample": "# ستقوم بتشغيل هذه الأوامر في الطرفية الخاصة بك، وليس في برنامج بايثون نصي.\n\n# 1. انتقل إلى مجلد مشروعك وأنشئ بيئة افتراضية\n# python -m venv myenv\n\n# 2. قم بتنشيط البيئة\n# على ويندوز: .\\myenv\\Scripts\\activate\n# على ماك/لينكس: source myenv/bin/activate\n\n# 3. بمجرد التنشيط، سيتغير موجه الأوامر في الطرفية.\n# الآن، قم بتثبيت حزمة. سيتم تثبيتها فقط في 'myenv'.\n# pip install requests\n\n# 4. احفظ تبعياتك في ملف.\n# pip freeze > requirements.txt\n\n# 5. عند الانتهاء، قم بإلغاء تنشيط البيئة.\n# deactivate\n\nprint(\"الأوامر أعلاه مخصصة للطرفية الخاصة بك لإدارة تبعيات المشروع.\")",
        "quiz": [
          {
            "question": "ما هو الغرض الأساسي للبيئة الافتراضية؟",
            "options": ["لجعل الكود يعمل بشكل أسرع", "لعزل تبعيات المشروع وتجنب التعارضات", "لكتابة كود بايثون", "لمشاركة الكود الخاص بك عبر الإنترنت"],
            "correctAnswer": "لعزل تبعيات المشروع وتجنب التعارضات"
          },
          {
            "question": "ما هو `pip`؟",
            "options": ["محرر كود بايثون", "مدير إصدار بايثون", "مثبت الحزم القياسي لبايثون", "نوع من البيئة الافتراضية"],
            "correctAnswer": "مثبت الحزم القياسي لبايثون"
          },
          {
            "question": "أي أمر ينشئ بيئة افتراضية تسمى `venv`؟",
            "options": ["pip create venv", "python -m venv venv", "virtualenv create venv", "python new venv"],
            "correctAnswer": "python -m venv venv"
          },
          {
            "question": "ما هو الاسم الشائع للملف المستخدم لسرد تبعيات المشروع؟",
            "options": ["packages.json", "dependencies.yml", "pip.conf", "requirements.txt"],
            "correctAnswer": "requirements.txt"
          },
          {
            "question": "أي أمر يثبت جميع الحزم من ملف `requirements.txt`؟",
            "options": ["pip install all", "pip requirements.txt", "pip install -r requirements.txt", "pip load requirements.txt"],
            "correctAnswer": "pip install -r requirements.txt"
          }
        ],
        "pacing": "medium"
      },
      {
        "id": "26",
        "title": "مقدمة في الاختبار",
        "description": "فهم أهمية الاختبار وتعلم أساسيات إطار عمل `unittest` في بايثون.",
        "content": [
          "كتابة الكود الذي يعمل هو جزء من المهمة؛ ضمان أنه يعمل بشكل صحيح لا يقل أهمية. **الاختبار الآلي** هو ممارسة كتابة كود لاختبار كود التطبيق الخاص بك. يوفر هذا شبكة أمان، مما يضمن أن التغييرات الجديدة لا تكسر الوظائف الحالية (وهذا ما يسمى منع **التراجعات regressions**).",
          "تتضمن مكتبة بايثون القياسية إطار عمل **`unittest`** لكتابة الاختبارات. في حين توجد أطر عمل أخرى شائعة مثل `pytest`، فإن `unittest` مكان رائع للبدء.",
          "مع `unittest`، تقوم بإنشاء ملف اختبار (على سبيل المثال، `test_my_code.py`). في الداخل، تقوم بإنشاء فئة ترث من `unittest.TestCase`. كل اختبار فردي هو تابع داخل هذه الفئة يبدأ اسمه بـ `test_`.",
          "داخل كل تابع اختبار، تستخدم **توابع تأكيد (assertion methods)** خاصة (مثل `self.assertEqual()`، `self.assertTrue()`، `self.assertIn()`) للتحقق مما إذا كانت نتيجة الكود الخاص بك هي ما تتوقعه. إذا فشل تأكيد، يفشل الاختبار، ويبلغ إطار العمل عن الخطأ."
        ],
        "codeExample": "import unittest\n\n# دالة بسيطة نريد اختبارها\ndef add_numbers(a, b):\n    return a + b\n\n# فئة حالة اختبار لدالتنا\n# عادة ما يكون هذا في ملف منفصل مثل 'test_adder.py'\nclass TestAddNumbers(unittest.TestCase):\n\n    def test_two_positives(self):\n        \"\"\"اختبار إضافة رقمين موجبين.\"\"\"\n        self.assertEqual(add_numbers(5, 10), 15)\n\n    def test_one_negative(self):\n        \"\"\"اختبار إضافة رقم موجب وسالب.\"\"\"\n        self.assertEqual(add_numbers(5, -2), 3)\n\n    def test_two_negatives(self):\n        \"\"\"اختبار إضافة رقمين سالبين.\"\"\"\n        self.assertEqual(add_numbers(-5, -5), -10)\n\n# لتشغيل الاختبارات، ستستخدم عادةً سطر الأوامر:\n# python -m unittest test_adder.py\nprint(\"يوضح هذا المثال كيفية هيكلة حالة اختبار باستخدام unittest.\")",
        "quiz": [
          {
            "question": "لماذا الاختبار مهم في تطوير البرمجيات؟",
            "options": ["لجعل الكود أطول", "لضمان جودة الكود ومنع التراجعات", "لإبطاء التطوير", "لاستبدال التعليقات"],
            "correctAnswer": "لضمان جودة الكود ومنع التراجعات"
          },
          {
            "question": "ما هو اسم إطار عمل الاختبار المضمن في بايثون؟",
            "options": ["pytest", "nose2", "unittest", "doctest"],
            "correctAnswer": "unittest"
          },
          {
            "question": "في `unittest`، يجب أن تبدأ دوال الاختبار بـ...",
            "options": ["assert_", "check_", "test_", "verify_"],
            "correctAnswer": "test_"
          },
          {
            "question": "أي تأكيد `unittest` يتحقق مما إذا كانت قيمتان متساويتان؟",
            "options": ["assertTrue()", "assertIs()", "assertEqual()", "assertIn()"],
            "correctAnswer": "assertEqual()"
          },
          {
            "question": "يجب أن ترث فئات حالة الاختبار في `unittest` من أي فئة؟",
            "options": ["unittest.Test", "unittest.Suite", "unittest.Case", "unittest.TestCase"],
            "correctAnswer": "unittest.TestCase"
          }
        ],
        "pacing": "medium"
      },
      {
        "id": "27",
        "title": "تصحيح أخطاء كود بايثون",
        "description": "تعلم تقنيات وأدوات للعثور على الأخطاء وإصلاحها في الكود الخاص بك.",
        "content": [
          "بغض النظر عن مدى خبرتك، سيحتوي الكود الخاص بك على أخطاء. **تصحيح الأخطاء (Debugging)** هو المهارة الأساسية للعثور على هذه الأخطاء وإصلاحها. إتقان تصحيح الأخطاء سيوفر عليك ساعات لا تحصى من الإحباط.",
          "أبسط تقنية لتصحيح الأخطاء هي استخدام **عبارات `print()`**. يمكنك وضع `print(my_variable)` بشكل استراتيجي في الكود الخاص بك لمعرفة حالة متغيراتك في نقاط مختلفة ومعرفة أين سارت الأمور بشكل خاطئ. على الرغم من بساطتها، إلا أنها فعالة بشكل مدهش.",
          "للقضايا الأكثر تعقيدًا، تحتاج إلى أداة أكثر قوة: **مصحح الأخطاء (debugger)**. يسمى مصحح الأخطاء المدمج في بايثون **`pdb`**. يسمح لك بإيقاف تنفيذ برنامجك مؤقتًا عند نقطة معينة (تسمى **نقطة توقف breakpoint**).",
          "بمجرد التوقف، يمكنك التنقل في الكود سطراً بسطر، وفحص قيم جميع المتغيرات في تلك اللحظة، وتنفيذ الكود لمعرفة ما يحدث. يمنحك هذا رؤية أعمق بكثير لما يفعله برنامجك. يمكنك تعيين نقطة توقف في الكود الخاص بك عن طريق استيراد `pdb` ثم استدعاء `pdb.set_trace()`."
        ],
        "codeExample": "import pdb\n\ndef buggy_function(items):\n    total = 0\n    for item in items:\n        # لنقم بتعيين نقطة توقف هنا لفحص 'item' و 'total'\n        pdb.set_trace()\n        total += item\n    return total\n\n# عند تشغيل هذا، سيتوقف البرنامج مؤقتًا عند نقطة التوقف.\n# في الطرفية، يمكنك كتابة 'item' أو 'total' لرؤية قيمهما.\n# اكتب 'c' (continue) للخروج من مصحح الأخطاء وإنهاء البرنامج.\n\n# numbers = [10, '20', 30] # هذا سيسبب خطأ TypeError\n# print(buggy_function(numbers))\n\nprint(\"تسمح وحدة pdb بتصحيح الأخطاء التفاعلي. قم بإلغاء التعليق على الأسطر أعلاه لتجربتها.\")",
        "quiz": [
          {
            "question": "ما هو تصحيح الأخطاء؟",
            "options": ["كتابة كود جديد", "عملية العثور على الأخطاء وإصلاحها", "تحسين سرعة الكود", "التعليق على الكود"],
            "correctAnswer": "عملية العثور على الأخطاء وإصلاحها"
          },
          {
            "question": "ما هي أبسط تقنية لتصحيح الأخطاء؟",
            "options": ["استخدام مصحح أخطاء احترافي", "سؤال صديق", "استخدام عبارات `print()`", "إعادة كتابة الكود"],
            "correctAnswer": "استخدام عبارات `print()`"
          },
          {
            "question": "ما اسم وحدة تصحيح الأخطاء المضمنة في بايثون؟",
            "options": ["debug", "pdb", "pydebug", "debugger"],
            "correctAnswer": "pdb"
          },
          {
            "question": "ماذا تفعل `pdb.set_trace()`؟",
            "options": ["تطبع مكدس الاستدعاءات", "تنهي البرنامج", "تعين نقطة توقف وتبدأ مصحح الأخطاء", "تتجاهل جميع الأخطاء"],
            "correctAnswer": "تعين نقطة توقف وتبدأ مصحح الأخطاء"
          },
          {
            "question": "في مصحح الأخطاء، ماذا يعني 'التنقل عبر' الكود؟",
            "options": ["تنفيذ الكود ببطء شديد", "تنفيذ الكود سطرًا بسطر", "القفز إلى نهاية الدالة", "حذف أسطر من الكود"],
            "correctAnswer": "تنفيذ الكود سطرًا بسطر"
          }
        ],
        "pacing": "medium"
      },
      {
        "id": "28",
        "title": "أفضل ممارسات بايثون (PEP 8)",
        "description": "تعرف على PEP 8، دليل الأسلوب الرسمي لكود بايثون، لكتابة كود نظيف وقابل للقراءة.",
        "content": [
          "كتابة كود يعمل شيء؛ وكتابة كود نظيف وقابل للقراءة والصيانة شيء آخر. **PEP 8** (اقتراح تحسين بايثون 8) هو دليل الأسلوب الرسمي لكود بايثون. إنه يوفر مجموعة من الاصطلاحات التي يتبعها معظم مطوري بايثون.",
          "اتباع PEP 8 يجعل الكود الخاص بك أكثر اتساقًا وأسهل للقراءة والفهم من قبل مبرمجي بايثون الآخرين (بما في ذلك نفسك في المستقبل!). تشمل الإرشادات الرئيسية: **المسافة البادئة** يجب أن تكون 4 مسافات لكل مستوى. **طول السطر** يجب أن يقتصر على 79 حرفًا لتحسين القراءة.",
          "**اصطلاحات التسمية** مهمة أيضًا. استخدم `snake_case` للدوال والمتغيرات (على سبيل المثال، `my_variable`، `calculate_sum`). استخدم `PascalCase` (وتسمى أيضًا `CamelCase`) لأسماء الفئات (على سبيل المثال، `MyClass`). استخدم `UPPERCASE_SNAKE_CASE` للثوابت.",
          "يمكن لأدوات مثل المدققات (linters) (مثل `flake8`) والمنسقات التلقائية (auto-formatters) (مثل `black` أو `autopep8`) التحقق تلقائيًا من توافق الكود الخاص بك مع PEP 8 وحتى إصلاح العديد من المشكلات نيابة عنك. يعد دمج هذه الأدوات في سير عملك عادة رائعة يجب بناؤها."
        ],
        "codeExample": "# أسلوب PEP 8 جيد\n\nCONSTANT_VALUE = 3.14\n\ndef calculate_area(radius):\n    return CONSTANT_VALUE * radius * radius\n\nclass Circle:\n    def __init__(self, radius):\n        self.radius = radius\n\n    def get_area(self):\n        return calculate_area(self.radius)\n\nmy_circle = Circle(10)\nprint(f\"المساحة هي: {my_circle.get_area()}\")",
        "quiz": [
          {
            "question": "ما هو PEP 8؟",
            "options": ["اقتراح تحسين بايثون لميزة جديدة", "دليل الأسلوب الرسمي لكود بايثون", "مكتبة لتنسيق الكود", "إصدار من بايثون"],
            "correctAnswer": "دليل الأسلوب الرسمي لكود بايثون"
          },
          {
            "question": "وفقًا لـ PEP 8، ما هي الطريقة المفضلة للمسافة البادئة للكود؟",
            "options": ["مسافتان", "علامات تبويب", "4 مسافات", "8 مسافات"],
            "correctAnswer": "4 مسافات"
          },
          {
            "question": "ما هو اصطلاح التسمية الموصى به للدوال والمتغيرات؟",
            "options": ["camelCase", "PascalCase", "kebab-case", "snake_case"],
            "correctAnswer": "snake_case"
          },
          {
            "question": "ما هو اصطلاح التسمية الموصى به للفئات؟",
            "options": ["camelCase", "PascalCase (أو CamelCase)", "snake_case", "UPPER_CASE"],
            "correctAnswer": "PascalCase (أو CamelCase)"
          },
          {
            "question": "لماذا من المهم اتباع دليل أسلوب مثل PEP 8؟",
            "options": ["إنه مطلوب لتشغيل الكود", "يحسن قابلية قراءة الكود واتساقه", "يجعل الكود يعمل بشكل أسرع", "يضيف المزيد من الميزات إلى اللغة"],
            "correctAnswer": "يحسن قابلية قراءة الكود واتساقه"
          }
        ],
        "pacing": "medium"
      },
      {
        "id": "29",
        "title": "أساسيات التزامن",
        "description": "مقدمة في التزامن وكيفية استخدام الخيوط للمهام المتوازية.",
        "content": [
          "**التزامن (Concurrency)** هو مفهوم وجود مهام متعددة تعمل في فترات زمنية متداخلة. إنه يتعلق بالتعامل مع أشياء كثيرة في وقت واحد. هذا يختلف عن **التوازي (parallelism)**، وهو يتعلق بالقيام بأشياء كثيرة في نفس الوقت. التزامن هو الهيكل، والتوازي هو التنفيذ.",
          "في بايثون، الطريقة الشائعة لتحقيق التزامن هي باستخدام **الخيوط (threads)**. الخيط هو تدفق منفصل للتنفيذ. تسمح وحدة `threading` في المكتبة القياسية بإنشاء وإدارة الخيوط.",
          "تكون الخيوط أكثر فعالية للمهام **المرتبطة بالإدخال/الإخراج (I/O-bound)**. هذه هي المهام التي يقضي فيها البرنامج معظم وقته في انتظار مورد خارجي، مثل استجابة شبكة، أو استعلام قاعدة بيانات، أو قراءة ملف من القرص. بينما ينتظر خيط واحد، يمكن لمفسر بايثون التبديل إلى خيط آخر للقيام بعمل مفيد.",
          "بسبب قفل المفسر العالمي (GIL) في بايثون، فإن الخيوط ليست فعالة للمهام **المرتبطة بوحدة المعالجة المركزية (CPU-bound)** (حسابات رياضية ثقيلة)، حيث يمكن لخيط واحد فقط تنفيذ كود بايثون في كل مرة. لهذه المهام، تعد وحدة `multiprocessing` خيارًا أفضل."
        ],
        "codeExample": "import threading\nimport time\n\ndef fetch_data(name, delay):\n    print(f\"الخيط {name}: بدء جلب البيانات...\")\n    time.sleep(delay) # محاكاة طلب شبكة\n    print(f\"الخيط {name}: انتهى من الجلب.\")\n\n# إنشاء خيطين\nthread1 = threading.Thread(target=fetch_data, args=(\"API_1\", 2))\nthread2 = threading.Thread(target=fetch_data, args=(\"API_2\", 3))\n\nstart_time = time.time()\nprint(\"الرئيسي: بدء الخيوط.\")\n# بدء كلا الخيطين\nthread1.start()\nthread2.start()\n\n# انتظار اكتمال كلا الخيطين قبل المتابعة\nthread1.join()\nthread2.join()\nend_time = time.time()\n\nprint(f\"الرئيسي: انتهى كلا الخيطين في {end_time - start_time:.2f} ثانية.\")",
        "quiz": [
          {
            "question": "ما هو التزامن؟",
            "options": ["تشغيل الكود في نفس الوقت بالضبط", "القدرة على إدارة مهام متعددة في فترات زمنية متداخلة", "طريقة لكتابة الكود بشكل أسرع", "تقنية لتصحيح الأخطاء"],
            "correctAnswer": "القدرة على إدارة مهام متعددة في فترات زمنية متداخلة"
          },
          {
            "question": "أي وحدة نمطية تستخدم للخيوط في بايثون؟",
            "options": ["multiprocessing", "asyncio", "threading", "concurrent"],
            "correctAnswer": "threading"
          },
          {
            "question": "ماذا تفعل `thread.start()`؟",
            "options": ["تشغل دالة الهدف للخيط على الفور", "تجهز الخيط ليتم تشغيله", "تجدول الخيط ليتم تشغيله وتبدأ تنفيذه", "توقف الخيط"],
            "correctAnswer": "تجدول الخيط ليتم تشغيله وتبدأ تنفيذه"
          },
          {
            "question": "ما هو الغرض من `thread.join()`؟",
            "options": ["لدمج خيطين في واحد", "لإيقاف الخيط", "لجعل البرنامج الرئيسي ينتظر حتى ينهي الخيط تنفيذه", "لبدء الخيط"],
            "correctAnswer": "لجعل البرنامج الرئيسي ينتظر حتى ينهي الخيط تنفيذه"
          },
          {
            "question": "الخيوط هي الأكثر فعالة لأي نوع من المهام؟",
            "options": ["المهام المرتبطة بوحدة المعالجة المركزية (حسابات ثقيلة)", "المهام المرتبطة بالإدخال/الإخراج (انتظار الشبكة/القرص)", "جميع المهام على حد سواء", "فقط لطباعة النص"],
            "correctAnswer": "المهام المرتبطة بالإدخال/الإخراج (انتظار الشبكة/القرص)"
          }
        ],
        "pacing": "fast"
      },
      {
        "id": "30",
        "title": "المشروع النهائي: تجميع كل شيء معًا",
        "description": "طبق كل ما تعلمته لبناء مشروع صغير وكامل.",
        "content": [
          "تهانينا على وصولك إلى الدرس النهائي! حان الوقت الآن لتوحيد معرفتك وبناء شيء من الصفر. أفضل طريقة للتعلم هي بالممارسة، وهذا المشروع سوف يتحداك لدمج العديد من المفاهيم التي تعلمتها.",
          "فكرة مشروع رائعة هي تطبيق سطر أوامر، حيث يتيح لك التركيز على منطق بايثون دون الحاجة إلى واجهة مستخدم رسومية. بعض الأفكار تشمل: مدير قائمة مهام، دفتر جهات اتصال، متتبع ميزانية بسيط، أو تطبيق طقس يجلب البيانات من واجهة برمجة تطبيقات مجانية عبر الإنترنت.",
          "**تخطيط المشروع:** قبل كتابة أي كود، فكر في الهيكل. ما هي هياكل البيانات التي ستستخدمها؟ (على سبيل المثال، قائمة من القواميس لقائمة المهام). ما هي الدوال التي ستحتاجها؟ (على سبيل المثال، `add_task()`، `view_tasks()`، `save_to_file()`). كيف ستتعامل مع إدخال المستخدم؟ تعتبر حلقة `while` رائعة للحلقة الرئيسية للتطبيق.",
          "هذه هي فرصتك لتكون مبدعًا وتحل مشكلة، مهما كانت صغيرة. لا تخف من العودة إلى الدروس السابقة أو البحث عن مساعدة عبر الإنترنت. عملية بناء وتصحيح وإنهاء مشروع هي التجربة التعليمية الأكثر قيمة على الإطلاق. حظا سعيدا!"
        ],
        "codeExample": "# فكرة مشروع: مدير قائمة مهام بسيط\n\n# مهمتك: قم بتنفيذ الدوال أدناه لإنشاء تطبيق قائمة مهام عامل!\n\ndef display_menu():\n    print(\"\\n--- قائمة المهام ---\")\n    print(\"1. عرض المهام\")\n    print(\"2. إضافة مهمة\")\n    print(\"3. وضع علامة على المهمة كمكتملة\")\n    print(\"4. خروج\")\n\ndef view_tasks(tasks):\n    # TODO: قم بتنفيذ هذه الدالة\n    print(\"\\n--- مهامك ---\")\n    if not tasks:\n        print(\"لا توجد مهام بعد!\")\n    else:\n        for i, task in enumerate(tasks):\n            print(f\"{i+1}. {task}\")\n\ndef main():\n    tasks = [] # ابدأ بقائمة مهام فارغة\n    # تلميح: استخدم حلقة while للحفاظ على تشغيل البرنامج.\n    # تلميح: استخدم if/elif/else لاستدعاء الدالة الصحيحة بناءً على إدخال المستخدم.\n    print(\"هذه فرصتك لبناء شيء بنفسك!\")\n\n# لتشغيل التطبيق، ستقوم باستدعاء main()\n# main()",
        "quiz": [
          {
            "question": "أي بنية بيانات ستكون مناسبة لتخزين قائمة من جهات الاتصال، حيث يكون كل جهة اتصال مجموعة من المعلومات الخاصة بها؟",
            "options": ["قائمة بسيطة من النصوص", "قائمة من القواميس", "مجموعة", "صف"],
            "correctAnswer": "قائمة من القواميس"
          },
          {
            "question": "لحفظ بياناتك بحيث تستمر بعد إغلاق البرنامج، يجب عليك استخدام...",
            "options": ["المتغيرات", "إدخال/إخراج الملفات", "دوال لامدا", "المزخرفات"],
            "correctAnswer": "إدخال/إخراج الملفات"
          },
          {
            "question": "ما هو نوع الحلقة الأفضل للجزء الرئيسي من تطبيق سطر أوامر ينتظر أوامر المستخدم؟",
            "options": ["حلقة for على نطاق", "حلقة while تعمل حتى يختار المستخدم الخروج", "دالة map", "دالة تكرارية"],
            "correctAnswer": "حلقة while تعمل حتى يختار المستخدم الخروج"
          },
          {
            "question": "إذا كان تطبيقك يحصل على بيانات من خدمة طقس عبر الإنترنت، فماذا تستخدم؟",
            "options": ["قاعدة بيانات", "بيئة افتراضية", "واجهة برمجة تطبيقات (API)", "مزخرف"],
            "correctAnswer": "واجهة برمجة تطبيقات (API)"
          },
          {
            "question": "ما هو الجزء الأكثر أهمية في المشروع النهائي؟",
            "options": ["جعله يبدو جميلاً", "كتابته بأقل عدد من أسطر الكود", "تطبيق المفاهيم التي تعلمتها لحل مشكلة", "استخدام كل ميزة من الدورة"],
            "correctAnswer": "تطبيق المفاهيم التي تعلمتها لحل مشكلة"
          }
        ],
        "pacing": "fast"
      }
    ],
    "intermediate": [
      {
        "id": "31",
        "title": "هياكل البيانات المتقدمة: `collections`",
        "description": "تجاوز القوائم والقواميس مع هياكل البيانات القوية في وحدة `collections`.",
        "content": [
          "توفر وحدة `collections` أنواع بيانات حاويات متخصصة وعالية الأداء تعد بدائل للحاويات المدمجة للأغراض العامة في بايثون مثل `dict` و `list` و `set` و `tuple`.",
          "**`defaultdict`**: هذا يشبه القاموس العادي، لكنك توفر دالة مصنع افتراضية عند إنشائه. إذا حاولت الوصول إلى مفتاح غير موجود، فسيتم إنشاؤه تلقائيًا بالقيمة الافتراضية بدلاً من إثارة `KeyError`. هذا مفيد بشكل لا يصدق لتجميع العناصر أو عدها.",
          "**`Counter`**: `Counter` هو فئة فرعية من `dict` لعد الكائنات القابلة للهاش. إنها مجموعة يتم فيها تخزين العناصر كمفاتيح قاموس وتخزين عددها كقيم قاموس. إنه مثالي لإحصاء العناصر في قائمة.",
          "**`deque`**: `deque` (تُنطق 'ديك') هي قائمة انتظار مزدوجة النهاية. إنها مثل قائمة ولكنها توفر إضافات وحذف سريعة من كلا الطرفين. وهذا يجعلها مثالية لتنفيذ قوائم الانتظار والمكدسات حيث تحتاج إلى إضافات وعمليات إزالة فعالة من بداية ونهاية التسلسل."
        ],
        "codeExample": "from collections import defaultdict, Counter, deque\n\n# مثال defaultdict\ns = [('yellow', 1), ('blue', 2), ('yellow', 3), ('blue', 4), ('red', 1)]\nd = defaultdict(list)\nfor k, v in s:\n    d[k].append(v)\nprint(f\"defaultdict: {sorted(d.items())}\")\n\n# مثال Counter\nword_list = ['red', 'blue', 'red', 'green', 'blue', 'blue']\ncounts = Counter(word_list)\nprint(f\"Counter: {counts}\")\n\n# مثال deque\nq = deque(['Eric', 'John', 'Michael'])\nq.append('Terry')\nq.appendleft('Graham')\nprint(f\"deque: {q}\")\nprint(f\"عنصر محذوف من اليسار: {q.popleft()}\")",
        "quiz": [
          {
            "question": "ما هي الفائدة الأساسية لـ `defaultdict`؟",
            "options": ["إنه أسرع من القاموس العادي", "يمنع `KeyError` من خلال توفير قيمة افتراضية للمفاتيح المفقودة", "يمكنه تخزين الأعداد الصحيحة فقط", "يحافظ على ترتيب الإدخال"],
            "correctAnswer": "يمنع `KeyError` من خلال توفير قيمة افتراضية للمفاتيح المفقودة"
          },
          {
            "question": "أي فئة `collections` هي الأنسب لإحصاء تكرار العناصر في قائمة؟",
            "options": ["deque", "defaultdict", "Counter", "namedtuple"],
            "correctAnswer": "Counter"
          },
          {
            "question": "ماذا تعني `deque`؟",
            "options": ["قائمة انتظار مزينة", "قائمة انتظار مزدوجة النهاية", "قائمة انتظار افتراضية", "قائمة انتظار ديناميكية"],
            "correctAnswer": "قائمة انتظار مزدوجة النهاية"
          },
          {
            "question": "إذا كنت بحاجة إلى عمليات إضافة وحذف سريعة من بداية ونهاية التسلسل، فما هو هيكل البيانات الأكثر كفاءة؟",
            "options": ["list", "tuple", "deque", "set"],
            "correctAnswer": "deque"
          },
          {
            "question": "ماذا سينتج عن الوصول إلى مفتاح غير موجود في `defaultdict(int)`؟",
            "options": ["KeyError", "قيمة None", "قيمة 0", "TypeError"],
            "correctAnswer": "قيمة 0"
          }
        ],
        "pacing": "medium"
      },
      {
        "id": "32",
        "title": "فك الوسائط المتقدم: `*args` و `**kwargs`",
        "description": "إتقان كتابة دوال مرنة يمكنها قبول عدد متغير من الوسائط.",
        "content": [
          "لقد تعلمت كيفية تعريف الدوال بعدد ثابت من الوسائط. ولكن ماذا لو كنت ترغب في إنشاء دالة يمكنها قبول أي عدد من الوسائط الموضعية أو الكلمات المفتاحية؟ هنا يأتي دور `*args` و `**kwargs`.",
          "**`*args` (الوسائط)**: يسمح لك بناء الجملة `*args` في تعريف الدالة بتمرير عدد متغير من الوسائط الموضعية. داخل الدالة، سيكون `args` عبارة عن صف (tuple) يحتوي على جميع الوسائط الموضعية التي تم تمريرها.",
          "**`**kwargs` (وسائط الكلمات المفتاحية)**: يسمح لك بناء الجملة `**kwargs` بتمرير عدد متغير من وسائط الكلمات المفتاحية. داخل الدالة، سيكون `kwargs` عبارة عن قاموس يحتوي على جميع وسائط الكلمات المفتاحية التي تم تمريرها، مع أسماء الوسائط كمفاتيح.",
          "يمكنك أيضًا استخدام عاملي `*` و `**` عند استدعاء دالة لـ 'فك' قائمة/صف أو قاموس إلى وسائط موضعية أو كلمات مفتاحية، على التوالي. هذه ميزة قوية لتمرير الوسائط برمجيًا."
        ],
        "codeExample": "# دالة تستخدم *args و **kwargs\ndef flexible_function(*args, **kwargs):\n    print(f\"الوسائط الموضعية (args): {args}\")\n    print(f\"وسائط الكلمات المفتاحية (kwargs): {kwargs}\")\n\n# استدعاء الدالة بوسائط مختلفة\nflexible_function(1, 2, 3, name=\"Alice\", age=30)\n\n# فك قائمة وقاموس\nmy_list = ['a', 'b']\nmy_dict = {'x': 100, 'y': 200}\n\n# هذا يعادل flexible_function('a', 'b', x=100, y=200)\nflexible_function(*my_list, **my_dict)",
        "quiz": [
          {
            "question": "في تعريف دالة، ما هو نوع كائن `*args`؟",
            "options": ["قائمة", "صف", "قاموس", "مجموعة"],
            "correctAnswer": "صف"
          },
          {
            "question": "في تعريف دالة، ما هو نوع كائن `**kwargs`؟",
            "options": ["قائمة", "صف", "قاموس", "مجموعة"],
            "correctAnswer": "قاموس"
          },
          {
            "question": "ما هو الغرض الأساسي من `*args`؟",
            "options": ["لقبول وسائط كلمات مفتاحية فقط", "لقبول عدد متغير من الوسائط الموضعية", "لقبول وسيطين فقط", "لفك قاموس عند استدعاء دالة"],
            "correctAnswer": "لقبول عدد متغير من الوسائط الموضعية"
          },
          {
            "question": "إذا قمت باستدعاء `my_func(name='Bob', age=40)`، ماذا سيكون `kwargs` داخل `def my_func(**kwargs):`؟",
            "options": ["('name', 'age')", "{'name': 'Bob', 'age': 40}", "['Bob', 40]", "{'Bob': 'name', 40: 'age'}"],
            "correctAnswer": "{'name': 'Bob', 'age': 40}"
          },
          {
            "question": "أسماء 'args' و 'kwargs' إلزامية.",
            "options": ["صحيح", "خطأ"],
            "correctAnswer": "خطأ"
          }
        ],
        "pacing": "medium"
      },
      {
        "id": "33",
        "title": "مديرو السياق وعبارة `with`",
        "description": "تعلم كيفية إدارة الموارد بشكل صحيح مثل الملفات واتصالات الشبكة باستخدام عبارة `with`.",
        "content": [
          "لقد استخدمت بالفعل عبارة `with` للتعامل مع الملفات. هذا مثال على **مدير السياق**. مدير السياق هو كائن يحدد سياقًا مؤقتًا لمجموعة من التعليمات البرمجية، مما يضمن الحصول على الموارد وتحريرها بشكل صحيح.",
          "الفائدة الأساسية هي إدارة الموارد. عند الدخول في كتلة `with`، يتم استدعاء تابع `__enter__` لمدير السياق. عند الخروج من الكتلة (إما بشكل طبيعي أو من خلال استثناء)، يتم استدعاء تابع `__exit__`. هذا يضمن أن كود التنظيف (مثل إغلاق ملف أو اتصال قاعدة بيانات) يتم تنفيذه دائمًا.",
          "بينما تعد الملفات المثال الأكثر شيوعًا، يمكنك إنشاء مديري سياق خاصين بك. يمكنك القيام بذلك عن طريق تعريف فئة باستخدام تابعي `__enter__` و `__exit__`، أو بسهولة أكبر باستخدام المزخرف `@contextmanager` من وحدة `contextlib` على دالة مولد.",
          "فهم مديري السياق أمر بالغ الأهمية لكتابة كود بايثون قوي لا يسرب الموارد."
        ],
        "codeExample": "from contextlib import contextmanager\n\n# مدير سياق بسيط يعتمد على المولد\n@contextmanager\ndef simple_timer(name):\n    import time\n    print(f\"الدخول إلى المؤقت '{name}'...\")\n    start_time = time.time()\n    try:\n        yield\n    finally:\n        end_time = time.time()\n        print(f\"الخروج من المؤقت '{name}'. المدة: {end_time - start_time:.2f} ثانية\")\n\n# استخدام مدير السياق\nwith simple_timer(\"My Task\"):\n    print(\"القيام ببعض العمل...\")\n    # محاكاة مهمة تستغرق ثانية واحدة\n    time.sleep(1)",
        "quiz": [
          {
            "question": "ما هو الغرض الأساسي لمدير السياق؟",
            "options": ["لتوقيت تنفيذ الكود", "لتبسيط استدعاءات الدوال", "لإدارة الموارد وضمان التنظيف", "لإنشاء أنواع بيانات جديدة"],
            "correctAnswer": "لإدارة الموارد وضمان التنظيف"
          },
          {
            "question": "ما هما التابعان الخاصان اللذان يجب على مدير السياق المستند إلى الفئة تنفيذهما؟",
            "options": ["__start__ و __stop__", "__begin__ و __end__", "__enter__ و __exit__", "__init__ و __del__"],
            "correctAnswer": "__enter__ و __exit__"
          },
          {
            "question": "أي تابع لمدير السياق يتم استدعاؤه عند الخروج من كتلة `with`؟",
            "options": ["__exit__", "__enter__", "__del__", "__close__"],
            "correctAnswer": "__exit__"
          },
          {
            "question": "هل يتم استدعاء تابع `__exit__` إذا حدث استثناء داخل كتلة `with`؟",
            "options": ["نعم", "لا"],
            "correctAnswer": "نعم"
          },
          {
            "question": "أي وحدة توفر المزخرف `@contextmanager`؟",
            "options": ["context", "managers", "withtools", "contextlib"],
            "correctAnswer": "contextlib"
          }
        ],
        "pacing": "fast"
      },
      {
        "id": "34",
        "title": "البرمجة الشيئية المتقدمة: الخصائص",
        "description": "تحكم في الوصول إلى السمات باستخدام مزخرف `property` في بايثون لكتابة فئات أنظف وأكثر قابلية للصيانة.",
        "content": [
          "في بعض الأحيان تريد إضافة منطق عند الحصول على قيمة سمة أو تعيينها أو حذفها. يمكنك إنشاء توابع getter و setter صريحة (على سبيل المثال، `get_name()`، `set_name()`)، ولكن هذا يمكن أن يجعل الكود غير عملي. يوفر مزخرف `property` في بايثون طريقة أكثر 'بايثونية'.",
          "يسمح لك المزخرف `@property` بتحويل تابع فئة إلى 'getter' لسمة. هذا يعني أنه يمكنك استدعاء التابع بدون أقواس، تمامًا مثل الوصول إلى سمة عادية، ولكن سيتم تشغيل منطق مخصص خلف الكواليس.",
          "لإنشاء 'setter' لهذه الخاصية، تستخدم مزخرفًا آخر يسمى على اسم تابع getter، مثل `@my_property.setter`. سيتم استدعاء هذا التابع كلما حاول شخص ما تعيين قيمة للسمة (على سبيل المثال، `obj.my_property = value`). هذا هو المكان المثالي لإضافة منطق التحقق من الصحة.",
          "يسمح لك استخدام الخصائص بالبدء بسمات عامة بسيطة ثم إضافة منطق getter/setter لاحقًا دون تغيير واجهة برمجة التطبيقات العامة لفئتك، وهو أمر رائع للصيانة."
        ],
        "codeExample": "class Product:\n    def __init__(self, price):\n        self._price = price # لاحظ الشرطة السفلية للسمة 'الخاصة'\n\n    @property\n    def price(self):\n        \"\"\"هذا هو تابع 'getter'.\"\"\"\n        return self._price\n\n    @price.setter\n    def price(self, value):\n        \"\"\"هذا هو تابع 'setter' مع التحقق من الصحة.\"\"\"\n        if value < 0:\n            raise ValueError(\"لا يمكن أن يكون السعر سالبًا.\")\n        self._price = value\n\n# إنشاء منتج\nshirt = Product(20)\n\n# الوصول إلى السعر باستخدام getter (بدون أقواس)\nprint(f\"السعر هو: ${shirt.price}\")\n\n# تغيير السعر باستخدام setter\nshirt.price = 25\nprint(f\"السعر الجديد هو: ${shirt.price}\")\n\n# هذا سيثير ValueError\ntry:\n    shirt.price = -10\nexcept ValueError as e:\n    print(f\"خطأ: {e}\")",
        "quiz": [
          {
            "question": "أي مزخرف يستخدم لإنشاء تابع 'getter' لسمة؟",
            "options": ["@getter", "@property", "@get", "@attribute"],
            "correctAnswer": "@property"
          },
          {
            "question": "كيف تحدد 'setter' لخاصية تسمى `value`؟",
            "options": ["@setter(value)", "@value.setter", "@set.value", "def set_value(self, new_val):"],
            "correctAnswer": "@value.setter"
          },
          {
            "question": "ما هي الفائدة الرئيسية لاستخدام الخصائص؟",
            "options": ["إنها تجعل الكود يعمل بشكل أسرع.", "تسمح لك بإضافة منطق (مثل التحقق من الصحة) إلى الوصول إلى السمات.", "تجعل السمات خاصة.", "إنها مطلوبة لجميع الفئات."],
            "correctAnswer": "تسمح لك بإضافة منطق (مثل التحقق من الصحة) إلى الوصول إلى السمات."
          },
          {
            "question": "إذا كانت فئة تحتوي على خاصية تسمى `temperature`، كيف تصل إلى getter الخاص بها؟",
            "options": ["obj.temperature()", "obj.get_temperature()", "obj.temperature", "property.get(obj, 'temperature')"],
            "correctAnswer": "obj.temperature"
          },
          {
            "question": "من الشائع تسمية السمة المخزنة الفعلية بشرطة سفلية بادئة (على سبيل المثال، `_price`). لماذا؟",
            "options": ["إنه شرط لعمل الخصائص.", "يشير إلى المطورين الآخرين أن هذه السمة مخصصة للاستخدام الداخلي.", "يجعل السمة خاصة حقًا.", "يحسن الأداء."],
            "correctAnswer": "يشير إلى المطورين الآخرين أن هذه السمة مخصصة للاستخدام الداخلي."
          }
        ],
        "pacing": "fast"
      },
      {
        "id": "35",
        "title": "البرمجة الشيئية المتقدمة: التوابع السحرية",
        "description": "خصص سلوك فئاتك عن طريق تنفيذ توابع 'dunder' الخاصة ببايثون.",
        "content": [
          "التوابع السحرية، المعروفة أيضًا باسم توابع 'dunder' (شرطة سفلية مزدوجة)، هي توابع خاصة يمكنك تعريفها في فئاتك تبدأ وتنتهي بشرطتين سفليتين (على سبيل المثال، `__init__`، `__len__`). ليس من المفترض استدعاؤها مباشرة. بدلاً من ذلك، يستدعيها بايثون نيابة عنك استجابة لعمليات محددة.",
          "على سبيل المثال، عند استخدام عامل `+` على كائنين، يستدعي بايثون تابع `__add__`. عندما تستدعي `len(my_object)`، يستدعي بايثون `my_object.__len__()`. عندما تقوم بـ `print(my_object)`، يستدعي بايثون `my_object.__str__()`.",
          "من خلال تنفيذ هذه التوابع، يمكنك جعل كائناتك المخصصة تتصرف مثل الأنواع المضمنة. هذا يسمح لك بدمج كائناتك بسلاسة أكبر في لغة بايثون، مما يجعلها أكثر سهولة في الاستخدام.",
          "تشمل التوابع السحرية الشائعة `__str__` لتمثيل نصي سهل الاستخدام، `__repr__` لتمثيل لا لبس فيه وصديق للمطورين، `__len__` للطول، وتوابع المقارنة مثل `__eq__` (==)، `__lt__` (<)، إلخ."
        ],
        "codeExample": "class Vector:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def __repr__(self):\n        \"\"\"تمثيل لا لبس فيه، للمطورين.\"\"\"\n        return f\"Vector({self.x}, {self.y})\"\n\n    def __str__(self):\n        \"\"\"تمثيل سهل الاستخدام.\"\"\"\n        return f\"({self.x}, {self.y})\"\n\n    def __add__(self, other):\n        \"\"\"يحدد السلوك لعامل '+'.\"\"\"\n        return Vector(self.x + other.x, self.y + other.y)\n\nv1 = Vector(2, 3)\nv2 = Vector(3, 4)\n\n# يتم استدعاء __add__\nv3 = v1 + v2\n\n# يتم استدعاء __str__ بواسطة print()\nprint(f\"{v1} + {v2} = {v3}\")\n\n# يتم استدعاء __repr__ عند فحص الكائن\nprint(repr(v3))",
        "quiz": [
          {
            "question": "ما هو الاسم الآخر لـ 'التوابع السحرية'؟",
            "options": ["التوابع الخاصة", "توابع Dunder", "التوابع الخاصة", "كلاهما B و C"],
            "correctAnswer": "كلاهما B و C"
          },
          {
            "question": "أي تابع سحري يتم استدعاؤه عند استخدام دالة `len()` على كائن؟",
            "options": ["__length__", "__size__", "__len__", "__count__"],
            "correctAnswer": "__len__"
          },
          {
            "question": "ما هو الغرض الأساسي من تابع `__str__`؟",
            "options": ["لتوفير تمثيل رسمي لا لبس فيه للمطورين.", "لتحديد طول الكائن.", "لتوفير تمثيل نصي قابل للقراءة وسهل الاستخدام.", "لتحويل الكائن إلى نص للتخزين في ملف."],
            "correctAnswer": "لتوفير تمثيل نصي قابل للقراءة وسهل الاستخدام."
          },
          {
            "question": "لإعادة تحميل عامل `==` لفئتك المخصصة، أي تابع يجب عليك تنفيذه؟",
            "options": ["__equals__", "__is_equal__", "__eq__", "__compare__"],
            "correctAnswer": "__eq__"
          },
          {
            "question": "هل يتم استدعاء التوابع السحرية عادةً بشكل مباشر (على سبيل المثال، `my_object.__add__(other)`)؟",
            "options": ["نعم، دائمًا", "لا، يستدعيها بايثون ضمنيًا بناءً على العملية التي يتم إجراؤها"],
            "correctAnswer": "لا، يستدعيها بايثون ضمنيًا بناءً على العملية التي يتم إجراؤها"
          }
        ],
        "pacing": "fast"
      },
      {
        "id": "36",
        "title": "الاختبار باستخدام `pytest`",
        "description": "ارتق بمهاراتك في الاختبار مع `pytest`، وهو إطار عمل اختبار قوي وشائع.",
        "content": [
          "في حين أن `unittest` مدمج، يفضل العديد من المطورين `pytest` لبنائه الأبسط، وميزاته القوية، ونظام الإضافات الواسع. يجعل `pytest` كتابة الاختبارات أسرع وأكثر متعة.",
          "يستخدم `pytest` عبارات `assert` العادية بدلاً من توابع `self.assertEqual()` من `unittest`. هذا يجعل الاختبارات أكثر إيجازًا وقابلية للقراءة. `pytest` ذكي بما يكفي لفحص عبارة `assert` وتوفير مخرجات مفصلة حول ما فشل.",
          "إحدى أقوى ميزات pytest هي **fixtures**. fixture هي دالة توفر أساسًا ثابتًا من البيانات أو حالة نظام لاختباراتك. يمكنك إعادة استخدام fixtures عبر اختبارات متعددة، مما يجعل إعداد الاختبار أنظف وأكثر قابلية للصيانة.",
          "للبدء، تحتاج فقط إلى `pip install pytest` ثم كتابة ملفات اختبار (على سبيل المثال، `test_something.py`) مع دوال اختبار (على سبيل المثال، `def test_addition():`). سيكتشف `pytest` ويشغل اختباراتك تلقائيًا."
        ],
        "codeExample": "# ستحتاج إلى تشغيل 'pip install pytest' أولاً.\n# سيكون هذا الكود في ملف مثل 'test_calculation.py'.\n\n# دالة نريد اختبارها\ndef add(a, b):\n    return a + b\n\n# دالة اختبار pytest بسيطة\ndef test_add_positive_numbers():\n    # يستخدم pytest عبارة assert عادية\n    assert add(2, 3) == 5\n\ndef test_add_negative_numbers():\n    assert add(-1, -1) == -2\n\n# لتشغيل الاختبارات، ستنتقل إلى الدليل في الطرفية الخاصة بك\n# وتشغل الأمر ببساطة: pytest\nprint(\"يبسط pytest كتابة الاختبارات باستخدام عبارات assert العادية.\")",
        "quiz": [
          {
            "question": "ماذا يستخدم `pytest` للتأكيدات؟",
            "options": ["`self.assertEqual()`", "`self.assertTrue()`", "الكلمة المفتاحية `assert` العادية", "`check.equals()`"],
            "correctAnswer": "الكلمة المفتاحية `assert` العادية"
          },
          {
            "question": "بشكل افتراضي، يبحث `pytest` عن ملفات الاختبار بأي نمط تسمية؟",
            "options": ["`test_*.py` أو `*_test.py`", "`check_*.py`", "`test.py`", "`*.test.py`"],
            "correctAnswer": "`test_*.py` أو `*_test.py`"
          },
          {
            "question": "ما هو استخدام `pytest` fixture؟",
            "options": ["لتوقيت تنفيذ الاختبار", "لتوفير إعداد/تفكيك قابل لإعادة الاستخدام للاختبارات (مثل البيانات والاتصالات)", "لتنسيق مخرجات الاختبار", "لتشغيل الاختبارات بالتوازي"],
            "correctAnswer": "لتوفير إعداد/تفكيك قابل لإعادة الاستخدام للاختبارات (مثل البيانات والاتصالات)"
          },
          {
            "question": "أي أمر يستخدم عادة لتشغيل جميع الاختبارات في مشروع؟",
            "options": ["`run-pytest`", "`python -m unittest`", "`pytest`", "`python test`"],
            "correctAnswer": "`pytest`"
          },
          {
            "question": "مقارنة بـ `unittest`، يؤدي `pytest` عمومًا إلى...",
            "options": ["كود اختبار أكثر تفصيلاً", "كود اختبار أقل قابلية للقراءة", "كود اختبار أكثر إيجازًا وقابلية للقراءة", "ميزات أقل"],
            "correctAnswer": "كود اختبار أكثر إيجازًا وقابلية للقراءة"
          }
        ],
        "pacing": "medium"
      },
      {
        "id": "37",
        "title": "العمل مع ملفات CSV",
        "description": "تعلم قراءة وكتابة بيانات القيم المفصولة بفواصل (CSV)، وهو تنسيق شائع لتبادل البيانات.",
        "content": [
          "CSV (القيم المفصولة بفواصل) هو تنسيق نصي بسيط ومنتشر في كل مكان لتخزين البيانات الجدولية (مثل جداول البيانات أو سجلات قاعدة البيانات). يمثل كل سطر في ملف CSV صفًا، مع فصل القيم في ذلك الصف بفاصلة.",
          "تتضمن مكتبة بايثون القياسية وحدة `csv` لجعل العمل مع هذه الملفات سهلاً وقويًا. إنها تتعامل بشكل صحيح مع حالات الحافة المختلفة، مثل القيم التي تحتوي على فواصل أو فواصل أسطر بداخلها.",
          "لقراءة ملف CSV، تستخدم عادةً `csv.reader` الذي يمنحك مكررًا ينتج كل صف كقائمة من السلاسل النصية. للحصول على نهج أكثر ملاءمة، يعامل `csv.DictReader` كل صف كقاموس، باستخدام صف الرأس كمفاتيح.",
          "لكتابة البيانات، تستخدم `csv.writer` وتوابع `writerow` أو `writerows` الخاصة به. وبالمثل، يتيح لك `csv.DictWriter` كتابة قائمة من القواميس، والتي يمكن أن تكون مريحة للغاية. تحتاج فقط إلى التأكد من فتح الملف باستخدام `newline=''` لتجنب صفوف فارغة إضافية في المخرجات الخاصة بك."
        ],
        "codeExample": "import csv\n\n# --- الكتابة إلى ملف CSV ---\nheaders = ['name', 'department', 'birth_month']\ndata = [\n    {'name': 'John Smith', 'department': 'Accounting', 'birth_month': 'November'},\n    {'name': 'Erica Meyers', 'department': 'IT', 'birth_month': 'March'}\n]\n\nwith open('employees.csv', 'w', newline='') as f:\n    writer = csv.DictWriter(f, fieldnames=headers)\n    writer.writeheader()\n    writer.writerows(data)\n\nprint(\"تم إنشاء employees.csv.\")\n\n# --- القراءة من ملف CSV ---\nprint(\"\\nالقراءة من employees.csv:\")\nwith open('employees.csv', 'r') as f:\n    reader = csv.DictReader(f)\n    for row in reader:\n        print(dict(row))",
        "quiz": [
          {
            "question": "ماذا تعني CSV؟",
            "options": ["قيم نظام الكمبيوتر", "القيم المفصولة بفواصل", "التحقق من نمط الكود", "القيم المشتركة الشائعة"],
            "correctAnswer": "القيم المفصولة بفواصل"
          },
          {
            "question": "أي دالة من وحدة `csv` تستخدم لقراءة ملف CSV صفًا بصف في قواميس؟",
            "options": ["csv.reader", "csv.read", "csv.DictReader", "csv.read_dict"],
            "correctAnswer": "csv.DictReader"
          },
          {
            "question": "لماذا من المهم فتح الملف باستخدام `newline=''` عند كتابة CSV؟",
            "options": ["لتحسين الأداء", "لمنع وحدة `csv` من إضافة صفوف فارغة إضافية", "لتشفير الملف", "ليس مهمًا"],
            "correctAnswer": "لمنع وحدة `csv` من إضافة صفوف فارغة إضافية"
          },
          {
            "question": "ماذا يأخذ تابع `writerow` لكائن `csv.writer` كوسيط؟",
            "options": ["قاموس", "سلسلة نصية واحدة", "كائن قابل للتكرار (مثل قائمة أو صف)", "عدد صحيح"],
            "correctAnswer": "كائن قابل للتكرار (مثل قائمة أو صف)"
          },
          {
            "question": "ماذا يفعل `csv.DictWriter.writeheader()`؟",
            "options": ["يكتب صفوف البيانات إلى الملف", "يكتب الصف الأول من ملف CSV باستخدام أسماء الحقول المقدمة", "يقرأ الرأس من الملف", "يغلق الملف"],
            "correctAnswer": "يكتب الصف الأول من ملف CSV باستخدام أسماء الحقول المقدمة"
          }
        ],
        "pacing": "medium"
      },
      {
        "id": "38",
        "title": "العمل مع التواريخ والأوقات: `datetime`",
        "description": "إتقان وحدة `datetime` للتعامل مع التواريخ والأوقات وحسابات الوقت في بايثون.",
        "content": [
          "يعد العمل مع التواريخ والأوقات مهمة شائعة في البرمجة. توفر وحدة `datetime` في بايثون، وهي جزء من المكتبة القياسية، فئات قوية لمعالجة التواريخ والأوقات.",
          "الفئات الرئيسية التي ستتعامل معها هي: `date` (للسنة والشهر واليوم)، `time` (للساعة والدقيقة والثانية والميكروثانية)، `datetime` (تجمع بين التاريخ والوقت)، و `timedelta` (لتمثيل مدة أو فرق بين تاريخين/وقتين).",
          "يمكنك الحصول على التاريخ والوقت الحاليين باستخدام `datetime.now()`. يمكنك إجراء عمليات حسابية باستخدام كائنات التاريخ والوقت، على سبيل المثال، عن طريق إضافة `timedelta` إلى `datetime` للعثور على تاريخ مستقبلي.",
          "جزء حاسم من العمل مع التواريخ هو تحليلها من السلاسل النصية وتنسيقها إلى سلاسل نصية. يتم استخدام تابع `strptime()` (string parse time) لتحويل سلسلة نصية إلى كائن `datetime`، ويقوم `strftime()` (string format time) بالعكس. يستخدم كلاهما رموز تنسيق خاصة (مثل `%Y` لسنة مكونة من 4 أرقام، `%m` للشهر، `%d` لليوم) لتحديد التنسيق."
        ],
        "codeExample": "from datetime import datetime, timedelta\n\n# الحصول على الوقت الحالي\nnow = datetime.now()\nprint(f\"التاريخ والوقت الحالي: {now}\")\n\n# تنسيق التاريخ والوقت إلى سلسلة نصية قابلة للقراءة\nformatted_string = now.strftime(\"%A, %B %d, %Y %I:%M %p\")\nprint(f\"السلسلة المنسقة: {formatted_string}\")\n\n# حساب تاريخ مستقبلي\nthree_weeks_from_now = now + timedelta(weeks=3)\nprint(f\"بعد ثلاثة أسابيع من الآن سيكون: {three_weeks_from_now.date()}\")\n\n# تحليل سلسلة نصية إلى كائن datetime\ndate_string = \"2023-01-20\"\ndate_object = datetime.strptime(date_string, \"%Y-%m-%d\")\nprint(f\"كائن التاريخ المحلل: {date_object}\")",
        "quiz": [
          {
            "question": "أي فئة `datetime` تمثل مدة زمنية؟",
            "options": ["date", "time", "datetime", "timedelta"],
            "correctAnswer": "timedelta"
          },
          {
            "question": "أي تابع يحول كائن `datetime` إلى سلسلة نصية منسقة؟",
            "options": ["strftime()", "strptime()", "format()", "parse()"],
            "correctAnswer": "strftime()"
          },
          {
            "question": "أي تابع يحلل سلسلة نصية إلى كائن `datetime`؟",
            "options": ["strftime()", "strptime()", "format()", "parse()"],
            "correctAnswer": "strptime()"
          },
          {
            "question": "ماذا يمثل رمز التنسيق `%Y` في `strftime`/`strptime`؟",
            "options": ["سنة مكونة من رقمين", "يوم السنة", "سنة مكونة من أربعة أرقام", "السنة المختصرة"],
            "correctAnswer": "سنة مكونة من أربعة أرقام"
          },
          {
            "question": "كيف يمكنك الحصول على التاريخ والوقت المحليين الحاليين؟",
            "options": ["datetime.now()", "datetime.today()", "datetime.current()", "يمكن استخدام كل من A و B"],
            "correctAnswer": "datetime.now()"
          }
        ],
        "pacing": "medium"
      },
      {
        "id": "39",
        "title": "تغليف مشروع بايثون الخاص بك",
        "description": "تعلم كيفية تغليف كود بايثون الخاص بك بحيث يمكن توزيعه وتثبيته من قبل الآخرين باستخدام `pip`.",
        "content": [
          "لقد كتبت نصًا برمجيًا أو مكتبة بايثون مفيدة. كيف تشاركها مع الآخرين حتى يتمكنوا من تثبيتها واستخدامها بسهولة؟ الجواب هو التغليف.",
          "يدور تغليف بايثون الحديث حول ملف `pyproject.toml`. هذا الملف هو المعيار الجديد لتكوين نظام بناء مشروعك والبيانات الوصفية (مثل اسم المشروع والإصدار والمؤلف والتبعيات).",
          "تتضمن العملية بشكل عام: 1) تنظيم الكود الخاص بك في تخطيط قياسي (على سبيل المثال، وضع كود المصدر الخاص بك في دليل `src`). 2) إنشاء ملف `pyproject.toml` لتعريف مشروعك. 3) استخدام أداة بناء مثل `build` لإنشاء حزم توزيع (عادةً ملف 'wheel' و 'توزيع مصدر').",
          "بمجرد حصولك على ملفات التوزيع هذه، يمكنك تحميلها إلى فهرس حزم بايثون (PyPI)، وهو مستودع البرامج الرسمي لجهات خارجية لبايثون. بعد ذلك، يمكن لأي شخص في العالم تثبيت الحزمة الخاصة بك عن طريق تشغيل `pip install your-package-name`."
        ],
        "codeExample": "# هذا ليس كود بايثون، ولكنه محتوى ملف pyproject.toml.\n\n# [build-system]\n# requires = [\"hatchling\"]\n# build-backend = \"hatchling.build\"\n# \n# [project]\n# name = \"my-awesome-package\"\n# version = \"0.0.1\"\n# authors = [\n#   { name=\"Your Name\", email=\"you@example.com\" },\n# ]\n# description = \"A small example package\"\n# requires-python = \">=3.8\"\n# classifiers = [\n#     \"Programming Language :: Python :: 3\",\n#     \"License :: OSI Approved :: MIT License\",\n#     \"Operating System :: OS Independent\",\n# ]\n\nprint(\"يتم تكوين التغليف من خلال ملف 'pyproject.toml'.\")\nprint(\"ستستخدم أدوات سطر الأوامر مثل 'pip install build' و 'python -m build' لإنشاء حزم.\")",
        "quiz": [
          {
            "question": "ما هو ملف التكوين القياسي الحديث لحزمة بايثون؟",
            "options": ["`setup.py`", "`requirements.txt`", "`pyproject.toml`", "`package.json`"],
            "correctAnswer": "`pyproject.toml`"
          },
          {
            "question": "ما هو PyPI؟",
            "options": ["واجهة برمجة بايثون", "مدقق كود بايثون", "فهرس حزم بايثون الرسمي لبرامج الجهات الخارجية", "مدير بيئة افتراضية لبايثون"],
            "correctAnswer": "فهرس حزم بايثون الرسمي لبرامج الجهات الخارجية"
          },
          {
            "question": "أي تنسيق ملف هو تنسيق التوزيع المفضل والحديث لحزم بايثون؟",
            "options": [".zip", ".tar.gz", "Wheel (.whl)", ".egg"],
            "correctAnswer": "Wheel (.whl)"
          },
          {
            "question": "أي أمر سيستخدمه شخص ما لتثبيت الحزمة الخاصة بك من PyPI؟",
            "options": ["`pip download your-package-name`", "`pip install your-package-name`", "`pypi install your-package-name`", "`python get your-package-name`"],
            "correctAnswer": "`pip install your-package-name`"
          },
          {
            "question": "ما هو الغرض من تخطيط `src` في مشروع بايثون؟",
            "options": ["إنه مطلوب بموجب القانون.", "يفصل بوضوح كود المصدر الخاص بك عن ملفات المشروع الأخرى مثل الاختبارات والوثائق.", "يجعل الكود الخاص بك يعمل بشكل أسرع.", "إنه المكان الذي تخزن فيه الصور والأصول الأخرى."],
            "correctAnswer": "يفصل بوضوح كود المصدر الخاص بك عن ملفات المشروع الأخرى مثل الاختبارات والوثائق."
          }
        ],
        "pacing": "fast"
      },
      {
        "id": "40",
        "title": "الغوص العميق في المكررات والقابلات للتكرار",
        "description": "اكتساب فهم أعمق لبروتوكول التكرار في بايثون.",
        "content": [
          "لقد استخدمت حلقات `for` على نطاق واسع، ولكن كيف تعمل بالفعل؟ يكمن السحر في بروتوكول التكرار في بايثون، والذي يتضمن مفهومين: القابلات للتكرار والمكررات.",
          "**القابل للتكرار** هو أي كائن يمكن التكرار عليه. إنه أي شيء يمكن أن يوفر مكررًا. تشمل الأمثلة القوائم والصفوف والسلاسل النصية والقواميس. يكون الكائن قابلاً للتكرار إذا قام بتنفيذ تابع `__iter__` السحري.",
          "**المكرر** هو كائن يمثل دفقًا من البيانات. ينتج القيمة التالية في الدفق عند استدعاء `next()` عليه. يجب على المكرر تنفيذ تابع `__next__`. كما أنه ينفذ تابع `__iter__` (الذي يعيد نفسه فقط)، مما يجعل جميع المكررات قابلة للتكرار أيضًا.",
          "عندما تكتب `for item in my_list:`، يستدعي بايثون أولاً `iter(my_list)` للحصول على مكرر. ثم، في كل تكرار للحلقة، يستدعي `next()` على ذلك المكرر للحصول على العنصر التالي. عندما لا يكون هناك المزيد من العناصر، يثير المكرر استثناء `StopIteration`، الذي يخبر حلقة `for` بالإنهاء. يعد فهم هذا التمييز مفتاحًا لإتقان الموضوعات المتقدمة مثل المولدات."
        ],
        "codeExample": "my_list = [1, 2, 3]\n\n# الحصول على مكرر من القائمة القابلة للتكرار\nmy_iterator = iter(my_list)\n\nprint(f\"نوع my_list: {type(my_list)}\")\nprint(f\"نوع my_iterator: {type(my_iterator)}\")\n\n# استدعاء next() يدويًا على المكرر\nprint(\"استدعاء next() يدويًا:\")\nprint(next(my_iterator)) # الإخراج: 1\nprint(next(my_iterator)) # الإخراج: 2\nprint(next(my_iterator)) # الإخراج: 3\n\n# سيثير الاستدعاء التالي StopIteration\ntry:\n    next(my_iterator)\nexcept StopIteration:\n    print(\"تم إثارة StopIteration.\")",
        "quiz": [
          {
            "question": "ما الذي يجعل الكائن 'قابلاً للتكرار'؟",
            "options": ["يحتوي على تابع `__next__`", "يحتوي على تابع `__iter__`", "إنه قائمة", "يمكن تقطيعه"],
            "correctAnswer": "يحتوي على تابع `__iter__`"
          },
          {
            "question": "ماذا تفعل دالة `iter()` المدمجة؟",
            "options": ["تعيد العنصر التالي في تسلسل.", "تنشئ قائمة من صف.", "تستدعي تابع `__iter__` لكائن للحصول على مكرر.", "تتحقق مما إذا كان الكائن مكررًا."],
            "correctAnswer": "تستدعي تابع `__iter__` لكائن للحصول على مكرر."
          },
          {
            "question": "ما هو الاستثناء الذي يثيره المكرر عندما لا يكون لديه المزيد من العناصر؟",
            "options": ["`EndOfStreamError`", "`StopIteration`", "`IterationError`", "`NoMoreItems`"],
            "correctAnswer": "`StopIteration`"
          },
          {
            "question": "هل القائمة مكرر؟",
            "options": ["نعم", "لا"],
            "correctAnswer": "لا"
          },
          {
            "question": "هل المكرر قابل للتكرار؟",
            "options": ["نعم", "لا"],
            "correctAnswer": "نعم"
          }
        ],
        "pacing": "medium"
      },
      {
        "id": "41",
        "title": "تعبيرات المولدات",
        "description": "إنشاء مكررات فعالة من حيث الذاكرة بسرعة باستخدام بناء جملة مشابه لتعبيرات القائمة.",
        "content": [
          "لقد تعلمت عن دوال المولدات (باستخدام `yield`). توفر بايثون أيضًا **تعبيرات المولدات**، وهي تعميم عالي الأداء وفعال من حيث الذاكرة لتعبيرات القائمة ودوال المولدات.",
          "بناء الجملة يكاد يكون مطابقًا لتعبير القائمة، لكنك تستخدم الأقواس `()` بدلاً من الأقواس المربعة `[]`.",
          "على سبيل المثال، `my_list_comp = [x*x for x in range(10)]` ينشئ قائمة كاملة في الذاكرة. في المقابل، `my_gen_exp = (x*x for x in range(10))` ينشئ كائن مولد. لا يحسب أيًا من القيم حتى تبدأ في التكرار عليه.",
          "هذا يجعل تعبيرات المولدات مثالية عندما تقوم بالتكرار على النتائج مرة واحدة فقط، خاصة مع مجموعات البيانات الكبيرة جدًا. تحصل على فائدة التقييم الكسول دون الحاجة إلى كتابة دالة مولد كاملة."
        ],
        "codeExample": "import sys\n\n# تعبير القائمة (ينشئ قائمة كاملة في الذاكرة)\nlist_comp = [i for i in range(1000)]\n\n# تعبير المولد (ينشئ كائن مولد، ويستخدم القليل جدًا من الذاكرة)\ngen_exp = (i for i in range(1000))\n\nprint(\"استخدام الذاكرة:\")\nprint(f\"تعبير القائمة: {sys.getsizeof(list_comp)} بايت\")\nprint(f\"تعبير المولد: {sys.getsizeof(gen_exp)} بايت\")\n\n# لا يزال بإمكاننا التكرار على تعبير المولد\nsum_of_squares = sum(x*x for x in range(10))\nprint(f\"\\nمجموع المربعات من المولد: {sum_of_squares}\")",
        "quiz": [
          {
            "question": "ما هو بناء جملة تعبير المولد؟",
            "options": ["`[x for x in iterable]`", "`{x for x in iterable}`", "`(x for x in iterable)`", "`lambda x: x for x in iterable`"],
            "correctAnswer": "`(x for x in iterable)`"
          },
          {
            "question": "ما هي الميزة الأساسية لتعبير المولد على تعبير القائمة؟",
            "options": ["إنها أسرع للقوائم الصغيرة", "إنها أسهل في الكتابة", "إنها أكثر كفاءة في استخدام الذاكرة بسبب التقييم الكسول", "يمكن استخدامها كمفاتيح قاموس"],
            "correctAnswer": "إنها أكثر كفاءة في استخدام الذاكرة بسبب التقييم الكسول"
          },
          {
            "question": "ماذا يعيد تعبير المولد؟",
            "options": ["قائمة", "صف", "كائن مولد", "مجموعة"],
            "correctAnswer": "كائن مولد"
          },
          {
            "question": "إذا كنت بحاجة إلى التكرار على النتائج عدة مرات، أيها يجب أن تختار؟",
            "options": ["تعبير المولد", "تعبير القائمة"],
            "correctAnswer": "تعبير القائمة"
          },
          {
            "question": "أي من التالي هو حالة استخدام صالحة لتعبير المولد؟",
            "options": ["`my_list = (x for x in range(5))`", "`sum((x for x in range(100)))`", "`my_dict = {(x, x*x) for x in range(5)}`", "`my_set = [x for x in range(5)]`"],
            "correctAnswer": "`sum((x for x in range(100)))`"
          }
        ],
        "pacing": "fast"
      },
      {
        "id": "42",
        "title": "المزخرفات المتقدمة",
        "description": "استكشف المزخرفات التي تقبل الوسائط وتحافظ على البيانات الوصفية للدالة.",
        "content": [
          "المزخرفات الأساسية قوية، ولكن يمكننا جعلها أكثر مرونة. ماذا لو كنت تريد تمرير وسائط إلى المزخرف نفسه؟ يمكنك القيام بذلك عن طريق إضافة طبقة أخرى من تداخل الدوال. تقوم بإنشاء دالة تأخذ وسائط المزخرف وتعيد المزخرف الفعلي.",
          "مشكلة شائعة أخرى مع المزخرفات البسيطة هي أنها تخفي البيانات الوصفية للدالة الأصلية (مثل اسمها `__name__` وسلسلة التوثيق `__doc__`). الدالة التي يتم استدعاؤها هي في الواقع دالة `wrapper`، لذا ترى أدوات الاستبطان البيانات الوصفية للمغلف، وليس الأصلية.",
          "الحل هو استخدام `functools.wraps`. هذا مزخرف تقوم بتطبيقه على دالة `wrapper` الخاصة بك. يقوم بنسخ البيانات الوصفية من الدالة الأصلية (`func`) إلى دالة `wrapper`، مما يجعل مزخرفاتك أكثر شفافية وأسهل في التصحيح.",
          "تسمح لك هذه التقنيات المتقدمة ببناء مزخرفات قوية وقابلة للتكوين وقوية لمجموعة واسعة من التطبيقات."
        ],
        "codeExample": "import functools\n\n# مزخرف يقبل وسيطًا\ndef repeat(num_times):\n    def decorator_repeat(func):\n        @functools.wraps(func) # يحافظ على البيانات الوصفية\n        def wrapper(*args, **kwargs):\n            for _ in range(num_times):\n                value = func(*args, **kwargs)\n            return value\n        return wrapper\n    return decorator_repeat\n\n# استخدام المزخرف مع وسيط\n@repeat(num_times=3)\ndef greet(name):\n    \"\"\"يطبع تحية ودية.\"\"\"\n    print(f\"أهلاً، {name}!\")\n\ngreet(\"Alice\")\n\n# التحقق من البيانات الوصفية المحفوظة\nprint(f\"\\nاسم الدالة: {greet.__name__}\")\nprint(f\"سلسلة توثيق الدالة: {greet.__doc__}\")",
        "quiz": [
          {
            "question": "ما هو الغرض من `functools.wraps`؟",
            "options": ["لتوقيت تنفيذ دالة", "لنسخ البيانات الوصفية من الدالة الأصلية إلى دالة المغلف", "للسماح للمزخرفات بقبول الوسائط", "لتغليف الدالة في فئة"],
            "correctAnswer": "لنسخ البيانات الوصفية من الدالة الأصلية إلى دالة المغلف"
          },
          {
            "question": "كيف تنشئ مزخرفًا يقبل وسائطه الخاصة؟",
            "options": ["عن طريق إضافة طبقة إضافية من تداخل الدوال", "باستخدام فئة بدلاً من دالة", "هذا غير ممكن", "باستخدام الرمز `@` مرتين"],
            "correctAnswer": "عن طريق إضافة طبقة إضافية من تداخل الدوال"
          },
          {
            "question": "بدون `functools.wraps`، ماذا سيعيد `my_decorated_function.__name__` عادةً؟",
            "options": ["`my_decorated_function`", "`wrapper`", "`func`", "سيثير خطأ"],
            "correctAnswer": "`wrapper`"
          },
          {
            "question": "في دالة `wrapper` للمزخرف، لماذا من الممارسات الجيدة استخدام `*args` و `**kwargs`؟",
            "options": ["إنه شرط بناء جملة", "يجعل المزخرف عامًا، مما يسمح له بالعمل على أي دالة بغض النظر عن وسائطها", "يحسن الأداء", "هو فقط للمزخرفات التي تقبل الوسائط"],
            "correctAnswer": "يجعل المزخرف عامًا، مما يسمح له بالعمل على أي دالة بغض النظر عن وسائطها"
          },
          {
            "question": "أين تقوم بتطبيق المزخرف `@functools.wraps(func)`؟",
            "options": ["على الدالة الخارجية", "على الدالة التي يتم زخرفتها", "على دالة `wrapper` الداخلية", "في نهاية الملف"],
            "correctAnswer": "على دالة `wrapper` الداخلية"
          }
        ],
        "pacing": "fast"
      },
      {
        "id": "43",
        "title": "الدوال الجزئية",
        "description": "أنشئ دوال جديدة مع وسائط مملوءة مسبقًا من الدوال الحالية باستخدام `functools.partial`.",
        "content": [
          "توفر وحدة `functools` أداة مفيدة أخرى تسمى `partial`. الدالة الجزئية هي دالة جديدة يتم إنشاؤها عن طريق 'تجميد' بعض وسائط دالة موجودة.",
          "هذا مفيد عندما يكون لديك دالة تأخذ عدة وسائط، ولكنك تستدعيها بشكل متكرر بنفس القيم لبعض هذه الوسائط. يمكنك إنشاء دالة جديدة أبسط تحتوي بالفعل على هذه الوسائط مملوءة.",
          "على سبيل المثال، إذا كان لديك دالة `power(base, exponent)`، يمكنك إنشاء دالة `square(base)` عن طريق إنشاء دالة جزئية حيث يكون `exponent` دائمًا 2. أو دالة `cube(base)` حيث يكون `exponent` دائمًا 3.",
          "يساعد هذا في تقليل تكرار الكود ويمكن أن يجعل الكود الخاص بك أكثر قابلية للقراءة عن طريق إنشاء إصدارات متخصصة من الدوال الأكثر عمومية."
        ],
        "codeExample": "from functools import partial\n\n# دالة عامة لرفع رقم إلى قوة\ndef power(base, exponent):\n    return base ** exponent\n\n# إنشاء دالة جديدة 'square' حيث يكون الأس دائمًا 2\nsquare = partial(power, exponent=2)\n\n# إنشاء دالة جديدة 'cube' حيث يكون الأس دائمًا 3\ncube = partial(power, exponent=3)\n\n# استخدام الدوال الجديدة الأبسط\nprint(f\"3 تربيع هو: {square(3)}\")\nprint(f\"3 تكعيب هو: {cube(3)}\")\n\n# لا يزال بإمكانك استخدام الدالة الأصلية\nprint(f\"10 أس 5 هو: {power(10, 5)}\")",
        "quiz": [
          {
            "question": "ماذا تفعل `functools.partial`؟",
            "options": ["تجعل الدالة تعمل بشكل أسرع", "تنشئ دالة جديدة مع ملء بعض وسائط دالة موجودة مسبقًا", "تقسم دالة إلى دالتين أصغر", "تزخرف دالة"],
            "correctAnswer": "تنشئ دالة جديدة مع ملء بعض وسائط دالة موجودة مسبقًا"
          },
          {
            "question": "إذا كان لديك `f = partial(my_func, 10)`، ماذا يحدث عند استدعاء `f(20)`؟",
            "options": ["يستدعي `my_func(20)`", "يستدعي `my_func(10, 20)`", "يستدعي `my_func(20, 10)`", "يثير خطأ"],
            "correctAnswer": "يستدعي `my_func(10, 20)`"
          },
          {
            "question": "أي من التالي هو حالة استخدام جيدة لـ `partial`؟",
            "options": ["لإنشاء دالة تثير خطأ دائمًا", "عندما تريد تقليل عدد الوسائط التي تمررها بشكل متكرر إلى دالة", "لدمج دالتين في واحدة", "لجعل دالة تقبل `*args`"],
            "correctAnswer": "عندما تريد تقليل عدد الوسائط التي تمررها بشكل متكرر إلى دالة"
          },
          {
            "question": "يمكن استخدام `partial` لتجميد كل من الوسائط الموضعية والكلمات المفتاحية.",
            "options": ["صحيح", "خطأ"],
            "correctAnswer": "صحيح"
          },
          {
            "question": "إنشاء دالة جزئية `p = partial(f, ...)` يستدعي الدالة الأصلية `f` على الفور.",
            "options": ["صحيح", "خطأ"],
            "correctAnswer": "خطأ"
          }
        ],
        "pacing": "medium"
      },
      {
        "id": "44",
        "title": "أساسيات التعبيرات النمطية (Regex)",
        "description": "تعلم أساسيات استخدام التعبيرات النمطية لمطابقة الأنماط القوية في السلاسل النصية.",
        "content": [
          "التعبيرات النمطية (أو 'regex') هي لغة مصغرة قوية تستخدم للبحث عن الأنماط ومعالجتها داخل السلاسل النصية. في حين أنها يمكن أن تبدو مخيفة، إلا أنها أداة أساسية للعديد من مهام معالجة النصوص.",
          "توفر وحدة `re` في بايثون جميع الدوال اللازمة للعمل مع regex. الدوال الأكثر شيوعًا هي `re.search()` (للعثور على أول تطابق لنمط في أي مكان في سلسلة نصية)، `re.match()` (للعثور على تطابق فقط في بداية سلسلة نصية)، `re.findall()` (للعثور على جميع التطابقات غير المتداخلة)، و `re.sub()` (لاستبدال التطابقات بسلسلة نصية جديدة).",
          "يتم بناء أنماط Regex باستخدام أحرف التعريف الخاصة. على سبيل المثال، `.` يطابق أي حرف، `*` يطابق الحرف السابق صفرًا أو أكثر من المرات، `+` يطابق مرة واحدة أو أكثر، `\\d` يطابق أي رقم، و `\\s` يطابق أي حرف مسافة بيضاء. يمكن استخدام الأقواس المربعة `[]` لتعريف مجموعة من الأحرف للمطابقة (على سبيل المثال، `[aeiou]`).",
          "يعد تعلم regex مهارة تتطلب الممارسة، لكنها قوية بشكل لا يصدق لمهام مثل التحقق من صحة إدخال المستخدم (على سبيل المثال، التحقق مما إذا كانت السلسلة النصية عنوان بريد إلكتروني صالحًا)، وتحليل ملفات السجل، واستخراج البيانات من النصوص."
        ],
        "codeExample": "import re\n\ntext = \"رقم هاتف العميل هو 408-555-1234. اتصل قريبًا!\"\n\n# نمط للعثور على رقم هاتف (3 أرقام، شرطة، 3 أرقام، شرطة، 4 أرقام)\nphone_pattern = r'\\d{3}-\\d{3}-\\d{4}'\n\n# البحث عن النمط في النص\nmatch = re.search(phone_pattern, text)\n\nif match:\n    found_number = match.group(0)\n    print(f\"تم العثور على رقم الهاتف: {found_number}\")\nelse:\n    print(\"لم يتم العثور على رقم هاتف.\")\n\n# العثور على جميع الكلمات التي تبدأ بـ 'a' أو 's'\nwords = \"A sample sentence showing some stuff.\"\nfound_words = re.findall(r'\\b[as]\\w*', words, re.IGNORECASE)\nprint(f\"الكلمات التي تم العثور عليها: {found_words}\")",
        "quiz": [
          {
            "question": "ما هو الغرض من وحدة `re` في بايثون؟",
            "options": ["لقراءة الملفات", "لإجراء طلبات الشبكة", "للعمل مع التعبيرات النمطية", "لإدارة الموارد"],
            "correctAnswer": "للعمل مع التعبيرات النمطية"
          },
          {
            "question": "أي دالة `re` تجد جميع التطابقات غير المتداخلة لنمط في سلسلة نصية؟",
            "options": ["`re.search()`", "`re.match()`", "`re.sub()`", "`re.findall()`"],
            "correctAnswer": "`re.findall()`"
          },
          {
            "question": "في نمط regex، ماذا يطابق `\\d` عادةً؟",
            "options": ["أي حرف", "حرف مسافة بيضاء", "حرف رقم (0-9)", "حرف كلمة"],
            "correctAnswer": "حرف رقم (0-9)"
          },
          {
            "question": "ما الفرق بين `re.search()` و `re.match()`؟",
            "options": ["لا يوجد فرق.", "`re.search()` يجد تطابقًا في أي مكان، بينما `re.match()` يتحقق فقط من وجود تطابق في بداية السلسلة النصية.", "`re.match()` أسرع.", "`re.search()` يعيد سلسلة نصية، `re.match()` يعيد كائنًا."],
            "correctAnswer": "`re.search()` يجد تطابقًا في أي مكان، بينما `re.match()` يتحقق فقط من وجود تطابق في بداية السلسلة النصية."
          },
          {
            "question": "ماذا يعني المحدد الكمي `+` في تعبير نمطي؟",
            "options": ["مطابقة العنصر السابق مرة واحدة أو أكثر.", "مطابقة العنصر السابق صفرًا أو أكثر من المرات.", "مطابقة العنصر السابق صفرًا أو مرة واحدة.", "مطابقة علامة زائد حرفية."],
            "correctAnswer": "مطابقة العنصر السابق مرة واحدة أو أكثر."
          }
        ],
        "pacing": "medium"
      },
      {
        "id": "45",
        "title": "التسجيل",
        "description": "تجاوز عبارات `print()` وتعلم استخدام وحدة `logging` القوية في بايثون لمراقبة أفضل للتطبيقات.",
        "content": [
          "بينما يعد `print()` رائعًا لتصحيح الأخطاء البسيط، إلا أن له قيودًا في التطبيقات الأكبر. لا يمكنك إيقاف تشغيله بسهولة أو تصفية الرسائل أو توجيه المخرجات إلى أماكن مختلفة (مثل ملف ووحدة التحكم). تحل وحدة `logging` هذه المشكلات.",
          "توفر وحدة `logging` إطارًا مرنًا لإصدار رسائل السجل من برامج بايثون. تحدد عدة مستويات من الخطورة: `DEBUG`، `INFO`، `WARNING`، `ERROR`، و `CRITICAL`. يتيح لك هذا تصفية الرسائل بناءً على أهميتها.",
          "يمكنك تكوين نظام التسجيل للتحكم في تنسيق رسائل السجل الخاصة بك (على سبيل المثال، إضافة طابع زمني أو اسم الملف) وأين تذهب (المعالج 'handler'). على سبيل المثال، يمكنك الحصول على `StreamHandler` للطباعة إلى وحدة التحكم و `FileHandler` لحفظ السجلات في ملف.",
          "يعد استخدام التسجيل من البداية أفضل ممارسة لكتابة تطبيقات قابلة للصيانة. يتيح لك الحصول على رؤية قيمة لما يفعله تطبيقك في بيئة التطوير، والأهم من ذلك، في الإنتاج."
        ],
        "codeExample": "import logging\n\n# تكوين أساسي لتعيين المستوى والتنسيق\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(levelname)s - %(message)s'\n)\n\n# سيتم تسجيل هذه الرسائل لأنها INFO أو أعلى\nlogging.info(\"هذه رسالة إعلامية.\")\nlogging.warning(\"هذه رسالة تحذير.\")\nlogging.error(\"هذه رسالة خطأ.\")\n\n# لن يتم تسجيل هذه الرسالة لأن مستواها (DEBUG) أقل من المستوى الذي تم تكوينه (INFO)\nlogging.debug(\"هذه رسالة تصحيح أخطاء.\")\n\n# يمكنك أيضًا تسجيل بيانات متغيرة\nuser = 'Alice'\nlogging.info(f\"قام المستخدم {user} بتسجيل الدخول بنجاح.\")",
        "quiz": [
          {
            "question": "ما هي الميزة الرئيسية لوحدة `logging` على استخدام `print()`؟",
            "options": ["إنها أسرع.", "يمكنها تسجيل رسائل بمستويات خطورة مختلفة.", "يمكنها الطباعة فقط إلى وحدة التحكم.", "تتطلب كودًا أقل."],
            "correctAnswer": "يمكنها تسجيل رسائل بمستويات خطورة مختلفة."
          },
          {
            "question": "أي من مستويات التسجيل هذه هو الأعلى (الأكثر خطورة)؟",
            "options": ["DEBUG", "INFO", "WARNING", "CRITICAL"],
            "correctAnswer": "CRITICAL"
          },
          {
            "question": "إذا تم تعيين مستوى التسجيل على `WARNING`، فهل سيتم عرض رسالة مسجلة باستخدام `logging.INFO()`؟",
            "options": ["نعم", "لا"],
            "correctAnswer": "لا"
          },
          {
            "question": "ما هو 'المعالج' (handler) في سياق وحدة التسجيل؟",
            "options": ["دالة تعالج رسائل السجل", "مستوى خطورة", "كائن يحدد وجهة رسائل السجل (على سبيل المثال، وحدة التحكم، ملف)", "تنسيق رسالة سجل"],
            "correctAnswer": "كائن يحدد وجهة رسائل السجل (على سبيل المثال، وحدة التحكم، ملف)"
          },
          {
            "question": "ما هي الدالة المستخدمة للتكوين البسيط لمرة واحدة لنظام التسجيل؟",
            "options": ["`logging.setup()`", "`logging.configure()`", "`logging.basicConfig()`", "`logging.init()`"],
            "correctAnswer": "`logging.basicConfig()`"
          }
        ],
        "pacing": "medium"
      }
    ]
  }
}
